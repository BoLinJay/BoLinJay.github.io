{"pages":[],"posts":[{"title":"javascript面试题目","text":"一、JavaScript基础1、基本数据类型介绍所有的编程语言都有数据类型的概念。 在JavaScript中，数据类型可以分为基本数据类型和引用数据类型。其中基本数据类型包括Undefined,Null,Boolean,Number,String5种类型。在ES6中新增了一种基本的数据类型Symbol. 引用类型有Object,Function,Array,Date等。 问题：两种类型有什么区别？ 存储位置不同 区别 基本数据类型 引用数据类型 存储位置 栈(stack) 堆(heap) 占据空间 小，大小固定 大，大小不固定 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 下面我们先来回顾基本数据类型的内容，后面再复习引用类型的内容，以及看一下对应的常见的面试题。 1.1 Undefined类型Undefined类型只有一个唯一的字面值undefined,表示的含义是一个变量不存在。 问题：哪些场景中会出现undefined? 第一：使用只声明而未初始化的变量时，会返回undefined var a console.log(a) //undefined 第二：获取一个对象的某个不存在的属性时，会返回undefined var obj={ userName:'zhangsan' } console.log(obj.age)//undefined 第三：函数没有明确的返回值，却对函数的调用结果进行打印 function fn(){} console.log(fn()) //undefined 第四：函数定义的时候，使用了多个形参，但是在调用的时候传递的参数的数量少于形参数量，那么没有匹配上的参数就为undefined function fn(p1,p2,p3){ console.log(p3) //undefined } fn(1,2) 1.2 Null类型​ Null类型只有一个唯一的字面值null,表示一个空指针的对象，这也是在使用typeof运行符检测null值时会返回object的原因。 问题：哪些场景中会出现null？ 第一：一般情况下，如果声明的变量是为了以后保存某个值，则应该在声明时就将其赋值为null var obj=null function foo(){ return { userName:'zhangsan' } } obj=foo(); 第二：JavaScript在获取DOM元素时，如果没有获取到指定的元素对象，就会返回null document.querySelector('#id') //null 第三：在使用正则表达式进行匹配的时候，如果没有匹配的结果，就会返回null 'test'.match(/a/);// null 1.3 Undefined与null比较Undefined和Null虽然是两种不同的基本数据类型，但是在某些情况也存在相同之处，下面看一下它们两者相同点和不同点。 （1）相同点 第一：Undefined和Null两种数据类型都只有一个字面值，分别是undefined和null. 第二：Undefined和Null类型在转换为Boolean类型的值时，都会转换为false. 第三：在需要将两者转换成对象的时候，都会抛出一个TypeError的异常。 var a; var b=null; cosnole.log(a.name);//Cannot read property 'name' of undefined cosnole.log(b.name);//Cannot read property 'name' of undefined 第四：Undefined类型派生自Null类型，所以在非严格相等的比较下，两者是相等的。如下面代码所示： null==undefined //true (2)不同点 第一：null是JavaScript的关键字，而undefined是JavaScript的一个全局变量，也就是挂载在window对象上的一个变量，并不是关键字。 第二：在使用typeof运算符进行检测时，Undefined类型的值会返回undefined.而Null类型的值返回为object typeof undefined ;//undefined typeof null ;//object 第三：在需要进行字符串类型的转换时，null会转换成字符串null,而undefined会转换字符串undefined. undefined+&quot; abc&quot; //&quot;undefined abc&quot; null+&quot; abc&quot; //&quot;null abc&quot; 第四：在进行数值类型的转换时，undefined会转换为NaN,无法参与计算，而null会转换为0,可以参与计算。 undefined +0;// NaN null+0 ;// 0 第五：建议：无论在什么情况下都没有必要将一个变量显示的赋值为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null. 1.4 Boolean类型Boolean类型(布尔类型)的字面量只有两个，分别是true和false,它们是区分大小写的。 Boolean类型使用最多的场景就是用于if语句的判断。在JavaScript中，if语句可以接受任何类型的表达式，即if(a)语句中的a,可以是Boolean,Number,String,Object，Null,Undefined等类型。 如果a不是Boolean类型的值，那么JavaScript解析器会自动调用Boolean( )函数对a进行类型的转换，返回最终符合if语句判断的true或者是false值。 不同类型与Boolean类型的值的转换是Boolean类型的重点。 第一：String类型转换为Boolean类型 空字符都会转换成false,而任何非空字符串都会转换为true 第二：Number类型转换为Boolean类型 0和NaN都会转换为false.而除了0和NaN以外都会转换true. 第三：Object类型转换Boolean类型 如果object为null时，会转换为false,如果object不为null，则都会转换成true. var obj={} Boolean(obj) //true var obj=null Boolean(obj)//false 第四：Function类型转换Boolean类型 任何Function类型都会转换为true var fn=function(){ } Boolean(fn)//true 第五：Null类型转换为Boolean类型，我们知道Null类型只有一个null值，会转换为false. 第六：Undefined类型转换Boolean类型，我们知道Undefined类型只有一个undefined值，会转换为false. 1.5 Number类型在JavaScript中，Number类型的数据包括了整型数据，也包括了浮点型数据。 我们先来看一下整型的处理。整型可以是十进制，也可以通过八进制或者是十六进制来表示。 第一：八进制：如果想要用八进制来表示一个数值，那么首位必须是0，其它位必须是0–7的数字，如果后面的数字大于7，则破坏了八进制的规则，这时会被当作十进制数来处理。 var num1=024 console.log(num1) //20 var num2=079 console.log(num2) //79 num1第一位是0表示八进制，后面每位数字都是在0--7之间的，所以符合八进制规则，最终转换为十进制为20 num2的第一位也是0，但是最后一位已经超过了7，所以不属于八进制，这里直接作为十进制来处理，最终输出的结果为79. 第二：十六进制： 如果想用十六进制表示一个数值，那么前面两位必须是0x,其它的位必须是(0–9,a--f或者A--F).如果超出了这个范围，则会抛出异常。 var num1=0x5f //95 var num2=Ox5h //Uncaught SyntaxError: Invalid or unexpected token 与Boolean类型一样，当其它类型在与Number类型进行数据转换时，也会遵守一定的规则。 1.5.1 Number类型转换在实际开发中，我们经常会遇到将其他类型的值转换为Number类型的情况。在JavaScript中，一共有3个函数可以完成这种转换，分别是Number()函数，parseInt( )函数,parseFloat( )函数。下面我们看一下这些函数需要注意的事项。 Number( )函数 Number( )函数可以用于将任何类型转换为Number类型，它在转换时遵循如下规则： 第一：如果是数字，会按照对应的进制数据格式，统一转换为十进制返回。 Number(10) //10 Number(010) // 8, 010是八进制的数据，转换成十进制是8 Number(0x10) // 16,0x10是十六进制的数据，转换成十进制是16 第二：如果是Boolean类型的值，true返回1,false返回是的0 Number(true) //1 Number(false) //0 第三：如果值为null,则返回0 Number(null) //0 第四：如果值为undefined,则返回NaN Number(undefined) //NaN 第五：如果值为字符串类型，需要遵循如下规则 （1）如果该字符串只包含了数字，则会直接转换成十进制数；如果数字前面有0，则会直接忽略掉这个0。 Number('21') //21 Number('012') //12 (2) 如果字符串是有效的浮点数形式，则会直接转成对应的浮点数，前置的多个重复的0会被删除，只保留一个。 Number('0.12') //0.12 Number('00.12') //0.12 (3)如果字符串是有效的十六进制形式，则会转换为对应的十进制数值 Number('0x12') //18 (4) 如果字符串是有效的八进制，则不会按照八进制转换，而是直接按照十进制转换并输出，因为前置的0会被直接忽略掉。 Number('010') //10 Number('0020') //20 (5)如果字符串为空，即字符串不包含任何字符，或为连续多个空格，则会转换为0. Number('') //0 Number(' ')//0 (6)如果字符串中包含了任何不适以上5种情况的其它格式内容，则会返回NaN Number('123a') //NaN Number('abc') //NaN 第六：如果是对象类型，则会调用对象的valueOf( )函数获取返回值，并且判断返回值能否转换为Number类型，如果不能，会调用对象的toString( )函数获取返回值，并且判断是否能够转换为Number类型。如果也不满足，则返回NaN. 以下是通过valueOf( )函数将对象转换成Number类型。 var obj={ age:'12', valueOf:function(){ return this.age }, } Number(obj) //12 以下是通过toString( )函数将对象转换成Number类型。 var obj={ age:'21', toString:function(){ return this.age } } Number(obj) parseInt( )函数 parseInt()函数用于解析一个字符串，并返回指定的基数对应的整数值。 语法格式： parseInt(string,radix) 其中string参数表示要被解析的值，如果该参数不是一个字符串，那么会使用toString( )函数将其转换成字符串。并且字符串前面的空白符会被忽略。 radix表示的是进制转换的基数，可以是二进制，十进制，八进制和十六进制。默认值为10. 因为对相同的数采用不同进制进行处理时可能会得到不同的结果，所以在任何情况下使用parseInt函数时，建议都手动补充第二个参数。 parseInt( )函数会返回字符串解析后的整数值，如果该字符串无法转换成Number类型，则会返回NaN. parseInt('aaa')//NaN 在使用parseInt函数将字符串转换成整数时，需要注意的问题： 第一：如果遇到传入的参数是非字符串类型的情况，则需要将其优先转换成字符串类型。即使传入的是整型数据。 第二：parseInt( )函数在做转换时，对于传入的字符串会采用前置匹配的原则。 parseInt(&quot;fg123&quot;,16) 对于字符串fg123,首先从第一个字符开始，f是满足十六进制的数据的，因为十六进制数据的范围是0--9,a--f,所以保留f，然后是第二个字符g，它不满足十六进制数据范围，因此从第二个字符都最后一个字符全部舍弃，最终字符串只保留了字符f，然后将字符f转换成十六进制的数据，为15，因此最终返回的结果为15. 还要注意的一点就是，如果传入的字符串中涉及到了算术运算，则不会执行，算术符号会被当作字符处理。 parseInt('16*2')// 16,这里直接当作字符串处理，并不会进行乘法的运算 parseInt(16*2) // 32 第三：对浮点数的处理 如果传入的值是浮点数，则会忽略小数点以及后面的数，直接取整。 parseInt(12.98) //12 第四：map( )函数与parseInt( )函数的问题 我们这里假设有一个场景，存在一个数组，数组中的每个元素都是数字字符串，[‘1’,’2’,’3’,’4’]，如果将这个数组中的元素全部转换成整数，应该怎样处理呢？ 这里我们可能会想到使用map( )函数，然后在该函数中调用parseInt( )函数来完成转换。所以代码如下： &lt;script&gt; var arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]; var result = arr.map(parseInt); console.log(result); &lt;/script&gt; 执行上面程序得到的结果是：[1,NaN,NaN,NaN] 为什么会出现这样的问题呢？ 上面的代码等效如下的代码 var arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]; // var result = arr.map(parseInt); var result = arr.map(function (val, index) { return parseInt(val, index); }); console.log(result); 通过以上的代码，可以发现，parseInt函数第二个参数实际上就是数组的索引值。所以，整体的形式如下所示： parseInt('1',0) // 任何整数以0为基数取整时，都会返回本身，所以这里返回的是1 parseInt('2',1) //注意parseInt第二个参数的取值范围为2--36，所以不满足条件，这里只能返回NaN parseInt('3',2) // 表示将3作为二进制来进行处理，但是二进制只有0和1，所以3超出了范围，无法转换，返回`NaN` parseInt('4',3) //将4作为三进制来处理，但是4无法用三进制的数据表示，返回NaN 所以当我们在map( )函数中使用parseInt( )函数时，不能直接将parseInt( )函数作为map( )函数的参数，而是需要在map( )函数的回调函数中使用,并尽量指定基数。代码如下所示： var arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]; var result = arr.map(function (val) { return parseInt(val, 10); }); console.log(result); parseFloat( )函数 parseFloat函数用于解析一个字符串，返回对应的浮点数，如果给定值不能转换为数值，则返回NaN 与parseInt( )函数相比，parseFloat( )函数没有进制的概念。 注意: 第一：如果字符串前面有空白符，则会直接忽略掉，如果第一个字符就无法解析，则会直接返回NaN parseFloat(' 2.6')// 2.6 parseFloat('f2.6') //NaN 第二：对于小数点，只能正确匹配第一个，第二个小数点是无效的，它后面的字符也都将被忽略。 parseFloat('12.23')// 12.23 parseFloat('12.23.39')//12.23 总结: 虽然Number( ),parseInt( ),parseFloat( )函数都能勇于Number类型的转换，但是他们之间还是有一定的差异 第一：Number( ) 函数转换的是传入的整个值，并不是像parseInt( )函数和parseFloat( )函数一样会从首位开始匹配符合条件的值。如果整个值不能被完整转换，则会返回NaN 第二：parseFloat( )返回对应的浮点数，parseInt( )返回整数，并且parseFloat( )函数在解析时没有进制的概念，而parseInt() 函数在解析时会依赖于出入的第二个参数来做值的转换。 1.5.2 isNaN( )函数与Number.isNaN( )函数对比Number类型数据中存在一个比较特殊的值NaN（Not a Number）,它表示应该返回数值却并未返回数值的情况。 NaN存在的目的是在某些异常情况下保证程序的正常执行。例如0/0，在其他的语言中，程序会直接抛出异常，而在JavaScript中会返回NaN,程序可以正常运行。 NaN有两个很明显的特点，第一个是任何涉及NaN的操作都会返回NaN,第二个是NaN与任何值都不相等，即使是与NaN本身相比。 NaN==NaN //false 在判断NaN时，ES5提供了isNaN函数，ES6为Number类型增加了静态函数isNaN( ). 问题：既然在ES5中提供了isNaN函数，为什么要在ES6中专门增加Number.isNaN( )函数呢？两者在使用上有什么区别？我们先来看一下isNaN( )函数 isNaN( )函数的作用是用来确定一个变量是不是NaN,NaN是一个Number类型的数值，只不过这个值无法用真实的数字表示。 isNaN检测的机制：它在处理的时候会去判断传入的变量值能否转为数字，如果能转换成数字则会返回false,如果无法转换则会返回true. isNaN(NaN)//true isNaN(undefined) //true isNaN({})//true isNaN(true)// false ,Number(true)会转换成数字1 isNaN(false)// false,Number(false)会转换成数字0 isNaN(null) // false,Number(null)会转换成数字0 isNaN(1) //false isNaN('aaa') //true 字符串aaa无法转换成数字 isNaN('1') //false 字符串“1”可以转换成数字1. **Number.isNaN( )**函数 既然在全局的环境中有了isNaN( )函数，为什么在ES6中会专门针对Number类型增加一个isNaN函数呢？ 这是因为全局的isNaN函数本身存在误导性，而ES6中的Number.isNaN( )函数会在真正意义上去判断变量是否为NaN,不会做数据类型转换。只有在传入的值为NaN,才会返回true,传入其它类型的值时会返回false. Number.isNaN(NaN)// true Number.isNaN(1) //false Number.isNaN(null) //false Number.isNaN(undefined) //false 如果在非ES6环境中想用ES6中的isNaN( )函数，怎样处理呢？ if(!Number.isNaN){ Number.isNaN=function(n){ return n!==n } } 在所有类型的数据中，如果一个变量和自身进行比较，只有在变量为NaN时才会返回false,其它情况都是返回的true. 所以n!==n返回true,也只有在n的值为NaN的时候才会成立。 总结： isNaN( )函数与Number.isNaN( )函数的区别如下： 第一：isNaN( )函数在判断是否为NaN时，需要进行数据类型转换，只有在无法转换为数字时才会返回true 第二：Number.isNaN( )函数在判断是否为NaN时，只需要判断传入的值是否为NaN,并不会进行数据类型转换。 1.6 String类型在JavaScript中的String类型可以通过双引号表示，也可以通过单引号表示，并且这两种方式是完全等效的。 1.6.1 String类型定义在JavaScript中有3种方式来创建字符串，分别是字符串字面量，直接调用String( )函数，还有就是通过new String( )构造函数的方式。 字面量 字符串字面量就是直接通过单引号或者是双引号定义字符串的方式。 注意：单引号和双引号是等价的。 var str='hello' var str2=&quot;JavaScript&quot; 直接调用String( )函数 直接调用String( )函数，会将传入的任何类型的值转换成字符串类型。在转换的时候，需要遵循如下的规则： 第一：如果是Number类型的值，则直接转换成对应的字符串。 String(123) // '123' String(123.56) // &quot;123.56&quot; 第二：如果是Boolean类型的值，则直接转换成字符串的&quot;true&quot;或者是&quot;false&quot; String(true)// &quot;true&quot; String(false) // &quot;false&quot; 第三：如果值为null,直接转换成字符串的&quot;null&quot; String(null) // &quot;null&quot; 第四：如果值为undefined,则转换成字符串的undefined String(undefined) //&quot;undefined&quot; new String( )构造函数 这种方式是使用new运算符来创建一个String的实例。转换的规则和String( )函数是一样的，最后返回的是一个String类型的对象实例。 new String(678) //返回的对象中有length属性，并且可以通过下标获取对应的值。 三种创建方式的区别 使用字符串字面量方式和直接调用String( )函数的方式得到的字符串都是基本字符串，而通过new String( )方式生成的字符串是字符串对象。 基本字符串在比较的时候，只需要比较字符串的值即可，而在比较字符串对象时，比较的是对象所在的地址。 var str='hello' var str2=String('hello') str===str2 //true var str3=new String('hello') var str4=new String('hello') str3===str4 //false 对于str与str2都是基本字符串，只是比较字符串的值就可以了，所以两者是相等的。 而对于str3与str4都是通过String类型的实例，所以在比较的时候需要判断变量是否指向了同一个对象，也就是内存地址是否相同，很明显，str3与str4都是在内存中新生成的地址，彼此各不相同。 函数调用 在String对象的原型链有一系列的函数，例如indexOf( ),substring()等等。 通过String对象的实例可以调用这些函数做字符串的处理。 但是，我们发现了一个问题，就是采用字面量方式定义的字符串也能够直接调用原型链上的这些函数。 'hello'.indexOf('o') //4 这是为什么呢？ 实际上基本字符串本身是没有字符串对象上的这些函数的，而在基本字符串调用字符串对象才有的函数时，JavaScript会自动将基本字符串转换为字符串对象，形成一种包装的类型，这样基本字符串就可以正常调用字符串对象的方法了。 1.6.2 字符串常见算法我们来看一下常见的String类型中的算法，这些在面试的时候也是经常被问到的。 第一：字符串逆序输出 字符串逆序输出就是将一个字符串以相反的顺序进行输出。 例如abcdef输出的结果是fedcba 第一种算法 这里我们是借助与数组的reverse()函数来实现。 function reverseString(str) { return str.split(&quot;&quot;).reverse().join(&quot;&quot;); } console.log(reverseString(&quot;abcdef&quot;)); 第二种算法： var arr=Array.from('abcdef') //转换成数组,这里比第一种方式简单 console.log(arr.reverse().join(&quot;&quot;)) 第三种算法： 这里可以通过字符串本身提供的chartAt函数来完成。 function reverseString2(str) { var result = &quot;&quot;; for (var i = str.length - 1; i &gt;= 0; i--) { result += str.charAt(i); } return result; } console.log(reverseString2(&quot;abcdef&quot;)); 统计字符串中出现次数最多的字符及出现的次数 假如有一个字符串javascriptjavaabc,其中出现最多的字符是a,出现了5次。 算法1 思想：通过key-value形式的对象存储字符串以及字符串出现的次数，然后逐个判断出现次数最大的值，同时获取对应的字符。 &lt;script&gt; function getMaxCount(str) { var json = {}; //表示key-value结构的对象 //遍历str的每一个字符得到key-value形式的对象 for (var i = 0; i &lt; str.length; i++) { //判断json对象中是否有当前从str字符串中取出来的某个字符。 if (!json[str.charAt(i)]) { //如果不存在，把当前字符作为key添加到json对象中，值为1 json[str.charAt(i)] = 1; } else { //如果存在，则让value值加1 json[str.charAt(i)]++; } } //存储出现次数最多的字符 var maxCountChar = &quot;&quot;; //存储出现最多的次数 var maxCount = 0; //遍历json对象，找出出现次数最大的值 for (var key in json) { if (json[key] &gt; maxCount) { maxCount = json[key]; maxCountChar = key; } } return ( &quot;出现最多的字符是&quot; + maxCountChar + &quot;,共出现了&quot; + maxCount + &quot;次&quot; ); } var str = &quot;javascriptjavaabc&quot;; console.log(getMaxCount(str)); &lt;/script&gt; 算法2 思路：这里主要是对字符串进行排序，然后通过lastIndexOf()函数获取索引值后，判断索引值的大小以获取出现的最大次数。 function getMaxCount(str) { //定义两个变量,分别表示出现最大次数和对应的字符。 var maxCount = 0, maxCountChar = &quot;&quot;; //处理成数组，调用sort()函数排序，再处理成字符串 str = str.split(&quot;&quot;).sort().join(&quot;&quot;); for (var i = 0, j = str.length; i &lt; j; i++) { var char = str[i]; //计算每个字符出现的次数 var charCount = str.lastIndexOf(char) - i + 1; //与次数最大值进行比较 if (charCount &gt; maxCount) { //更新maxCount与maxCountChar的值 maxCount = charCount; maxCountChar = char; } //变更索引为字符出现的最后位置 i = str.lastIndexOf(char); } return &quot;出现最多的字符是&quot; + maxCountChar + &quot;,出现次数为&quot; + maxCount; } console.log(getMaxCount(&quot;caa&quot;)); 去除字符串中重复的字符 假如存在一个字符串&quot;javascriptjavaabc&quot;,其中存有重复的字符，现在需要将这些重复的字符去掉，只保留一个。 function removeStringChar(str) { //结果数组 var result = []; //key-value形式的对象 var json = {}; for (var i = 0; i &lt; str.length; i++) { //当前处理的字符 var char = str[i]; //判断是否在对象中 if (!json[char]) { //将value值设置为true json[char] = true; //添加到结果数组中 result.push(char); } } return result.join(&quot;&quot;); } var str = &quot;javascriptjavaabc&quot;; console.log(removeStringChar(str)); 算法2 这里可以使用ES6中的Set数据结构，可以结构具有自动去重的特性，可以直接将数组元素去重。 下面先来看一下Set的基本使用方式 const set = new Set([1,2,3,4,4,]); //console.log(set) // Set(4) {1, 2, 3, 4} [...set] // [1, 2, 3, 4] 通过扩展运算符将set中的内容转换成数组，同时可以看到已经去重。 基本思路： （1）将字符串处理成数组，然后作为参数传递给Set的构造函数，通过new运算符生成一个Set实例。 (2) 将Set通过扩展运算符(…)转换成数组的形式，最终转换成字符串获得需要的结果。 function removeStringChar(str) { let set = new Set(str.split(&quot;&quot;)); return [...set].join(&quot;&quot;); } var str = &quot;javascriptjavaabc&quot;; console.log(removeStringChar(str)); 判断一个字符串是否为回文字符串 回文字符串指的是一个字符串正序和倒序是相同的，例如字符串abcdcba是一个回文字符串，而字符串abcedba就不是一个回文字符串。 需要注意的是，这里不区分字符的大小写，即a和A在判断的时候是相等的。 算法1 主要思想是将字符串按从前往后顺序的字符与按从后往前顺序的字符逐个进行比较，如果遇到不一样的值则直接返回false,否则返回true. function isEequStr(str) { //空字符串则直接返回true if (!str.length) { return true; } //统一转换成小写，同时再将其转换成数组 str = str.toLowerCase().split(&quot;&quot;); var start = 0, end = str.length - 1; //通过while循环，判断正序和倒序的字母 while (start &lt; end) { // 如果相等则更改比较的索引 if (str[start] === str[end]) { start++; end--; } else { return false; } } return true; } var str = &quot;abcdcba&quot;; 算法2 思想：将字符串进行逆序的处理，然后与原来的字符串进行比较，如果相等则表示是回文字符串，否则不是回文字符串。 function isEequStr(str) { //字符串统一转换成小写的形式 str = str.toLowerCase(); //将字符串转换成数组 var arr = str.split(&quot;&quot;); //将数组逆序并转换成字符串 var reverseStr = arr.reverse().join(&quot;&quot;); return str === reverseStr; } console.log(isEequStr(&quot;abccba&quot;)); 2、运算符在JavaScript中的运算符包括：算术运算符，关系运算符，等于运算符，位运算符(与、或、非)等 2.1 等于运算符在JavaScript中等于分为双等(==)比较，和三等于(===)比较。 2.1.1 三等于运算符(1)如果比较的值类型不相同，则直接返回false 1==='1' //false true==='true' //false 这里还需要注意的一点就是，基本数据类型存在包装类型，在没有使用new操作符时，简单类型的比较实际上就是值的比较，而使用了new操作符以后，实际得到的是引用类型的值，在判断时会因为类型不同而直接返回false 1===Number(1) //true 1===new Number(1) //false 'hello'===String('hello') //true 'hello'===new String('hello') //false (2) 如果比较的值都是数值类型，则直接比较值的大小，相等则返回true,否则返回false,需要注意的是，如果参与比较的值中有任何一方为NaN,则返回false 26===26 //true 34===NaN //false （3）如果比较的值是字符串类型，则判断每个字符是否相等，如果全部相等，返回true,否则返回false 'abc'==='abc' //true 'abc'==='abd' //false （4）关于null与undefined比较 null===null //true undefined===undefined //true undefined===null //false (5)如果比较的值都是引用类型，则比较的是引用类型的地址，当两个引用指向同一个地址时，则返回true,否则返回false var a=[] var b=a var c=[] console.log(a===b) //true console.log(a===c) //false new String('hello')===new String('hello')//false 两个不同对象，地址不相同 //创建构造函数 function Person(userName) { this.userName = userName; } var p1 = new Person(&quot;wangwu&quot;); var p2 = new Person(&quot;wangwu&quot;); console.log(p1 === p2);//false 两个不同对象，地址不相同 2.1.2 双等于运算符相比于三等于运算符，双等于运算符在进行相等比较的时候，要复杂一点。因为它不区分数据类型，而且会做隐式类型的转换。 双等于在进行比较的时候要注意的点： 如果比较的值类型不相同，则会按照下面的规则进行转换后再进行比较 (1) 如果比较的一方是null或者是undefined,只有在另一方是null或者是undefined的情况下才返回true,否则返回false null==undefined //true null==1 //false undefined==2 //false （2）如果比较的是字符串和数值类型数据，则会将字符串转换为数值后再进行比较，如果转换后的数值是相等的则返回true,否则返回false. 1=='1' //true '222'==222 //true （3）如果比较的时候，有一方的类型是boolean类型，会将boolean类型进行转换，true转换为1,false转换0，然后在进行比较。 '1'==true '2'==true //false '0'==false //true 2.2 typeof运算符typeof运算符用于返回对应的数据类型， 基本的使用方式 typeof operator typeof (operator) operator表示要返回类型的操作数，可以是引用类型，也可以是基本数据类型。 括号有时候是必须的，如果不加上括号将会因为优先级的问题，而得不到我们想要的结果。 下面我们看一下typeof的使用场景 （1）处理Undefined类型 我们知道Undefined类型的值只有一个undefined,typeof运算符在处理如下情况的时候，返回的结果都是undefined 处理undefined本身 未声明的变量 已经声明但是没有初始化的变量 typeof undefined //&quot;undefined&quot; typeof abc //&quot;undefined&quot; ,未声明的变量abc，通过typeof返回的是undefined var sum typeof sum //undefined 已经声明但是没有初始化的变量 (2)处理Boolean类型的值 Boolean类型的值有两个，分别是true和false,typeof运算符在处理这两个值的时候返回都是boolean var b=true typeof b //&quot;boolean&quot; (3) 处理Number类型的值 对于Number类型的数，typeof运算符在处理时会返回number typeof 666 //number typeof 66.66 //number （4）处理String类型的值 字符串类型，typeof返回的是string,包括空字符串。 typeof 'aaa' //string typeof '' //string (5)处理Function类型的值 函数的定义，包括函数的声明，typeof返回的值function function fun(){} typeof fun // &quot;function&quot; var fun2=function(){} typeof fun2 // &quot;function&quot; 关于通过class关键字定义的类，通过typoef计算返回的值也是function class Obj{ } typeof Obj // &quot;function&quot; class是在ES6中新增的一个关键字，原理依旧是原型继承，也就是说本质上仍然是一个Function (6) 处理Object类型的值 对象字面量的形式，返回的是object var obj={userName:'zhangsan'} typeof obj //&quot;object&quot; 数组，通过typeof计算返回的值是object var arr=[1,2,3] typeof arr // &quot;object&quot; var arr2=new Array() typeof arr2 //&quot;object&quot; (7) typeof运算符对null的处理 typeof运算符对null的处理，返回的是object typeof null //object 注意：在前面我们提到过，在使用typeof的时候，括号有时候是必须的，如果不加上括号会因为优先级问题，得不到我们想要的结果。 例如如下代码所示： var num=123 typeof (num + 'hello')// string typeof num + &quot; hello&quot; //&quot;number hello&quot; 通过上面的代码，我们知道typeof运算符的优先级要高于字符串的拼接运算符(+),但是优先级低于小括号，所以在未使用括号时，会优先处理typeof num, 返回的是number,然后与hello字符串进行拼接，得到的最终的结果就是number hello 下面，我们再来看一段代码 typeof 6/2 // NaN 在上面的代码中，会先执行typeof 6 得到的结果为number,然后除以2，一个字符串除以2，得到的结果为NaN typeof (6/2) //&quot;number&quot; 这里会先计算括号中的内容，然后在通过typeof进行计算。 3、常用的判空方法在JavaScript中判断一个变量是否为空，我们往往会想到对变量取反，然后判断是否为true if(!x){ } 这是一个非常简单的判断变量是否为空的方法，但是其实涉及到的场景却很多，这里我们就分情况来看一下。 （1）判断变量为空对象 判断变量为null或者为undefined 判断一个变量是否为空时，可以直接将变量与null或者是undefined进行比较，需要注意的是双等号和三等好直接的区别。 if(obj==null) //可以判断null或者是undefined的情况 if(obj===undefined) //只能判断undefined的情况 判断变量为空对象{ } 判断一个变量是否为空对象时，可以通过for...in语句遍历变量的属性，然后调用hasOwnProperty( )函数，判断是否有自身存在的属性，如果存在就不是空对象，如果不存在自身的属性（不包括继承的属性），那么变量为空对象。 function isEmpty(obj) { for (let key in obj) { if (obj.hasOwnProperty(key)) { return false; } } return true; } var obj = { username: &quot;zhangsan&quot;, }; console.log(isEmpty(obj));// false,表明obj这个对象是有自己的属性，所以不是空对象 var obj = {}; console.log(isEmpty(obj));//true,这里将obj对象的属性去掉了，返回的值为true,表明没有自己的属性，表示空对象 //这里通过构造函数的形式创建对象，并且指定了age属性 function Person() { this.age = 20; } var p = new Person(); console.log(isEmpty(p));//false 下面看一下另外一种情况 function Person() {} Person.prototype.userName = &quot;zhangsan&quot;; var p = new Person(); console.log(isEmpty(p)); //true 在上面的代码中，变量p是通过new操作符得到的Person对象的实例，所以p会继承Person原型链上的userName属性，但是因为不是自身的属性，所以会被判断为空，所以返回true. (2)判断变量为空数组 判断变量是否为空数组时，首先要判断变量是否为数组，然后通过数组的length属性确定。(instanceof 用于判断一个变量是否某个对象的实例) var arr=new Array() arr instanceof Array &amp;&amp; arr.length===0 以上两个条件都满足时，变量就是一个空数组。 (3) 判断变量为空字符串 判断变量是否为空字符串时，可以直接将其与空字符串进行比较，或者调用trim()函数去掉前后的空格以后，在去判断字符串的长度。 str==''||str.trim().length==0 当满足以上两个条件中的任意一个时，变量就是一个空字符串。 （4）判断变量为0或者NaN 当一个变量为Number类型时，判断变量是否为0或者NaN,因为NaN与任何值比较都是false,所以这里我们通过取非来完成判断。 !(Number(num)&amp;&amp;num)==true 当上述代码返回的结果为true，表明变量为0或者是NaN （5） 在最开始的时候，我们提到的 在JavaScript中判断一个变量是否为空，我们往往会想到对变量取反，然后判断是否为true if(!x){ } 这种方式会包含多种情况，下面我们总结一下： 变量为null 变量为undefined 变量为空字符串'' 变量为数字0 变量为NaN 4、流程控制关于流程控制这块内容，这里我们重点看一下Switch结构 看一下如下代码执行的结果 &lt;script&gt; function getStringValue(str) { switch (str) { case &quot;1&quot;: console.log(&quot;a&quot;); break; case &quot;2&quot;: console.log(&quot;b&quot;); break; case &quot;3&quot;: console.log(&quot;c&quot;); break; default: console.log(&quot;d&quot;); } } getStringValue(&quot;2&quot;); //b getStringValue(&quot;5&quot;); //d &lt;/script&gt; 以上的代码非常简单。分别输出的是b和d 但是，这里我们把对getStringValue函数的调用修改成如下的形式： getStringValue(3) //d 这里将参数修改成数字3，得到的结果是d.原因是：在JavaScript中的关于case的比较是采用严格相等的方式(===)。在上面的函数调用中，传递的是数字类型的3，而在case中比较的是String字符串的’3’,两者按照严格方式进行对比，是不相等的。所以只能执行default,输出字母d. 下面，再来看如下的调用 getStringValue(String(&quot;3&quot;)); //c 上面调用的结果是c. 在前面的课程中，我们讲解过：字符串的字面量和直接调用String( )函数生成的字符串都是基本的字符串，它们在本质上都是一样的。 所以在严格模式下进行比较是相等的。 String('3')==='3' //true 下面再来看另外一种调用方式 getStringValue(new String(&quot;3&quot;)); //d 通过new关键字创建的是字符串对象，这里采用严格模式进行比较，比较的是字符串对象的内存地址是否相同。而当与字符串的字面量进行比较时，会返回false. new String('3')==='3' //false 所以在运行整个getStringValue整个函数的时候，得到的结果为d. 二、引用数据类型引用类型有Object,Function,Array,Date，Math等。 引用类型与基本数据类型的区别: (1)引用数据类型的实例需要通过new关键字创建。 (2)将引用数据类型赋值给变量，实际上赋值的是内存地址 (3)引用数据类型的比较是对内存地址的比较，而基本数据类型的比较是对值的比较。 1、Object类型Object类型是JavaScript中使用最多的一个类型。 大部分的引用数据类型都是Object类型。 由于引用数据类型的实例都是通过new关键字来创建的，所以我们先来探讨有关new操作相关的问题。 1.1 new 操作符的作用new操作符在执行过程中会改变this的指向，所以下面我们先来看一下this的用法。 &lt;script&gt; function Person(userName, age) { this.userName = userName; this.age = age; } console.log(new Person(&quot;zhangsan&quot;, 20)); &lt;/script&gt; 执行上面的代码，发现输出的是一个Person对象，包含了userName和age的数据。 但是，问题是，在构造函数Person中，我们没有添加return,为什么会有返回值呢？ 其实就是this这个关键字起作用。 &lt;script&gt; function Person(userName, age) { console.log(this);//输出的是Person{ }对象 this.userName = userName; this.age = age; } new Person(&quot;zhangsan&quot;, 20); &lt;/script&gt; 执行上面的代码，我们可以看到this 这里就是一个Person的空对象，后面的两行代码就相当于给Person对象添加了userName和age这两个属性。 下面我们把代码修改成如下的形式： &lt;script&gt; function Person(userName, age) { var Person = {}; Person.userName = userName; Person.age = age; } console.log(new Person(&quot;zhangsan&quot;, 20)); &lt;/script&gt; 以上打印的结果中，输出的是Person{}，并没有包含userName和age,原因是什么呢？ 因为在 构造函数中如果没有添加return,则默认返回的是return this. 修改后的代码如下： &lt;script&gt; function Person(userName, age) { var Person = {}; Person.userName = userName; Person.age = age; return Person; } console.log(new Person(&quot;zhangsan&quot;, 20)); &lt;/script&gt; 对this有了一个简单的了解以后，下面重点看如下代码 var person= new Person(&quot;zhangsan&quot;, 20) 从上面的代码中，主要的作用就是创建一个Person对象，然后赋值给了person这个变量，该变量中包含了Person对象中的属性和函数。 其实，在new操作符做了如下3件事情。 var person={}; person.__proto__=Person.prototype; Person.call(person) 1.2 原型对象理解函数对象的 prototype 属性我们创建的每一个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，简单来说，该函数实例化的所有对象的__proto__的属性指向这个对象，它是该函数所有实例化对象的原型。 function Person(){ } // 为原型对象添加方法 Person.prototype.sayName = function(){ alert(this.name); } 下面我们来看一下它们之间的关系。 简易图 constructor 属性当函数创建，prototype 属性指向一个原型对象时，在默认情况下，这个原型对象将会获得一个 constructor 属性，这个属性是一个指针，指向 prototype 所在的函数对象。 拿前面的一个例子来说 Person.prototype.constructor 就指向 Person 函数对象。 console.log(Person.prototype.constructor == Person) 下面我们来更新一下它们之间的关系图。 **简易图** 对象的 __proto__ 属性当我们调用构造函数创建一个新实例后，在这个实例的内部将包含一个指针，指向构造函数的原型对象. 根据前面的 Person 构造函数我们新建一个实例 var student = new Person(); console.log(student.__proto__ === Person.prototype); // true 从上面我们可以看出，这个连接是存在与实例与构造函数的原型对象之间的，而不是存在于实例和构造函数之间的。 下面我们来看一下现在这几个对象之间的关系 isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。 console.log(Person.prototype.isPrototypeOf(student)); // true 简易图 1.3 原型属性属性访问每当代码读取对象的某个属性时，首先会在对象本身搜索这个属性，如果找到该属性就返回该属性的值，如果没有找到，则继续搜索该对象对应的原型对象，以此类推下去。 因为这样的搜索过程，因此我们如果在实例中添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，因为在实例中搜索到该属性后就不会再向后搜索了。 属性判断既然一个属性既可能是实例本身的，也有可能是其原型对象的，那么我们该如何来判断呢？ 在属性确认存在的情况下，我们可以使用 hasOwnProperty() 方法来判断一个属性是存在与实例中，还是存在于原型中 function Person() {}; Person.prototype.name = &quot;laker&quot; ; var student = new Person(); console.log(student.name); // laker console.log(student.hasOwnProperty(&quot;name&quot;)); // false student.name = &quot;xiaoming&quot;; console.log(student.name); //xiaoming 屏蔽了原型对象中的 name 属性 console.log(student.hasOwnProperty(&quot;name&quot;)); // true function hasPrototypeProperty(object, name){ return !object.hasOwnProperty(name) &amp;&amp; (name in object); } 所有属性获取 function Person() { this.name = &quot;KXY&quot;; } Person.prototype = { job: &quot;student&quot;, }; var kxy = new Person(); Object.defineProperty(kxy, &quot;sex&quot;, { value: &quot;female&quot;, enumerable: false, }); console.log(Object.keys(kxy)); //[&quot;name&quot;] //无法获取不可枚举的属性与原型链上继承的属性 console.log(Object.getOwnPropertyNames(kxy));//[&quot;name&quot;, &quot;sex&quot;] //for...in能获取原型链上继承的属性，无法获取不可枚举的属性 for (var pro in kxy) { console.log(&quot;kxy.&quot; + pro + &quot; = &quot; + kxy[pro]);// kxy.name = KXY //kxy.job = student } 怎样判断属性是否为实例属性并且是否可枚举 如果想判断指定名称的属性是否为实例属性并且是否可枚举的，可以使用propertyIsEnumerable function Student(userName) { this.userName = userName; } Student.prototype.sayHello = function () { console.log(&quot;hello&quot; + this.userName); }; var stu = new Student(); console.log(stu.propertyIsEnumerable(&quot;userName&quot;)); //true:userName为自身定义的实例属性 console.log(stu.propertyIsEnumerable(&quot;age&quot;)); // false:age属性不存在，返回false console.log(stu.propertyIsEnumerable(&quot;sayHello&quot;)); // false :sayHello属于原型上的函数 //将userName属性设置为不可枚举 Object.defineProperty(stu, &quot;userName&quot;, { enumerable: false, }); console.log(stu.propertyIsEnumerable(&quot;userName&quot;)); // false: userName设置了不可枚举 1.4 Object.create( )方法基本使用该函数的主要作用是创建并返回一个指定原型和指定属性的新对象，语法格式如下： Object.create(prototype,propertyDescriptor) prototype属性为对象的原型（必须），可以为null,如果为null，则对象的原型为undefined. propertyDescriptor表示的是属性描述符（可选），具体的格式如下： propertyName:{ value:'', writable:true, enumerable:true, configurable:true } 基本实现： &lt;script type=&quot;text/javascript&quot;&gt; const person = { userName: &quot;zhangsan&quot;, sayHello: function () { console.log(&quot;hello &quot; + this.userName); }, }; const stu = Object.create(person); stu.userName = &quot;lisi&quot;; stu.sayHello(); //hello lisi 覆盖了person中的userName属性原有的值 &lt;/script&gt; 通过以上的代码，可以看到stu对象的原型是person.也就是stu.__proto__===person 下面再来看一个案例： var obj = Object.create(null, { userName: { value: &quot;wangwu&quot;, writable: true, enumerable: true, configurable: true, }, age: { value: 23, }, }); console.log(obj.userName); console.log(obj.age); obj.age = 26; console.log(obj.age); for (var o in obj) { console.log(o); } delete obj.userName; console.log(obj.userName); delete obj.age; console.log(obj.age); 实现原理通过如下的伪代码来查看对应的实现原理 Object.create=function(proto,propertiesObject){ //省略了其它判断操作 function F(){} F.prototype=proto; if(propertiesObject){ Object.defineProperties(F, propertiesObject)} return new F() } 通过以上的代码，我们可以得出如下的结论： var f=new F() f.__proto__===F.prototype 下面我们可以通过一个例子来验证一下： var obj = { x: 12, y: 13 }; var test = Object.create(obj); console.log(test); console.log(test.x); console.log(test.__proto__.x); 最后，这里演示一下Object.defineProperties方法的基本使用 该方法的主要作用就是添加或修改对象的属性。 如下代码所示： var person = {}; Object.defineProperties(person, { userName: { value: &quot;张三&quot;, enumerable: true, }, age: { value: 12, enumerable: true, }, }); for (var p in person) { console.log(p); } person.age = 20; console.log(person.age); 应用场景对于Object.create方法很重要的一个应用场景是用来实现继承 function Person(name, sex) { this.name = name; this.sex = sex; } Person.prototype.getInfo = function () { console.log(&quot;getInfo: [name:&quot; + this.name + &quot;, sex:&quot; + this.sex + &quot;]&quot;); }; var a = new Person(&quot;jojo&quot;, &quot;femal&quot;); var b = Object.create(Person.prototype); console.log(a.name); console.log(b.name); console.log(b.getInfo); 下面看一下怎样实现完整的继承操作。 function Person(name, sex) { this.name = name; this.sex = sex; } Person.prototype.getInfo = function () { console.log(&quot;getInfo: [name:&quot; + this.name + &quot;, sex:&quot; + this.sex + &quot;]&quot;); }; function Student(name, sex, age) { Person.call(this, name, sex); this.age = age; } Student.prototype = Object.create(Person.prototype); var s = new Student(&quot;coco&quot;, &quot;femal&quot;, 25); s.getInfo(); 下面，我们简单的分析一下，上面的代码。 对象s的__proto__指向的是s的构造函数Student的prototype s.__proto__===Student.prototype 那么Student.prototype的__proto__指向什么呢？ Student.prototype.__proto__===Person.prototype s.__proto__.__proto__===Person.prototype 而我们知道对象s是有Student 创建的，所以其构造函数为Student,所以我们在修改了原型以后，这里应该重新修正构造函数。 function Person(name, sex) { this.name = name; this.sex = sex; } Person.prototype.getInfo = function () { console.log(&quot;getInfo: [name:&quot; + this.name + &quot;, sex:&quot; + this.sex + &quot;]&quot;); }; function Student(name, sex, age) { Person.call(this, name, sex); this.age = age; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; var s = new Student(&quot;coco&quot;, &quot;femal&quot;, 25); s.getInfo(); 1.5 Object.create( )与new Object()的区别1.6 模拟new操作符的实现在前面我们介绍了new操作符所做的三件事情，下面我们来模拟实现一下。 function Person(name, age) { this.name = name; this.age = age; } function New() { var obj = {}; var res = Person.apply(obj, arguments); return typeof res === &quot;object&quot; ? res : obj; } console.log(New(&quot;zhangsan&quot;, 19)); 1.7 原型链理解下面我们通过一个案例来看一个简单的原型链过程。初步代码如下 var A=function(){ } var a=new A( ); 通过a 实例沿着原型链第一次的追溯，__proto__属性指向A()构造函数的原型对象。 a.__proto__===A.prototype a实例沿着原型链第二次的追溯，A原型对象的__proto__属性指向Object类型的原型对象. a.__proto__.__proto__===A.prototype.__proto__ A.prototype.__proto__===Object.prototype a 实例沿着原型链第三次追溯，Object类型的原型对象的__proto__属性为null a.__proto__.__proto__.__proto__===Object.prototype.__proto__ Object.prototype.__proto__===null 具体的图如下所示： 下面，我们再来看一个案例： function Super(){ }; function Middle(){ }; function Sub(){ }; Middle.prototype = new Super(); Sub.prototype = new Middle(); var suber = new Sub(); 对应的原型链如下图所示： 上面的图其实并不完整，因为漏掉了Object.所以完整的图如下 通过以上内容的讲解，我们对原型链有了更加深入的理解。 1.8 原型链特点关于原型链的特点，主要有两个 第一个特点：由于原型链的存在，属性查找的过程不再只是查找自身的原型对象，而是会沿着整个原型链一直向上，直到追溯到Object.prototype.也就是说，当js引擎在查找对象的属性时，先查找对象本身是否存在该属性，如果不存在，会在原型链上查找，直到Object.prototype.如果Object.prototype上也找不到该属性，则返回undefined,如果期间在对象本身找到了或者是某个原型对象上找到了该属性，则会返回对应的结果。 由于这个特点，我们在自定义的对象中，可以调用某些未在自定义构造函数中定义的函数，例如toString( )函数。 function Person(){ } var p = new Person(); p.toString(); // 实际上调用的是Object.prototype.toString( ) 第二个特点：由于属性查找会经历整个原型链，因此查找的链路越长，对性能的影响越大。 1.9 属性的区分对象属性的查找往往会涉及到整个原型链，那么应该怎样区分属性是实例自身的还是从原型链中继承的呢？ 关于这个问题，前面我们也已经讲解过，是通过hasOwnProperty( )函数来完成的，这里我们在简单的复习强调一下。 function Person(name, age) { this.name = name; } //在对象的原型上添加age属性 Person.prototype.age = 21; var p = new Person(&quot;zhangsan&quot;); console.log(p.hasOwnProperty(&quot;name&quot;)); //true console.log(p.hasOwnProperty(&quot;age&quot;)); //false name属性为实例属性，在调用hasOwnProperty方法时，会返回true。age属性为原型对象上的属性，在调用hasOwnProperty函数时，会返回false. 在使用for...in运算符，遍历对象的属性时，一般可以配合hasOwnProperty方法一起使用，检测某个属性是否为对象自身的属性，如果是，可以做相应的处理。 for(var p in person){ if(person.hasOwnProperty(p)){ } } 2、Array类型Array类型中提供了丰富的函数用于对数组进行处理，例如，过滤，去重，遍历等等操作。 2.1 怎样 判断一个变量是数组还是对象这里，我们可能会想到使用typeof运算符，因为typeof运算符是专门用于检测数据类型的，但是typeof运算符能够满足我们的需求吗？ var a = [1, 2, 3]; console.log(typeof a); 2.1.1 instanceof运算符instanceof运算符用于通过查找原型链来检查某个变量是否为某个类型数据的实例，使用instanceof运算符可以判断一个变量是数组还是对象。 var a = [1, 2, 3]; console.log(a instanceof Array); // true console.log(a instanceof Object); // true var userInfo = { userName: &quot;zhangsan&quot; }; console.log(userInfo instanceof Array); // false console.log(userInfo instanceof Object); // true 这里我们可以封装一个函数，用于判断变量是数组类型还是对象类型。 var a = [1, 2, 3]; function getType(o) { if (o instanceof Array) { return &quot;Array&quot;; } else if (o instanceof Object) { return &quot;Object&quot;; } else { return &quot;参数类型不是Array也不是Object&quot;; } } console.log(getType(a)); 2.1.2 通过构造函数来判断判断一个变量是否是数组还是对象，其实就是判断变量的构造函数是Array类型还是Object类型。 因为一个对象的实例都是通过构造函数创建的。 var a = [1, 2, 3]; console.log(a.__proto__.constructor === Array); console.log(a.__proto__.constructor === Object); // false 同样这里，这里我们也可以封装一个函数，来判断变量是数组类型还是对象类型。 function getType(o) { //获取构造函数 var constructor = o.__proto__.constructor; if (constructor === Array) { return &quot;Array&quot;; } else if (constructor === Object) { return &quot;Object&quot;; } else { return &quot;参数类型不是Array也不是Object&quot;; } } var a = [1, 2, 3]; console.log(getType(a)); 2.1.3 通过toString( )函数来判断我们知道，每种引用类型都会直接或间接继承Object类型，因此它们都包含toString( )函数。 不同数据类型的toString( )函数返回值也不一样，所以通过toString( )函数就可以判断一个变量是数组还是对象，当然，这里我们需要用到call方法来调用Object原型上的toString( )函数来完成类型的判断。 如下所示： var arr = [1, 2, 3]; var obj = { userName: &quot;zhangsan&quot; }; console.log(Object.prototype.toString.call(arr)); //[object Array] console.log(Object.prototype.toString.call(obj)); // [object Object] console.log(arr.toString()); // 1,2,3 2.1.4 通过Array.isArray( )函数来判断Array.isArray 方法用来判断变量是否为数组。 var arr = [1, 2, 3]; var obj = { name: &quot;zhangsan&quot; }; console.log(Array.isArray(1)); //false console.log(Array.isArray(arr)); //true console.log(Array.isArray(obj)); //false 2.2 怎样过滤数组中满足条件的数据对数组中的数据进行过滤，我们使用比较多的是filter方法。 &lt;script&gt; var fn = function (x) { return x % 2 !== 0; }; var arr = [1, 2, 5, 6, 78, 9, 10]; var result = arr.filter(fn); console.log(result); &lt;/script&gt; 下面，我们再来看一下针对复杂类型数组的过滤。 下面案例是查找出年龄大于16的男生的信息。 var arr = [ { gender: &quot;男&quot;, age: 15 }, { gender: &quot;男&quot;, age: 17 }, { gender: &quot;女&quot;, age: 15 }, ]; var fn = function (obj) { return obj.gender === &quot;男&quot; &amp;&amp; obj.age &gt; 16; }; const result = arr.filter(fn); console.log(result); 2.3 怎样对数组元素做累加处理对数组中的元素做累加的处理，可以通过reduce函数来完成。 reduce函数最主要的作用就是做累加的操作，该函数接收一个函数作为累加器，将数组中的每个元素从左到右依次执行累加器，返回最终的处理结果。 reduce函数的语法如下： arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 求出数组中所有元素累加的和 var arr = [1, 2, 3, 4, 5, 6]; var sum = arr.reduce(function (accumulator, currentValue) { return accumulator + currentValue; }, 0); console.log(sum); 2.4 怎样求数组中的最大值与最小值关于查询出数组中的最大值与最小值的实现方式有很多种，下面我们来看一下具体的实现。 第一：通过prototype属性扩展min函数和max函数来实现求最小值与最大值 //最小值 Array.prototype.min = function () { var min = this[0]; var len = this.length; for (var i = 1; i &lt; len; i++) { if (this[i] &lt; min) { min = this[i]; } } return min; }; //最大值 Array.prototype.max = function () { var max = this[0]; var len = this.length; for (var i = 1; i &lt; len; i++) { if (this[i] &gt; max) { max = this[i]; } } return max; }; var arr = [1, 3, 6, 90, 23]; console.log(arr.min()); // 1 console.log(arr.max()); // 90 第二：通过数组的reduce函数来完成。 Array.prototype.max = function () { return this.reduce(function (preValue, currentValue) { return preValue &gt; currentValue ? preValue : currentValue; //返回最大的值 }); }; Array.prototype.min = function () { return this.reduce(function (preValue, currentValue) { return preValue &lt; currentValue ? preValue : currentValue; // 返回最小的值 }); }; var arr = [1, 3, 6, 90, 23]; console.log(arr.min()); // console.log(arr.max()); // 第三：通过ES6中的扩展运算符来实现 这里我们可以通过ES6中的扩展运算符(…)来实现。 var arr = [1, 3, 6, 90, 23]; console.log(Math.min(...arr)); // console.log(Math.max(...arr)); 2.5 数组遍历的方式有哪些数组遍历是我们针对数组最频繁的操作。下面我们看一下常见的数组的遍历方式。 通过for循环这时最基本的实现方式 var arr=[1,2,3] for(var i=0;i&lt;arr.length;i++){ console.log(arr[i]) } 使用forEach( )函数forEach函数也是我们遍历数组用的比较多的方法，forEach( )函数接收一个回调函数，参数分别表示当前执行的元素的值，当前值的索引和数组本身。 var arr = [1, 3, 6, 90, 23]; arr.forEach(function (element, index, array) { console.log(index + &quot;:&quot; + element); }); 使用map( )函数`m var arr = [1, 3, 6, 90, 23]; var result = arr.map(function (element, index, array) { console.log(index); return element * element; }); console.log(&quot;result: ===&quot;, result); 在使用map函数的时候一定要注意：在map( )函数的回调函数中需要通过return将处理后的值进行返回，否则会返回undefined. 如下所示： var arr = [1, 3, 6, 90, 23]; var result = arr.map(function (element, index, array) { // console.log(index); element * element; }); console.log(&quot;result: ===&quot;, result); 在上面的计算中，将return关键字省略了，最终返回的结果是： [undefined, undefined, undefined, undefined, undefined] 使用some( )函数与every( )函数some( )函数与every( )函数的相似之处都是在对数组进行遍历的过程中，判断数组中是否有满足条件的元素，如果有满足条件的就返回true,否则返回false. some()与every()的区别在于:some( )函数只要数组中某个元素满足条件就返回true,不会在对后面的元素进行判断。而every( )函数是数组中每个元素都要满足条件时才会返回true. 例如：要判断数组中是否有大于6的元素的时候，可以通过some( )函数来处理。 而要判断数组中是否所有的元素都大于6，则需要通过every( )函数来处理。 function fn(element, index, array) { return element &gt; 6; } var result = [1, 2, 3, 4, 5].some(fn); //false console.log(result); var result = [1, 2, 3, 4, 5, 7].some(fn); console.log(result); 下面测试一下every( )函数 function fn(element, index, array) { return element &gt; 6; } var result = [1, 2, 3, 4, 5, 7].every(fn); //false console.log(result); 下面修改一下数组中的元素。 function fn(element, index, array) { return element &gt; 6; } var result = [7, 8].every(fn); //true console.log(result); 现在数组中的元素的值都是大于6，所以返回的结果为true. 使用find( )函数find( ) 函数用于数组的遍历，当找到第一个满足条件的元素值时，则直接返回该元素值，如果都找不到满足条件的，则返回undefined. find( )方法的参数与forEach是一样的。 var arr = [1, 3, 6, 90, 23]; const result = arr.find(function (element, index, array) { return element &gt; 6; }); console.log(result); // 90 var arr = [1, 3, 6, 90, 23]; const result = arr.find(function (element, index, array) { return element &gt; 100; //undefined }); console.log(result); 以上就是我们比较常用的数组遍历的方式。当然还有我们前面讲解过的filter，reduce函数。 2.6 手动实现find方法 &lt;script&gt; Array.prototype.findTest = function (fn) { for (var i = 0; i &lt; this.length; i++) { var f = fn(this[i]);//把数组元素传递到函数中 if (f) { //如果函数的返回值为true return this[i]; //则返回对应的数组元素 } } }; var arr = [1, 3, 6, 90, 23]; var result = arr.findTest(function (item) { return item &gt; 6; }); console.log(result); &lt;/script&gt; 2.7 手动实现filter方法filter函数内部需要一个回调函数，数组中的每个元素都会执行该回调函数，在执行回调函数时会将数组中的每个元素传递给回调函数的参数，在回调函数的函数体内进行判断，如果返回的是true,那么将该元素放到新数组arr中，如果判断的结果为false，则数据不会放到新数组arr中。 //模拟实现filter函数 Array.prototype.filterOne = function (fn) { var newArray = []; for (var i = 0; i &lt; this.length; i++) { var f = fn(this[i]); if (f) { newArray.push(this[i]); } } return newArray; }; var array = [65, 56, 89, 53]; var arr = array.filterOne(function (item) { return item &gt;= 60; }); console.log(&quot;arr=&quot;, arr); 2.8 手动实现some函数some() 方法让数组中的每一个元素执行一次回调函数，在该回调函数中执行一些操作，只要有一个操作结果为真，就会返回true。不会在对后面的元素进行判断,否则返回false。 //手动模式some方法 Array.prototype.someTest = function (fn) { for (let i = 0; i &lt; this.length; i++) { let f = fn(this[i]); if (f) { return f; } } return false; }; let array = [1, 3, 5, 7, 90]; let result = array.someTest(function (item) { return item &gt; 10; }); console.log(&quot;result=&quot;, result); 2.9 手动实现every函数该方法与some()方法不同，some()方法只要有一个符合条件就返回true,而 every() 方法是数组中所有元素都要符合指定的条件，才会返回true. //手动模拟实现`every`方法 Array.prototype.everyTest = function (fn) { let f = true; for (let i = 0; i &lt; this.length; i++) { let f = fn(this[i]); if (!f) { //只要有一个不符合，就立即返回false. return false; } } return f; }; let array = [11, 31, 5, 71, 90]; let result = array.everyTest(function (item) { return item &gt; 10; }); console.log(&quot;result=&quot;, result); //false 2.10 手动实现map方法map( )函数在对数据进行遍历的时候，会将数组中的每个元素做相应的处理，然后得到新的元素，并返回一个新的数组。 //手动实现map方法 Array.prototype.mapTest = function (fn) { let newArray = []; for (let i = 0; i &lt; this.length; i++) { let f = fn(this[i], i, this); newArray.push(f); } return newArray; }; var arr = [1, 3, 6, 90, 23]; var result = arr.mapTest(function (element, index, array) { console.log(index); return element * element; }); console.log(&quot;result: ===&quot;, result); 2.11 手动实现reduce方法 Array.prototype.reduceTest = function (fn, initialValue) { //如果没有传递initialValue,我们将使用数组的第一项作为initialValue的值 let hasInitialValue = initialValue !== undefined; let value = hasInitialValue ? initialValue : this[0]; //如果没有传递initialValue,则索引从1开始，否则从0开始 for (let i = hasInitialValue ? 0 : 1, len = this.length; i &lt; len; i++) { value = fn(value, this[i], i, this); } return value; }; var arr = [1, 2, 3, 4, 5, 6]; var sum = arr.reduceTest(function (accumulator, currentValue) { return accumulator + currentValue; }, 0); console.log(sum); 2.12 怎样实现数组的去重数组去重是指当数组中出现重复的元素的时候，通过一定的方式，将重复的元素去掉。 利用数组遍历去重 // 数组去重 function fn(array) { var newArray = []; for (var i = 0; i &lt; array.length; i++) { if (newArray.indexOf(array[i]) === -1) { newArray.push(array[i]); } } return newArray; } var arr = [1, 2, 3, 4, 5, 5, 6]; console.log(fn(arr)); 利用键值对去重 function fn(array) { var obj = {}, result = [], val; for (var i = 0; i &lt; array.length; i++) { val = array[i]; if (!obj[val]) {//根据key获取obj对象中的值 obj[val] = &quot;ok&quot;; //表示该元素已经出现了 result.push(val); } } return result; } var arr = [1, 2, 3, 4, 5, 5, 6]; console.log(fn(arr)); function fn(array) { var obj = {}, result = [], val, type; for (var i = 0; i &lt; array.length; i++) { val = array[i]; type = typeof val; if (!obj[val]) { obj[val] = [type]; result.push(val); } else if (obj[val].indexOf(type) &lt; 0) { obj[val].push(type); result.push(val); } } return result; } var arr = [1, 2, 3, 4, 5, 5, 6, &quot;6&quot;]; console.log(fn(arr)); 使用Set数据结构去重具体的代码如下所示： function fn(arr) { return Array.from(new Set(arr)); } console.log(fn([1, 2, 3, 4, 5, 5, 6, &quot;6&quot;])); 2.13 怎样获取数组中最多的元素利用键值对实现&lt;script&gt; function fn(arr) { //如果数组中没有值，直接返回 if (!arr.length) return; //如果只有一个值，返回1，表示出现了1次 if (arr.length === 1) return 1; var result = {}; //对数组进行遍历 for (var i = 0; i &lt; arr.length; i++) { if (!result[arr[i]]) { result[arr[i]] = 1; } else { result[arr[i]]++; } } //遍历result对象 var keys = Object.keys(result); var maxNum = 0, maxElement; for (var i = 0; i &lt; keys.length; i++) { if (result[keys[i]] &gt; maxNum) { maxNum = result[keys[i]]; maxElement = keys[i]; } } return ( &quot;在数组中出现最多的元素是&quot; + maxElement + &quot;,共出现了&quot; + maxNum + &quot;次&quot; ); } var array = [1, 2, 3, 3, 3, 6, 6, 6, 6, 6, 7, 8, 9]; console.log(fn(array)); &lt;/script&gt; 算法优化 function fn(array) { var result = {}; var maxNum = 0; var maxElement = null; for (var i = 0; i &lt; array.length; i++) { var val = array[i]; result[val] === undefined ? (result[val] = 1) : result[val]++; if (result[val] &gt; maxNum) { maxNum = result[val]; maxElement = val; } } return ( &quot;在数组中出现最多的元素是&quot; + maxElement + &quot;,共出现了&quot; + maxNum + &quot;次&quot; ); } var array = [1, 2, 3, 3, 3, 6, 6, 6, 6, 6, 7, 8, 9]; console.log(fn(array)); 三、函数1、函数定义有哪几种实现方式在使用函数前，先需要对函数进行定义。关于函数的定义总体上可以分为三类。 第一类是函数声明。 第二类是函数表达式 第三类是通过Function构造函数来完成函数的定义。 首先来看一下函数的声明。 函数声明是直接通过function关键字接一个函数名，同时可以接收参数。 function sum(num1, num2){ return num1 + num2 } 函数表达式 函数表达式的形式类似于普通变量的初始化，只不过这个变量初始化的值是一个函数。如下代码所示： var sum = function (num1,num2){ return num1 + num2 } 这个函数表达式没有名称，属于匿名函数表达式。 Function( )构造函数 使用new操作符，调用Function( )构造函数，传入参数，也可以定义一个函数。 var sum = new Function('num1','num2', 'return a+b ') 其中的参数，除了最后一个参数是要执行的函数体，其它的参数都是函数的形参。 2、Function( )构造函数定义函数的问题但是，我们在实际的应用中很少使用Function( )构造函数来实现对函数的定义。 原因是： 第一：Function( ) 构造函数每次执行时，都会解析函数体，并创建一个新的函数对象，所以当在一个循环或者是一个频繁执行的函数中去使用Function( )构造函数的时候，相对来说性能是比较低的。 第二：通过Function( ) 构造函数创建的函数，并不遵循典型的作用域。 如下代码所示： var a = &quot;12&quot;; function fun() { var a = &quot;11&quot;; return new Function(&quot;return a&quot;); } console.log(fun()()); 3、函数表达式的应用场景关于函数表达式非常典型的应用就是实现了块级作用域 var person = (function () { var _name = &quot;&quot;; return { getName: function () { return _name; }, setName: function (userName) { _name = userName; }, }; })(); person.setName(&quot;zhangsan&quot;); console.log(person.getName()); 4、函数声明与函数表达式有什么区别函数声明与函数表达式虽然是两种定义函数的方式，但是两者之间还是有区别的。 第一点就是：函数名称 // 函数声明，函数名称sum是必须的 function sum (num1,num2){ return num1 + num2 } // 没有函数名称的匿名函数表达式 var sum = function (num1,num2){ return num1 + num2 } 第二点就是关于：函数提升 console.log(add(1, 2)); // 3 console.log(sum(3, 6)); // Uncaught TypeError: sum is not a function // 函数声明 function add(num1, num2) { return num1 + num2; } // 函数表达式 var sum = function (num1, num2) { return num1 + num2; }; 5、函数常见的调用模式有哪些函数调用模式 function add(num1, num2) { return num1 + num2; } // 函数表达式 var sum = function (num1, num2) { return num1 + num2; }; console.log(add(1, 2)); console.log(sum(3, 6)); 方法调用模式 var obj = { userName: &quot;zhangsan&quot;, getUserName: function () { return this.userName; }, }; console.log(obj.getUserName()); var obj = { userName: &quot;zhangsan&quot;, getUserName: function () { return this.userName; }, }; // console.log(obj.getUserName()); console.log(obj[&quot;getUserName&quot;]()); var obj = { userName: &quot;zhangsan&quot;, getUserName: function () { return this.userName; }, setUserName: function (name) { this.userName = name; return this; }, }; console.log(obj.setUserName(&quot;lisi&quot;).getUserName());// lisi 构造器(构造函数)调用模式 //定义构造函数 function Person(name) { this.userName = name; //定义属性 } // 在原型上定义函数 Person.prototype.getUserName = function () { return this.userName; }; // 通过new来创建实例 var p = new Person(&quot;zhangsan&quot;); // 调用原型上的方法 console.log(p.getUserName()); function sum(num1, num2) { return num1 + num2; } //定义一个对象 var obj = {}; //通过call()和apply( )函数调用sum( )函数 console.log(sum.call(obj, 2, 6)); console.log(sum.apply(obj, [3, 6])); 匿名函数调用模式 所谓的匿名函数，就是没有函数名称的函数。匿名函数的调用有两种方式，一种是通过函数表达式定义函数，并赋值给变量，通过变量进行调用。如下所示： //通过函数表达式定义匿名函数，并赋值给变量sum var sum =funciton (num1,num2){ return num1 + num2 } // 通过sum来进行调用 sum(2,6) 另外一种是使用小括号()将匿名函数括起来，然后在后面使用小括号( ),传递对应的参数从而完成对应的调用。 (function (num1, num2) { console.log(num1 + num2); })(2, 6); 6、实参与形参有哪些区别第一：在函数的调用过程中，数据传递是单向的，也就是只能把实参的值传递给形参，而不能把形参的值反向传递给实参 第二：当实参是基本数据类型的值的时候，在向形参传递的时候，实际上是将实参的值复制一份传递给形参，在函数运行结束以后 形参释放，而实参中的值不会发生变化。当实参是引用类型的值的时候，实际是将实参的内存地址传递给形参，即实参与形参都指向了 相同的内存地址，此时形参可以修改实参的值。 var person = { age: 21 }; function fn(obj) { obj.age = 22; } fn(person); console.log(person.age); 第三：函数可以不用定义形参，在函数体中可以通过arguments对象获取传递过来的实参的值，并进行处理。 第四：在函数定义形参时，形参的个数并一定要和实参的个数相同，实参与形参会按照从前向后的顺序进行匹配，没有匹配到的形参被当作undefined来处理。 第五：实参并不需要与形参的数据类型一致，因为形参的数据类型只能在执行的时候才能够被确定，因为会通过隐式数据类型的转换。 7、介绍一下arguments对象arguments对象是所有函数都具有的一个内置的局部变量，表示的是函数实际接收到的参数，是一个类似数组的结构。 下面我们说一下arguments对象都具有哪些性质。 第一：arguments对象只能在函数内部使用，无法在函数的外部访问到arguments对象。同时arguments对象存在于函数级的作用域中。 console.log(arguments); //Uncaught ReferenceError: arguments is not defined function fn() { console.log(arguments.length); } fn(1, 2, 3); 第二：可以通过索引来访问arguments对象中的内容，因为arguments对象类似数组结构。 function fn() { console.log(arguments[0]); // 1 console.log(arguments[1]); // 2 console.log(arguments[2]); // undefined } fn(1, 2); 第三：arguments 对象的值由实参决定，不是有形参决定。 function fn(num1, num2, num3) { console.log(arguments.length); // 2 } fn(1, 2); 因为arguments对象的length属性是由实际传递的实参的个数决定的，所以这里输出的是2. function fn(num1, num2, num3) { arguments[0] = 23; console.log(&quot;num1=&quot;, num1); //23 num2 = 33; console.log(arguments[1]); // 33 } fn(1, 2); function fn(num1, num2, num3) { // arguments[0] = 23; // console.log(&quot;num1=&quot;, num1); //23 // num2 = 33; // console.log(arguments[1]); // 33 arguments[2] = 19; console.log(num3); //undefined num3 = 10; console.log(arguments[2]); // 19 } fn(1, 2); function fn(num1, num2, num3) { // arguments[0] = 23; // console.log(&quot;num1=&quot;, num1); //23 // num2 = 33; // console.log(arguments[1]); // 33 arguments[2] = 19; console.log(num3); //undefined num3 = 10; console.log(arguments[2]); // 19 console.log(arguments.length); // 2 长度还是2 } fn(1, 2); 8、arguments对象有哪些应用场景第一：进行参数个数的判断。 function fn(num1, num2, num3) { // 判断传递的参数个数是否正确 if (arguments.length !== 3) { throw new Error( &quot;希望传递3个参数，实际传递的参数个数为:&quot; + arguments.length ); } } fn(1, 3); 第二：对任意个数参数的处理，也就是说只会对函数中前几个参数做特定处理，后面的参数不论传递多少个都会统一进行处理，这种情况我们可以使用arguments对象来完成。 function fn(sep) { var arr = Array.prototype.slice.call(arguments, 1); // console.log(arr); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] return arr.join(sep); } console.log(fn(&quot;-&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)); 第三：模拟函数的重载 什么是函数的重载呢？ 函数的重载指的是在函数名称相同的情况下，函数的形参的类型不同或者是个数不同。 但是在JavaScript中没有函数的重载。 function fn(num1, num2) { return num1 + num2; } function fn(num1, num2, num3) { return num1 + num2 + num3; } console.log(fn(1, 2)); // NaN console.log(fn(1, 2, 3)); // 6 function fn() { //将arguments对象转换成数组 var arr = Array.prototype.slice.call(arguments); // console.log(arr); // [1,2] //调用数组中的reduce方法完成数据的计算 return arr.reduce(function (pre, currentValue) { return pre + currentValue; }); } console.log(fn(1, 2)); console.log(fn(1, 2, 3)); console.log(fn(1, 2, 3, 4, 5)); 9、说一下普通函数与构造函数的区别在JavaScript的函数中，有一类比较特殊的函数：’构造函数’。当我们创建对象的时候，经常会使用构造函数。 构造函数与普通函数的区别： 第一：构造函数的函数名的第一字母通常会大写。 第二：在构造函数的函数体内可以使用this关键字，表示创生成的对象实例。 function Person(userName) { this.userName = userName; } var person = new Person(&quot;zhangsan&quot;); console.log(person); 第三：在使用构造函数的时候，必须与new操作符配合使用。 第四：构造函数的执行过程与普通函数也是不一样的。 代码如下： function Person(userName) { this.userName = userName; this.sayHi = function () { console.log(this.username); }; } var p1 = new Person(&quot;zhangsan&quot;); var p2 = new Person(&quot;lisi&quot;); console.log(p1.sayHi === p2.sayHi); // false function Person(userName) { this.userName = userName; // this.sayHi = function () { // console.log(this.username); // }; } Person.prototype.sayHi = function () { console.log(this.username); }; var p1 = new Person(&quot;zhangsan&quot;); var p2 = new Person(&quot;lisi&quot;); console.log(p1.sayHi === p2.sayHi); // true 10、什么是变量提升，什么是函数提升在javascript中存在一些比较奇怪的现象。在一个函数体内，变量在定义之前就可以被访问到，而不会抛出异常。 如下所示： function fn() { console.log(num); // undefined var num = 2; } fn(); 同样函数在定义之前也可以被调用，而不会抛出异常。 如下代码所示： fn(); function fn() { console.log(&quot;hello&quot;); } 导致出现以上情况的原因是，在javascript中存在变量提升与函数提升的机制。 在讲解变量提升之前，先来说以作用域的问题。 作用域在JavaScript中，一个变量的定义与调用都是在一个固定的范围内的，这个范围我们称之为作用域。 作用域可以分为全局的作用域，局部作用域(函数作用域)和块级作用域。 如下程序： function fn() { var userName = &quot;zhangsan&quot;; console.log(userName); } fn(); //zhangsan 下面，再看如下代码： var userName = &quot;zhangsan&quot;; function fn() { console.log(userName); } fn(); //zhangsan 综上两个案例，我们可以总结出，作用域本质就是一套规则，用于确定在何处以及如何查找变量的规则。 下面，我们再来看一个比较复杂的结构图，来体验一下作用域 作用域链 下面，我们再来看一下前面的代码： var userName = &quot;zhangsan&quot;; function fn() { console.log(userName); } fn(); //zhangsan 我们在查找userName这个变量的时候，现在函数的作用域中进行查找，没有找到，再去全局作用域中查找。你会注意到，这是一个往外层查找的过程，即顺着一条链条从下往上查找变量。这个链条，我们就称之为作用域链。 如下图所示： 对应的代码如下： 面试中关于作用域与作用域链的问题 第一题：以下代码的执行结果是： var a = 1; function fn1() { function fn2() { console.log(a); } function fn3() { var a = 4; fn2(); } var a = 2; return fn3; } var fn = fn1(); fn(); // 2 第二题：以下代码的执行结果是： var a = 1; function fn1() { function fn3() { var a = 4; fn2(); } var a = 2; return fn3; } function fn2() { console.log(a); } var fn = fn1(); fn(); // 1 第三题：以下代码的输出结果为 var a = 1; function fn1() { function fn3() { function fn2() { console.log(a); } var a; fn2(); a = 4; } var a = 2; return fn3; } var fn = fn1(); fn(); //undefined 第四题：以下代码的输出结果为： var x = 10; bar(); //10 function foo() { console.log(x); } function bar() { var x = 30; foo(); } 第五题： 以下代码的输出结果为： var x = 10; bar(); //30 function bar() { var x = 30; function foo() { console.log(x); } foo(); } 第六题：以下代码的输出结果为: var x = 10; bar(); //30 function bar() { var x = 30; (function () { console.log(x); })(); } 变量提升所谓变量提升，是将变量的声明提升到函数顶部的位置，也就是将变量声明提升到变量所在的作用域的顶端，而变量的赋值并不会被提升。 var str = &quot;hello world&quot;; (function () { console.log(str); var str = &quot;hello vue&quot;; })(); // undefined var str = &quot;hello world&quot;; (function () { var str; //变量的声明得到提升 console.log(str); str = &quot;hello vue&quot;; // 变量的赋值没有得到提升 })(); 如下代码所示： (function () { console.log(str); str = &quot;hello vue&quot;; })(); // str is not defined 以下代码的执行结果是： function foo() { var a = 1; console.log(a); //1 console.log(b); //undefined var b = 2; } foo(); 上面的代码等价于 function foo() { var a; var b; a = 1; console.log(a); // 1 console.log(b); // undefined b = 2; } foo(); 函数提升不仅通过var定义的变量会出现提升的情况，使用函数声明方式定义的函数也会出现提升。 如下代码： foo(); // 函数提升 function foo() { console.log(&quot;hello&quot;); } function foo(){ console.log(&quot;hello&quot;); } foo() //'hello' foo(); // foo is not a function var foo = function () { console.log(&quot;hello&quot;); }; 看一下如下程序的执行结果： function foo() { function bar() { return 3; } return bar(); function bar() { return 9; } } console.log(foo()); // 9 如下程序的执行结果： var a = true; foo(); function foo() { if (a) { var a = 20; } console.log(a); // undefined } 以上的代码的执行过程如下： var a; a = true; function foo(){ var a; if(a){ a=20 } console.log(a) } foo() 如下程序的执行结果： function v() { var a = 1; function a() {} console.log(a); } v(); // 1 下面我们再来看一段代码： function fn() { console.log(typeof foo); // function var foo = &quot;hello&quot;; function foo() { return &quot;abc&quot;; } console.log(typeof foo); // string } fn(); 执行上面的代码，首先打印的是function,然后是string. 上面的代码实际上可以修改成如下的代码段。 function fn1() { // 变量提升到函数的顶部 var foo; // 函数提升，但是优先级低，所以出现在变量声明的后面。 function foo() { return &quot;abc&quot;; } console.log(typeof foo); //function foo = &quot;hello&quot;; console.log(typeof foo); //string } 下面，我们再来看一段代码，看一下对应的输出结果是： function foo() { var a = 1; function b() { a = 10; return; function a() {} } b(); console.log(a); } foo(); //1 上面的代码可以修改成如下的代码。 function foo() { //变量a提升 var a; //函数声明b的提升 function b() { //内部的函数声明a的提升 function a() {} //全局变量 a = 10; return; } a = 1; b(); console.log(a);//在当前的作用域中，可以找到变量a，不需要获取全局变量a,所以其值为1，所以打印结果为1， } foo(); 11、闭包在正常的情况下，如果定义了一个函数，就会产生一个函数作用域，在函数体中的局部变量会在这个函数的作用域中使用。 一旦函数执行完毕后，函数所占用的空间就会被回收，存在于函数体中的局部变量同样也会被回收，回收后将不能被访问。 如果我们期望在函数执行完毕以后，函数中的局部变量仍然可以被访问到，应该怎样实现呢？ 这里我们可以通过闭包来实现。 在讲解闭包的问题之前，我们先说一个概念，执行上下文环境。 执行上下文环境JavaScript的每段代码的执行都会存在于一个执行上下文环境中。 执行上下文有且只有三类，全局执行上下文，函数上下文，与eval上下文；由于eval一般不会使用，这里不做讨论 function f1() { f2(); console.log(1); }; function f2() { f3(); console.log(2); }; function f3() { console.log(3); }; f1();//3 2 1 为了方便理解，我们假设执行栈是一个数组，在代码执行初期一定会创建全局执行上下文并压入栈，因此过程大致如下： //代码执行前创建全局执行上下文 ECStack = [globalContext]; // f1调用 ECStack.push('f1 functionContext'); // f1又调用了f2，f2执行完毕之前无法console 1 ECStack.push('f2 functionContext'); // f2又调用了f3，f3执行完毕之前无法console 2 ECStack.push('f3 functionContext'); // f3执行完毕，输出3并出栈 ECStack.pop(); // f2执行完毕，输出2并出栈 ECStack.pop(); // f1执行完毕，输出1并出栈 ECStack.pop(); // 此时执行栈中只剩下一个全局执行上下文 什么是闭包关于闭包的官方概念：一个拥有许多变量和绑定了这些变量执行上下文环境的表达式，通常是一个函数。 简单的理解就是：闭包就是能够读取其它函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 function outer () { ... function inner () { ... } } 所以，本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包有两个比较显著的特点： 第一：函数拥有的外部变量的引用，在函数返回时，该变量仍然处于活跃状态。 第二：闭包作为一个函数返回时，其执行上下文环境不会销毁，仍然处于执行上下文环境中。 在JavaScript中存在一种内部函数，即函数声明和函数表达式可以位于另一个函数的函数体内，在内部函数中可以访问外部函数声明的变量，当这个内部函数在包含它们外部函数之外被调用时，就会形成闭包。 function makeFunc() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); 下面，我们再来看另外一段代码： function fn() { var max = 10; return function bar(x) { if (x &gt; max) { console.log(x); } }; } var f1 = fn(); f1(11); // 11 闭包的应用场景 应用缓存 var cacheApp = (function () { var cache = {}; return { getResult: function (id) { // 如果在内存中，则直接返回 if (id in cache) { return &quot;得到的结果为:&quot; + cache[id]; } //经过耗时函数的处理 var result = timeFn(id); //更新缓存 cache[id] = result; //返回计算的结果 return &quot;得到的结果为:&quot; + result; }, }; })(); //耗时函数 function timeFn(id) { console.log(&quot;这是一个非常耗时的任务&quot;); return id; } console.log(cacheApp.getResult(23)); console.log(cacheApp.getResult(23)); 代码封装 在编程的时候，我们提倡将一定特征的代码封装到一起，只需要对外暴露对应的方法就可以，从而不用关心内部逻辑的实现。 &lt;script&gt; var stack = (function () { //使用数组模拟栈 var arr = []; return { push: function (value) { arr.push(value); }, pop: function () { return arr.pop(); }, size: function () { return arr.length; }, }; })(); stack.push(&quot;abc&quot;); stack.push(&quot;def&quot;); console.log(stack.size()); // 2 console.log(stack.pop()); // def console.log(stack.size()); // 1 &lt;/script&gt; 闭包常见面试题第一：如下程序执行的结果为： 获取所单击的li元素的索引值 &lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;li&gt;e&lt;/li&gt; &lt;/ul&gt; 对应的js代码如下： // 获取所单击的`li`元素的索引值 var list = document.getElementsByTagName(&quot;ul&quot;)[0].children; for (var i = 0; i &lt; list.length; i++) { list[i].onclick = function () { console.log(i); }; } 可以采用闭包解决这个问题： var list = document.getElementsByTagName(&quot;ul&quot;)[0].children; for (var i = 0; i &lt; list.length; i++) { (function (index) { list[index].onclick = function () { console.log(index); }; })(i); } 第二：如下程序输出结果是： var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; for (var i = 0; i &lt; arr.length; i++) { setTimeout(function () { console.log(arr[i]); }, 1000); } 代码修改后的内容为： var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; for (var i = 0; i &lt; arr.length; i++) { (function (index) { setTimeout(function () { console.log(arr[index]); }, 1000); })(i); } 第三：以下程序打印结果是： var userName = &quot;zhangsan&quot;; var person = { userName: &quot;lisi&quot;, method: function () { return function () { return this.userName; }; }, }; console.log(person.method()()); //zhangsan var userName = &quot;zhangsan&quot;; var person = { userName: &quot;lisi&quot;, method: function () { var that = this; //用that保存person的this return function () { return that.userName; }; }, }; console.log(person.method()()); 第四：以下程序的输出结果 function create() { var a = 100; return function () { console.log(a); }; } var fn = create(); var a = 200; fn(); // 100 第五：以下程序的输出结果： function print(fn) { var a = 200; fn(); } var a = 100; function fn() { console.log(a); // 100 } print(fn); 闭包优缺点闭包的优点： 第一：保护函数内变量的安全，实现封装，防止变量流入其它环境发生命名冲突，造成环境污染。 第二：在适当的时候，可以在内存中维护变量并缓存，提高执行效率 闭包的缺点： 消耗内存：通常来说，函数的活动对象会随着执行上下文环境一起被销毁，但是由于闭包引用的是外部函数的活动对象，因此这个活动对象无法被销毁，所以说，闭包比一般的函数需要消耗更多的内存。 12、this指向常见面试题我们知道，当我们创建一个构造函数的实例的时候，需要通过new操作符来完成创建，当创建完成后，函数体中的this指向了这个实例。 如下代码所示： function Person(userName) { this.userName = userName; } var person = new Person(&quot;zhangsan&quot;); console.log(person.userName); 如果，我们将上面的Person函数当作一个普通函数来调用执行，那么对应的this会指向谁呢？ function Person(userName) { this.userName = userName; } Person(&quot;lisi&quot;); console.log(window.userName); 通过上面的程序，我们可以总结出，this指向的永远是函数的调用者。 第一：如下程序的输出结果： var a = 10; var obj = { a: 120, method: function () { var bar = function () { console.log(this.a); // 10 }; bar();//这里是通过window对象完成bar方法的调用 return this.a; }, }; console.log(obj.method()); // 120 第二：如下程序的输出结果是： var num = 10; function Person() { //给全局变量重新赋值 num = 20; // 实例变量 this.num = 30; } Person.prototype.getNum = function () { return this.num; }; var person = new Person(); console.log(person.getNum()); // 30 第三：如下程序的输出结果是： function fn() { console.log(this); } let obj = { fn: fn, }; fn(); //window obj.fn(); //obj 第四：如下程序的输出结果是： var fullName = &quot;language&quot;; var obj = { fullName: &quot;javascript&quot;, prop: { getFullName: function () { return this.fullName; }, }, }; console.log(obj.prop.getFullName()); // undefined var test = obj.prop.getFullName; // language console.log(test()); 第五：如下程序的输出结果是： var val = 1; var json = { val: 10, dbl: function () { val *= 2; //这里由于前面没有添加this,也就是没有写成this.val,所以这里的val指向了全局变量 }, }; json.dbl(); console.log(json.val + val); // 12 如果将上面的题目修改成如下的形式： var val = 1 var json = { val: 10, dbl: function () { this.val *= 2 //20 } } json.dbl() console.log(json.val + val)//21 20+1=21 第六，如下程序的输出结果是： var num = 10; var obj = { num: 20 }; obj.fn = (function (num) { this.num = num * 3; num++; return function (n) { this.num += n; num++; console.log(num); }; })(obj.num); var fn = obj.fn; fn(5); obj.fn(10); console.log(num, obj.num); 第七：this 指向call()函数，apply()函数，bind()函数调用后重新绑定的对象。 我们知道通过call()函数，apply()函数，bind()函数可以改变函数执行的主体，如果函数中存在this关键字，则this指向call()函数，apply()函数，bind()函数处理后的对象。 代码如下： //全局变量 var value = 10; var obj = { value: 20, }; // 全局函数 var method = function () { console.log(this.value); }; method(); // 10 method.call(obj); // 20 method.apply(obj); // 20 var newMethod = method.bind(obj); newMethod(); // 20 下面我们再来看一段代码，看一下对应的执行结果： &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;获取用户信息&lt;/button&gt; &lt;script&gt; var userInfo = { data: [ { userName: &quot;zhangsan&quot;, age: 20 }, { userName: &quot;lisi&quot;, age: 21 }, ], getUserInfo: function () { var index = 1; console.log(this.data[index].userName + &quot; &quot; + this.data[index].age); }, }; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = userInfo.getUserInfo; &lt;/script&gt; &lt;/body&gt; 修改后的代码： var btn = document.getElementById(&quot;btn&quot;); // btn.onclick = userInfo.getUserInfo; btn.onclick = userInfo.getUserInfo.bind(userInfo); 第八、如下程序的输出结果是： &lt;button id=&quot;btn&quot;&gt;获取用户信息&lt;/button&gt; &lt;script&gt; var userInfo = { data: [ { userName: &quot;zhangsan&quot;, age: 20 }, { userName: &quot;lisi&quot;, age: 21 }, ], getUserInfo: function () { this.data.forEach(function (p) { console.log(this); }); }, }; var btn = document.getElementById(&quot;btn&quot;); // btn.onclick = userInfo.getUserInfo; btn.onclick = userInfo.getUserInfo.bind(userInfo); &lt;/script&gt; 修改后的代码： &lt;script&gt; var userInfo = { data: [ { userName: &quot;zhangsan&quot;, age: 20 }, { userName: &quot;lisi&quot;, age: 21 }, ], getUserInfo: function () { var that = this;//保存this this.data.forEach(function (p) { console.log(that);//这里的that 指的就是当前的userInfo对象。 }); }, }; var btn = document.getElementById(&quot;btn&quot;); // btn.onclick = userInfo.getUserInfo; btn.onclick = userInfo.getUserInfo.bind(userInfo); &lt;/script&gt; 或者是修改成箭头函数 var userInfo = { data: [ { userName: &quot;zhangsan&quot;, age: 20 }, { userName: &quot;lisi&quot;, age: 21 }, ], getUserInfo: function () { // var that = this; this.data.forEach((p) =&gt; { console.log(this); }); }, }; var btn = document.getElementById(&quot;btn&quot;); // btn.onclick = userInfo.getUserInfo; btn.onclick = userInfo.getUserInfo.bind(userInfo); 13、call()函数，apply( )函数，bind( )函数的使用与区别在前面我们简单的说过call( )函数，apply( )函数，bind( )函数，的作用。 call( )函数，apply( )函数，bind( )函数,的作用都是改变this的指向，但是在使用方式上是有一定的区别的。 下面我们分别来看一下它们各自的使用方式： call( )函数的基本使用基本语法如下： function.call(thisObj,arg1,arg2,...) function表示的是：需要调用的函数。 thisObj表示：this指向的对象，也就是this将指向thisObj这个参数，如果thisObj的值为null或者是undefined,则this指向的是全局对象。 arg1,arg2,..表示：调用的函数需要的参数。 function add(a, b) { console.log(this); console.log(a + b); } function sub(a, b) { console.log(a - b); } add.call(sub, 3, 1);// 调用add方法，但是add方法中的this指向的是sub,最终的输出结果是4 apply( )函数的基本使用apply()函数的作用与call()函数的作用是一样的，不同的是在传递参数的时候有一定的差别 语法格式如下： function.apply(thisObj,[argsArray]) function表示的是：需要调用的函数。 thisObj:this指向的对象，也就是this将指向thisObj这个参数，如果thisObj的值为null或者是undefined,则this指向的是全局对象。 [argsArray]:表示的是函数需要的参数会通过数组的形式进行传递,如果传递的不是数组或者是arguments对象，会抛出异常。 function add(a, b) { console.log(this); // 这里指向的是sub console.log(a + b); } function sub(a, b) { console.log(a - b); } add.apply(sub, [3, 1]); bind函数的基本使用function.bind(thisObj,arg1,arg2,...) 通过上面语法格式，可以看出bind函数与call函数的参数是一样的。 不同 的是bind函数会返回一个新的函数，可以在任何时候进行调用。 function add(a, b) { console.log(this); // 这里指向的是sub console.log(a + b); } function sub(a, b) { console.log(a - b); } var newFun = add.bind(sub, 3, 1); //bind 返回的是一个新的函数。 newFun();//完成对add函数的调用，同时this指向了sub 三个函数的比较通过前面对三个函数的基本使用，可以看出，它们共同点就是改变this的指向。 不同点： call()函数与apply()函数，会立即执行函数的调用，而bind返回的是一个新的函数，可以在任何时候进行调用。 call()函数与bind函数的参数是一样的，而apply函数第二个参数是一个数组或者是arguments对象。 应用场景这里，我们重点看一下，关于call()函数，bind()函数，apply()函数的应用场景。 求数组中的最大值与最小值 var arr = [3, 6, 7, 1, 9]; console.log(Math.max.apply(null, arr)); console.log(Math.min.apply(null, arr)); 将arguments转换成数组 function fn() { var arr = Array.prototype.slice.call(arguments); arr.push(6); return arr; } console.log(fn(1, 2)); 继承的实现 function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; } function Student(name, age, gender) { Person.call(this, name, age); this.gender = gender; } var student = new Student(&quot;zhangsan&quot;, 20, &quot;男&quot;); console.log( &quot;userName=&quot; + student.userName + &quot;,userAge=&quot; + student.userAge + &quot;,gender=&quot; + student.gender ); 改变匿名函数的this指向 首先看一下如下程序的执行结果： var person = [ { id: 1, userName: &quot;zhangsan&quot; }, { id: 2, userName: &quot;lisi&quot; }, ]; for (var i = 0; i &lt; person.length; i++) { (function (i) { this.print = function () { console.log(this.id); }; this.print(); })(i); } 具体的实现方式如下： var person = [ { id: 1, userName: &quot;zhangsan&quot; }, { id: 2, userName: &quot;lisi&quot; }, ]; for (var i = 0; i &lt; person.length; i++) { (function (i) { this.print = function () { console.log(this.id); }; this.print(); }.call(person[i], i)); } 手写call、apply及bind函数call方法的实现 Function.prototype.myCall = function (context) { var args = [...arguments].slice(1); context = context || window; context.fn = this; var result = context.fn(...args); return result; }; function Add(num1, num2) { console.log(this); console.log(num1 + num2); } function Sub(num1, num2) { console.log(num1 - num2); } Add.myCall(Sub, 6, 3); apply函数的实现 Function.prototype.myApply = function (context) { var result = null; context = context || window; context.fn = this; if (arguments[1]) { // console.log(&quot;arguments=&quot;, arguments[1]);// arguments= (2) [6, 3] result = context.fn(...arguments[1]); } else { result = context.fn(); } return result; }; function Add(num1, num2) { console.log(this); console.log(num1 + num2); } function Sub(num1, num2) { console.log(num1 - num2); } Add.myApply(Sub, [6, 3]); bind函数的实现 Function.prototype.myBind = function (context) { // 获取参数 var args = [...arguments].slice(1), // [1,5] fn = this; // console.log(this);//Add return function Fn() { // console.log(this); //Window return fn.apply(context, args); }; }; function Add(num1, num2) { console.log(this); console.log(num1 + num2); } function Sub(num1, num2) { console.log(num1 - num2); } var newFun = Add.myBind(Sub, 1, 5); newFun(); &lt;script&gt; function add(a, b) { console.log(this); // 这里指向的是sub console.log(a + b); } function sub(a, b) { console.log(a - b); } var newFun = add.bind(sub, 3); //bind 返回的是一个新的函数。 newFun(2); //完成对add函数的调用，同时this指向了sub &lt;/script&gt; 下面，我们就实现一下关于myBind方法参数的模拟。 Function.prototype.myBind = function (context) { // 获取参数 var args = [...arguments].slice(1), fn = this; // console.log(this);//Add return function Fn() { // console.log(this); //Window //这里是调用bind函数的时候传递的参数，将其转换成数组 var bindArgs = Array.prototype.slice.call(arguments); //下面完成参数的拼接 return fn.apply(context, args.concat(bindArgs)); }; }; function Add(num1, num2) { console.log(this); console.log(num1 + num2); return 10; } function Sub(num1, num2) { console.log(num1 - num2); } var newFun = Add.myBind(Sub, 1); console.log(newFun(8)); 14、回调函数有什么缺点在JavaScript编程过程中，我们经常会写回调函数。 我们知道在JavaScript中函数也是一种对象，对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。 例如，如下的代码示例： const btn=document.getElementById('btn'); btn.addEventListener('click',function(event){ }) 回调函数有一个比较严重的问题，就是很容易出现回调地狱的问题。也就是实现了回调函数不断的嵌套。 setTimeout(() =&gt; { console.log(1) setTimeout(() =&gt; { console.log(2) setTimeout(() =&gt; { console.log(3) },3000) },2000) },1000) 以上的代码就是典型的回调地狱的问题，这样的代码是非常不利于阅读和维护的。 所以在ES6中提供了Promise以及async/await来解决地狱回调的问题。关于这块内容 15、 为什么函数被称为一等公民？JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。 同时函数还可以作为类的构造函数，完成对象实例的创建。所以说，这种多重身份让JavaScript中的函数变得非常重要，所以说函数被称为一等公民。 四、对象1、对象的属性给对象添加属性非常的简单如下所示： var person={ userName:'zhangsan' } 如果想修改属性的特性，可以通过Object.defineProperty()来完成。 var person = { userName: &quot;zhangsan&quot;, }; Object.defineProperty(person, &quot;userName&quot;, { writable: false, }); person.userName = &quot;lisi&quot;; //无法完成值的修改 console.log(person.userName); //zhangsan 我们可以给Object.defineProperty添加getter()函数和setter( )函数，这两个函数可以实现对象的私有属性，私有属性不对外公布，如果想要对私有属性进行读取和写入，可以通过getter()函数和setter( )函数。 var person = { _age: 20, // _age表示私有属性 }; Object.defineProperty(person, &quot;age&quot;, { get: function () { return this._age; }, //在给私有属性赋值的时候，完成对应的校验功能 set: function (value) { if (value &gt;= 18) { this._age = value; console.log(&quot;可以浏览该网站&quot;); } else { console.log(&quot;不可以浏览该网站&quot;); } }, }); console.log(person.age); //20 person.age = 12; console.log(person.age); //20 person.age = 30; console.log(person.age); // 30 关于Object.defineProperty更详细的内容，可以参考vue响应式原理的课程。 2、属性访问方式的区别我们知道访问对象中的属性，有两种方式。 第一种方式:通过‘.’来访问。 第二种方式:通过‘[ ]’来访问属性。 两种方式有什么区别呢？ 第一：使用方括号来访问属性，可以借助于变量来实现。 var person = { userName: &quot;zhangsan&quot;, }; var myName = &quot;userName&quot;; console.log(person[myName]); 第二：使用方括号来访问属性，也可以通过数字来做属性。 var person = {}; person[1] = &quot;hello&quot;; console.log(person[1]); 3、创建对象有哪几种方式字面量方式创建对象 var userInfo = { userName: &quot;zhangsan&quot;, userAge: 18, getUserInfo: function () { console.log(this.userName + &quot;:&quot; + this.userAge); }, }; userInfo.getUserInfo(); 字面量创建对象比较简单，但是问题也比较突出，每次只能创建一个对象，复用性比较差，如果需要创建多个对象，代码冗余比较高。 通过工厂模式创建对象 工厂模式是一个比较重要的设计模式，该模式提供了一个函数，在该函数中完成对象的创建。 function createUser(userName, userAge) { var o = new Object(); o.userName = userName; o.userAge = userAge; o.sayHi = function () { console.log(this.userName + &quot;:&quot; + this.userAge); }; return o; } var user1 = createUser(&quot;wangwu&quot;, 20); var user2 = createUser(&quot;lisi&quot;, 20); console.log(user1.userName + &quot;:&quot; + user2.userName); 通过工厂模式创建对象，解决了字面量创建对象的问题，也就是当创建多个相似对象的时候代码重复的问题。 但是问题是，所创建的所有对象都是Object类型，无法进一步的区分对象的具体类型是什么。 通过构造函数创建对象 function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; this.sayHi = function () { console.log(this.userName + &quot;:&quot; + this.userAge); }; } var p = new Person(&quot;zhangsan&quot;, 19); p.sayHi(); 构造函数创建对象的优点：解决了工厂模式中对象类型无法识别的问题，也就是说通过构造函数创建的对象可以确定其所属的类型。 但是通过构造函数创建对象的问题： 在使用构造函数创建对象的时候，每个方法都会在创建对象时重新创建一遍，也就是说，根据Person构造函数每创建一个对象，我们就会创建一个sayHi方法，但它们做的事情是一样的，因此会造成内存的浪费。 通过原型模式创建对象 我们知道，每个函数都有一个prototype属性，这个属性指向函数的原型对象，而所谓的通过原型模式创建对象就是将属性和方法添加到prototype属性上。 function Person() {} Person.prototype.userName = &quot;wangwu&quot;; Person.prototype.userAge = 20; Person.prototype.sayHi = function () { console.log(this.userName + &quot;:&quot; + this.userAge); }; var person1 = new Person(); person1.sayHi(); var person2 = new Person(); console.log(person1.sayHi === person2.sayHi); // true 通过上面的代码，我们可以发现，使用基于原型模式创建的对象，它的属性和方法都是相等的，也就是说不同的对象会共享原型上的属性和方法，这样我们就解决了构造函数创建对象的问题。 但是这种方式创建的对象也是有问题的，因为所有的对象都是共享相同的属性，所以改变一个对象的属性值，会引起其他对象属性值的改变。而这种情况是我们不允许的，因为这样很容易造成数据的混乱。 function Person() {} Person.prototype.userName = &quot;wangwu&quot;; Person.prototype.userAge = 20; Person.prototype.arr = [1, 2]; Person.prototype.sayHi = function () { console.log(this.userName + &quot;:&quot; + this.userAge); }; var p1 = new Person(); var p2 = new Person(); console.log(p1.userName); p2.userName = &quot;zhangsan&quot;; console.log(p1.userName); //wangwu,基本数据类型不受影响 p1.arr.push(3); console.log(p1.arr); // [1,2,3] console.log(p2.arr); // [1,2,3] //引用类型受影响 组合使用构造函数模式和原型模式 通过构造函数和原型模式创建对象是比较常用的一种方式。 在构造函数中定义对象的属性，而在原型对象中定义对象共享的属性和方法。 //在构造函数中定义对象的属性 function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; } //在原型对象中添加共享的方法 Person.prototype.sayHi = function () { return this.userName; }; var p = new Person(&quot;zhangsan&quot;, 21); var p1 = new Person(&quot;lisi&quot;, 22); console.log(p1.sayHi()); console.log(p.sayHi()); // 不同对象共享相同的函数，所以经过比较发现是相等的。 console.log(p.sayHi === p1.sayHi); //修改p对象的userName属性的值，但是不会影响到p1对象的userName属性的值 p.userName = &quot;admin&quot;; console.log(p.sayHi()); console.log(p1.sayHi()); 通过构造函数与原型模式组合创建对象的好处就是：每个对象都有自己的属性值，也就是拥有一份自己的实例属性的副本，同时又共享着方法的引用，最大限度的节省了内存。 使用动态原型模式创建对象 所谓的使用动态原型模式创建对象，其实就是将所有的内容都封装到构造函数中，而在构造函数中通过判断只初始化一次原型。 function Person(userName, userAge) { this.userName = userName; this.userAge = userAge; if (typeof this.sayHi !== &quot;function&quot;) { console.log(&quot;abc&quot;); //只输出一次 Person.prototype.sayHi = function () { console.log(this.userName); }; } } var person = new Person(&quot;zhangsan&quot;, 21); var person1 = new Person(&quot;zhangsan&quot;, 21); person.sayHi(); person1.sayHi(); 通过上面的代码可以看出，我们将所有的内容写在了构造函数中，并且在构造函数中通过判断只初始化一次原型，而且只在第一次生成实例的时候进行原型的设置。这种方式创建的对象与构造函数和原型混合模式创建的对象功能上是相同的。 4、对象拷贝拷贝指的就是将某个变量的值复制给另外一个变量的过程，关于拷贝可以分为浅拷贝与深拷贝。 针对不同的数据类型，浅拷贝与深拷贝会有不同的表现，主要表现于基本数据类型和引用数据类型在内存中存储的值不同。 对于基本数据类型，变量存储的是值本身， 对于引用数据类型，变量存储的是值在内存中的地址，如果有多个变量同时指向同一个内存地址，其中对一个变量的值进行修改以后，其它的变量也会受到影响。 var arr=[1,23,33] var arr2=arr arr2[0]=10; console.log(arr) // [10, 23, 33] 在上面的代码中，我们把arr赋值给了arr2,然后修改arr2的值，但是arr也受到了影响。 正是由于数据类型的不同，导致在进行浅拷贝与深拷贝的时候首先的效果是不一样的。 基本数据类型不管是浅拷贝还是深拷贝都是对值的本身的拷贝。对拷贝后值的修改不会影响到原始的值。 对于引用数据类型进行浅拷贝，拷贝后的值的修改会影响到原始的值，如果执行的是深拷贝，则拷贝的对象和原始对象之间相互独立，互不影响。 所以，这里我们可以总结出什么是浅拷贝，什么是深拷贝。 浅拷贝：如果一个对象中的属性是基本数据类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，也就是拷贝后的内容与原始内容指向了同一个内存地址，这样拷贝后的值的修改会影响到原始的值。 深拷贝：如果一个对象中的属性是基本数据类型，拷贝的也是基本类型的值，如果属性是引用类型，就将其从内存中完整的拷贝一份出来，并且会在堆内存中开辟出一个新的区域存来进行存放，而且拷贝的对象和原始对象之间相互独立，互不影响。 浅拷贝下面我们先来看一下浅拷贝的内容 var obj = { a: 1, arr: [2, 3], o: { name: &quot;zhangsan&quot; } }; var shallowObj = shallowCopy(obj); function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst; } obj.o.name = &quot;lisi&quot;; console.log(shallowObj.o.name); //lisi,值受到了影响 obj.arr[0] = 20; console.log(shallowObj.arr[0]); //20，值受到了影响 obj.a = 10; console.log(shallowObj.a); // 1,值没有收到影响 除了以上方式实现浅拷贝以外，还可以通过ES6中的Object.assign()函数来实现，该函数可以将源对象中的可枚举的属性复制到目标对象中。 var obj = { a: 1, arr: [2, 3], o: { name: &quot;zhangsan&quot; } }; var result = {}; //将obj对象拷贝给result对象 Object.assign(result, obj); console.log(result); obj.a = 10; console.log(result.a); // 1，不受影响 obj.arr[0] = 20; console.log(result.arr[0]); //20 受影响 obj.o.name = &quot;lisi&quot;; console.log(result.o.name); // lisi 受影响 深拷贝下面，我们来看一下深拷贝内容 这里，我们可以使用 JSON.parse(JSON.stringify()); 来实现深拷贝。 JSON.stringify()可以将对象转换为字符串 JSON.parse()可以将字符串反序列为一个对象 var obj = { a: 1, arr: [2, 3], o: { name: &quot;zhangsan&quot; } }; var str = JSON.stringify(obj); var resultObj = JSON.parse(str); obj.a = 10; console.log(resultObj.a); // 1 不受影响 obj.arr[0] = 20; console.log(resultObj.arr[0]); // 2 不受影响 obj.o.name = &quot;lisi&quot;; console.log(resultObj.o.name); // zhangsan 不受影响 以上通过JSON对象，虽然能够实现深拷贝，但是还是有一定的问题的。 第一：无法实现对函数的拷贝 第二：如果对象中存在循环引用，会抛出异常。 第三：对象中的构造函数会指向Object,原型链关系被破坏。 function Person(userName) { this.userName = userName; } var person = new Person(&quot;zhangsan&quot;); var obj = { fn: function () { console.log(&quot;abc&quot;); }, // 属性o的值为某个对象 o: person, }; var str = JSON.stringify(obj); var resultObj = JSON.parse(str); console.log(&quot;resultObj=&quot;, resultObj); // 这里丢失了fn属性。因为该属性的值为函数 console.log(resultObj.o.constructor); //指向了Object,导致了原型链关系的破坏。 console.log(obj.o.constructor); // 这里指向Person构造函数，没有问题 下面我们再来看一下循环引用的情况： var obj = { userName: &quot;zhangsan&quot;, }; obj.a = obj; var result = JSON.parse(JSON.stringify(obj)); 以上的内容会抛出异常。 自己模拟实现深拷贝 这里，我们实现一个简单的深拷贝，当然也可以使用第三方库中的方法来实现深拷贝，例如：可以使用jQuery中的$.extend() 在浅拷贝中，我们通过循环将源对象中属性依次添加到目标对象中，而在深拷贝中，需要考虑对象中的属性是否有嵌套的情况（属性的值是否还是一个对象），如果有嵌套可以通过递归的方式来实现，直到属性为基本类型，也就是说，我们需要将源对象各个属性所包含的对象依次采用递归的方式复制到新对象上。 function clone(target) { if (typeof target === &quot;object&quot;) { let objTarget = {}; for (const key in target) { //通过递归完成拷贝 objTarget[key] = clone(target[key]); } return objTarget; } else { return target; } } var obj = { userName: &quot;zhangsan&quot;, a: { a1: &quot;hello&quot;, }, }; var result = clone(obj); console.log(result); 以上就是一个最简单的深拷贝功能，但是在这段代码中我们只考虑了普通的object,还没有实现数组，所以将上面的代码修改一下，让其能够兼容到数组。 function clone(target) { if (typeof target === &quot;object&quot;) { //判断target是否为数组 let objTarget = Array.isArray(target) ? [] : {}; for (const key in target) { objTarget[key] = clone(target[key]); } return objTarget; } else { return target; } } var obj = { userName: &quot;zhangsan&quot;, a: { a1: &quot;hello&quot;, }, //添加数组 arr: [2, 3], }; var result = clone(obj); console.log(result); 在上面的代码中，添加了 let objTarget = Array.isArray(target) ? [] : {};判断target是否为数组。 下面我们来看一下循环引用的情况： function clone(target) { if (typeof target === &quot;object&quot;) { //判断target是否为数组 let objTarget = Array.isArray(target) ? [] : {}; for (const key in target) { objTarget[key] = clone(target[key]); } return objTarget; } else { return target; } } var obj = { userName: &quot;zhangsan&quot;, a: { a1: &quot;hello&quot;, }, //添加数组 arr: [2, 3], }; obj.o = obj; //构成了循环引用 var result = clone(obj); console.log(result); 在上面的代码中，添加了obj.o=obj.然后出现了Maximum call stack size exceeded 以上的错误表明了递归进入了死循环导致栈内存溢出。 原因是：对象存在循环引用的情况，也就是对象的属性间接或直接引用了自身的情况。 解决的方法：这里我们可以额外开辟一个存储空间，在这个存储空间中存储当前对象和拷贝对象之间的对应关系。 当需要拷贝当前的对象的时候，先去这个存储空间中进行查找，如果没有拷贝过这个对象，执行拷贝操作。如果已经拷贝过这个对象，直接返回，这样就可以解决循环引用的问题。 let map = new WeakMap(); function clone(target) { if (typeof target === &quot;object&quot;) { //判断target是否为数组 let objTarget = Array.isArray(target) ? [] : {}; // 如果有直接返回 if (map.get(target)) { return target; } //存储当前对象与拷贝对象的对应关系 map.set(target, objTarget); for (const key in target) { objTarget[key] = clone(target[key]); } return objTarget; } else { return target; } } var obj = { userName: &quot;zhangsan&quot;, a: { a1: &quot;hello&quot;, }, //添加数组 arr: [2, 3], }; obj.o = obj; //构成了循环引用 var result = clone(obj); console.log(result); 以上就是一个基本的深拷贝的案例。 5、重写原型对象的问题原型对象 在前面的课程中，我们讲解过原型对象，我们知道每个函数在创建的时候都会有一个prototype属性，它指向函数的原型对象。 在这个对象中可以包含所有实例共享的属性和方法。例如上图中的sayName方法。 同时在每个原型对象上都会增加一个constructor属性，该属性指向prototype属性所在的构造函数，如上图所示。 当我们通过new操作符创建一个实例的时候，该实例就有了一个__proto__属性，该属性指向了构造函数的原型对象，如上图所示： 所以说，__proto__属性可以看作是一个连接实例与构造函数的原型对象的桥梁。 所以三者的关系是，每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。通俗点说就是，实例通过内部指针可以访问到原型对象，原型对象通过constructor指针，又可以找到构造函数。也就是上图体现的内容。 下面我们来看一个问题：重写原型对象 我们在前面写代码的时候，每次都是为原型对象添加一个属性或者函数时，都是直接给Person.prototype上添加，这种写法比较冗余。 我们可以将属性和方法写成一个字面量对象的形式，然后在赋值给prototype属性。 如下代码所示： function Person() {} Person.prototype = { userName: &quot;zhangsan&quot;, age: 20, sayHi: function () { console.log(this.userName); }, }; var person = new Person(); person.sayHi(); //zhangsan 通过执行的结果，依然可以获取到原型对象上属性的值。 当我们把一个字面量对象赋值给prototype属性以后，实际上就是重写了原型对象。 但是这时候，我们打印Person.prototype.constructor的时候，发现不在指向Person这个构造函数,而是指向了Object构造函数。 function Person() {} Person.prototype = { userName: &quot;zhangsan&quot;, age: 20, sayHi: function () { console.log(this.userName); }, }; var person = new Person(); person.sayHi(); console.log(Person.prototype.constructor); // Object 原因是：在重写prototype的时候，我们使用字面量创建了一个新的对象，并且这个新的对象中少了constructor属性， 如下图所示 而我们可以看到在字面量对象中有一个__proto__属性，指向了Object的原型对象,这时，只能去Object原型对象中查找是否有constructor属性，而Object原型对象中的constructor指向的还是Object.所以最终输出结果为Object. 我们怎样避免这种情况呢？ 可以在重写原型对象的时候添加constructor属性。这样就不用在去新对象的原型对象中查找constructor属性了。 function Person() {} Person.prototype = { constructor: Person, //添加constructor userName: &quot;zhangsan&quot;, age: 20, sayHi: function () { console.log(this.userName); }, }; var person = new Person(); person.sayHi(); console.log(Person.prototype.constructor);// Person 重写了原型对象以后，还需要注意一个问题，就是在重写原型对象之前，已经生成的对象的实例，无法获取新的原型对象中的属性和方法。 如下代码所示： &lt;script&gt; function Person() {} var person = new Person();//在重写原型对象之前，生成对象的实例 Person.prototype = { constructor: Person, //添加constructor userName: &quot;zhangsan&quot;, age: 20, sayHi: function () { console.log(this.userName); }, }; // var person = new Person(); person.sayHi(); // person.sayHi is not a function,无法获取sayHi函数。 console.log(Person.prototype.constructor); &lt;/script&gt; 造成上面错误的原因是：person这个对象指向的是最初的原型对象，而最初的原型对象中是没有sayHi这个方法的。 所以在执行的时候会抛出异常。 6、继承的实现方式有哪些关于继承的实现方式，在前面，我们也已经讲解过，这里做一个汇总。 原型链继承代码如下： function Animal() { this.superType = &quot;Animal&quot;; this.name = name || &quot;动物&quot;; //实例方法 this.sleep = function () { console.log(this.name + &quot;正在睡觉!!&quot;); }; } //原型上的函数 Animal.prototype.eat = function (food) { console.log(this.name + &quot;正在吃:&quot; + food); }; function Dog(name) { this.name = name; } // 改变Dog的prototype指向，指向了一个Animal实例，实现了原型继承 Dog.prototype = new Animal(); var doggie = new Dog(&quot;wangcai&quot;); console.log(doggie.superType); doggie.sleep(); doggie.eat(&quot;狗粮&quot;); 在上面的代码中，将Animal的实例赋值给了Dog的原型对象，这样就实现了原型的继承，所以Dog的实例可以获取父类Animal中的superType属性，调用父类中的实例方法，原型上的函数。 下面，可以通过一张图来理解一下： 原来的构造函数Dog的prototype指向的是Dog的原型对象，但是现在指向了Animal的实例对象。也就是说构造函数Dog的原型对象为Animal的实例对象。 这样会出现什么样的效果呢？ 注意：上面我们所写的代码还是有一个小的问题的。 Dog.prototype.constructor指向了Animal Dog.prototype.constructor===Animal // true 这里，还是要求Dog.prototype.constructor指向Dog function Animal() { this.superType = &quot;Animal&quot;; this.name = name || &quot;动物&quot;; //实例方法 this.sleep = function () { console.log(this.name + &quot;正在睡觉!!&quot;); }; } Animal.prototype.eat = function (food) { console.log(this.name + &quot;正在吃:&quot; + food); }; function Dog(name) { this.name = name; } // 改变Dog的prototype指向，指向了一个Animal实例，实现了原型继承 Dog.prototype = new Animal(); // 将Dog的构造函数指向自身 Dog.prototype.constructor = Dog; var doggie = new Dog(&quot;wangcai&quot;); console.log(doggie.superType); doggie.sleep(); doggie.eat(&quot;狗粮&quot;); 原型继承的优点： 第一：实现起来非常简单 只要设置子类的portotype属性为父类的实例即可。 第二：可以通过子类的实例直接访问父类原型链中的属性和函数。 原型继承的缺点： 第一：我们知道子类的所有实例将共享父类的属性，这样就会导致一个问题：如果父类中的某个属性的值为引用类型，某个子类的实例去修改这个属性的值，就会影响到其它实例的值。 如下代码所示： function Person() { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 } function Studnet(id) { this.id = id; // 学号 } Studnet.prototype = new Person(); Studnet.prototype.constructor = Studnet; var stu1 = new Studnet(1001); console.log(stu1.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;] stu1.emotion.push(&quot;玩游戏&quot;); console.log(stu1.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;, &quot;玩游戏&quot;] //创建 stu2对象 var stu2 = new Studnet(1002); console.log(stu2.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;, &quot;玩游戏&quot;] 通过上面的代码，我们可以看到stu1对象向数组emotion数组中添加了一项以后，stu2对象也收到了影响。 第二：在创建子类的实例的时候，无法向父类的构造函数中传递参数。 在通过new操作符创建子类的实例的时候，会调用子类的构造函数，而在子类的构造函数中并没有设置与父类的关联操作，所以无法向父类的构造函数中传递参数。 第三：在给子类的原型对象上添加属性或者是方法的时候，一定要放在Student.prototype=new Person语句的后面。 如下代码： function Person() { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 } function Studnet(id) { this.id = id; // 学号 } //在Studnet.prototype = new Person();代码前给Student的prototype添加study方法。 Studnet.prototype.study = function () { console.log(&quot;好好学习，天天向上&quot;); }; Studnet.prototype = new Person(); Studnet.prototype.constructor = Studnet; var stu1 = new Studnet(1001); stu1.study(); 指向上面的代码，会出现stu1.study is not a function的错误。 原因：后面通过Studnet.prototype = new Person();这行代码对Student的原型对象进行了重写，所以导致study方法无效了。 修改后的代码： function Person() { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 } function Studnet(id) { this.id = id; // 学号 } Studnet.prototype = new Person(); Studnet.prototype.constructor = Studnet; //放在了Studnet.prototype=new Person语句的后面 Studnet.prototype.study = function () { console.log(&quot;好好学习，天天向上&quot;); }; var stu1 = new Studnet(1001); stu1.study(); 构造函数继承在子类的构造函数中，通过apply()方法或者是call()方法，调用父类的构造函数，从而实现继承功能。 function Person() { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 } function Studnet(id) { this.id = id; // 学号 Person.call(this); } var stu1 = new Studnet(1001); console.log(stu1.emotion); 如下代码： function Person() { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 } function Studnet(id) { this.id = id; // 学号 Person.call(this); } var stu1 = new Studnet(1001); var stu2 = new Studnet(1002); stu1.emotion.push(&quot;玩游戏&quot;); console.log(stu1.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;, &quot;玩游戏&quot;] console.log(stu2.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;] 通过上面的代码，可以看到stu1对象向emotion数组中添加数据，并不会影响到stu2对象。 构造函数继承的优点 第一：由于在子类的构造中通过call改变了父类中的this指向，导致了在父类构造函数中定义的属性或者是方法都赋值给了子类，这样生成的每个子类的实例中都具有了这些属性和方法。而且它们之间是互不影响的，及时是引用类型。 第二：创建子类的实例的时候，可以向父类的构造函数中传递参数。 //传递age参数 function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; this.age = age; } //传递age参数 function Studnet(id, age) { this.id = id; // 传递age参数 Person.call(this, age); } var stu1 = new Studnet(1001, 20);//传递年龄 var stu2 = new Studnet(1002, 21); stu1.emotion.push(&quot;玩游戏&quot;); console.log(stu1.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;, &quot;玩游戏&quot;] console.log(stu2.emotion); // [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;] console.log(stu1.age); // 20 console.log(stu2.age); // 21 构造函数继承的缺点 第一：子类只能继承父类中实例的属性和方法，无法继承父类原型对象上的属性和方法。 function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 this.age = age; } // 原型上的方法 Person.prototype.study = function () { console.log(&quot;好好学习，天天向上&quot;); }; function Studnet(id, age) { this.id = id; // 学号 Person.call(this, age); } var stu = new Studnet(1001, 20); console.log(stu.age); // 20 stu.study(); //stu.study is not a function 第二：在父类的构造函数中添加一个实例方法，对应的子类也就有了该实例方法，但是问题时，每创建一个子类的实例，都会有一个父类中的实例方法，这样导致的结果就是占用内存比较大。以前我们是定义在prototype原型上来解决这个问题的，但是在构造函数的继承中，又出现了这个。 function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 this.age = age; this.study = function () { console.log(this.id + &quot;号同学要努力学习&quot;); }; } function Studnet(id, age) { this.id = id; // 学号 Person.call(this, age); } var stu = new Studnet(1001, 20); stu.study(); var stu1 = new Studnet(1002, 20); stu1.study(); //stu对象和stu1对象都单独有一个study方法。 拷贝继承所谓的拷贝继承指的是先创建父类的实例，然后通过for...in的方式来遍历父类实例中的所有属性和方法，并依次赋值给子类的实例，同时原型上的属性和函数也赋给子类的实例。 function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 this.age = age; this.study = function () { console.log(this.id + &quot;号同学要努力学习&quot;); }; } Person.prototype.run = function () { console.log(this.id + &quot;号学生正在跑步,年龄是:&quot; + this.age); }; function Studnet(id, age) { var person = new Person(age); for (var key in person) { if (person.hasOwnProperty(key)) { this[key] = person[key]; } else { Studnet.prototype[key] = person[key]; } } // 子类自身的属性 this.id = id; } var student = new Studnet(1001, 21); student.study(); student.run(); 在上面的代码中，创建了父类Person,并且在该类中指定了相应的实例属性和实例方法，同时为其原型对象中也添加了方法。 在Studnet这个子类中，首先会创建父类Person的实例，然后通过for...in来进行遍历，获取父类中的属性和方法，获取以后进行判断，如果person.hasOwnProperty(key)返回值为false，表示获取到的是父类原型对象上的属性和方法，所以也要添加到子类的prototype属性上，成为子类的原生对象上的属性或者是方法。 最后创建子类的实例student,通过子类的实例student,可以访问继承到的属性或者是方法。 拷贝继承的优点 第一：可以实现向父类中的构造方法中传递参数。 第二：能够实现让子类继承父类中的实例属性，实例方法以及原型对象上的属性和方法。 拷贝继承的缺点 父类的所有属性和方法，子类都需要复制拷贝一遍，所以比较消耗内存。 组合继承组合继承的核心思想是将构造函数继承与原型继承两种方式组合在一起。 function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 this.age = age; this.study = function () { console.log(this.id + &quot;号同学要努力学习&quot;); }; } Person.prototype.run = function () { console.log(this.id + &quot;号学生正在跑步,年龄是:&quot; + this.age); }; function Studnet(id, age) { Person.call(this, age); this.id = id; //子类独有的属性 } Studnet.prototype = new Person(); Studnet.prototype.constructor = Studnet; var student = new Studnet(1001, 21); student.run(); console.log(&quot;爱好是:&quot; + student.emotion); 组合继承的优点 第一：通过Person.call(this,ge)这个行代码，可以将父类中的实例属性和方法添加到子类Student中，另外通过Studnet.prototype = new Person(); 可以将父类的原型对象上的属性和函数绑定到Student的原型对象上。 第二：可以向父类的构造函数中传递参数。 组合继承的缺点 组合继承的主要缺点是父类的实例属性会绑定两次。 第一次是在子类的构造函数中通过call( )函数调用了一次父类的构造函数，完成实例属性和方法的绑定操作。 第二次是在改写子类prototype属性的时候，我们执行了一次new Person()的操作，这里又将父类的构造函数调用了一次，完成了属性的绑定操作。 所以在整个组合继承的过程中，父类实例的属性和方法会进行两次的绑定操作。当然这里需要你注意的一点是：通过call()函数完成父类中实例属性和方法的绑定的优先级要高于通过改写子类prototype的方式。也就是说第一种方式会覆盖第二种方式： 如下代码所示： function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 this.age = age; //实例方法 this.study = function () { console.log(this.id + &quot;号同学要努力学习&quot;); }; } Person.prototype.run = function () { console.log(this.id + &quot;号学生正在跑步,年龄是:&quot; + this.age); }; // 原型方法 Person.prototype.study = function () { console.log(this.id + &quot;号学生需要好好学习&quot;); }; function Studnet(id, age) { Person.call(this, age); this.id = id; //子类独有的属性 } Studnet.prototype = new Person(); Studnet.prototype.constructor = Student; var student = new Studnet(1001, 21); student.run(); console.log(&quot;爱好是:&quot; + student.emotion); student.study(); //调用父类的实例方法student 在上面的代码中，在父类Person的构造函数中定义了实例方法study,同时在其原型对象上也定义了一个study方法。 通过子类的实例调用study方法的时候，调用的是父类的实例方法study. 寄生式组合继承 function Person(age) { this.emotion = [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;学习&quot;]; // 爱好 this.age = age; this.study = function () { console.log(this.id + &quot;号同学要努力学习&quot;); }; } Person.prototype.run = function () { console.log(this.id + &quot;号学生正在跑步,年龄是:&quot; + this.age); }; Person.prototype.study = function () { console.log(this.id + &quot;号学生需要好好学习&quot;); }; function Studnet(id, age) { Person.call(this, age); this.id = id; } // 定义Super构造函数 function Super() {} //Super.prototype原型对象指向了Person.prototype Super.prototype = Person.prototype; //Student.prototype原型对象指向了Super的实例，这样就去掉了Person父类的实例属性。 Studnet.prototype = new Super(); Studnet.prototype.constructor = Studnet; var student = new Studnet(1001, 21); student.run(); console.log(&quot;爱好是:&quot; + student.emotion); student.study(); 在上面的代码中，创建了一个Super构造函数，让Super.prototype的原型指向了Person.prototype,同时将Super的对象赋值给了Student.prototype，这样就去掉了Person父类的实例属性。 通过寄生式组合继承解决了组合继承的问题。 同时，在以后的应用中，可以使用组合继承，也可以使用寄生式组合继承。 7、模拟jQuery实现下面我们通过模拟实现一个简单的jQuery,来巩固原型的应用。 &lt;script&gt; // 为jQuery起一个别名，模仿jQuery的框架 var $ = (jQuery = function () {}); // 为jQuery原型起一个别名 //这里没有直接赋值给fn，否则它属于window对象，容易造成全局污染 //后面要访问jquery的原型，可以直接通过jQuery.fn来实现 jQuery.fn = jQuery.prototype = { version: &quot;6.1.1&quot;, //添加原型属性，表示jquery的版本 //添加原型方法，表示返回jquery对象的长度 size: function () { return this.length; }, }; &lt;/script&gt; 下面，我们使用jQuery原型中的size方法和version属性。 // 为jQuery起一个别名，模仿jQuery的框架 var $ = (jQuery = function () {}); // 为jQuery原型起一个别名 //这里没有直接赋值给fn，否则它属于window对象，容易造成全局污染 //后面要访问jquery的原型，可以直接通过jQuery.fn来实现 jQuery.fn = jQuery.prototype = { version: &quot;6.1.1&quot;, //添加原型属性，表示jquery的版本 //添加原型方法，表示返回jquery对象的长度 size: function () { return this.length; }, }; var jq = new $(); console.log(jq.version); // 6.1.1 console.log(jq.size()); // undefined 在上面的代码中，我们是创建了一个jquery的实例，然后通过该实例完成了原型属性和方法的调用。 但是在jquery库中，是采用如下的方式进行调用。 $().version; $().size() 通过以上的两行代码，我们可以看到在jQuery库中，并没有使用new操作符，而是直接使用小括号运算符完成了对jQuery构造函数的调用。然后后面直接访问原型成员。 那应该怎样实现这种操作？ 我们想到的就是，在jquery的构造函数中，直接创建jQuery类的实例。 // 为jQuery起一个别名，模仿jQuery的框架 var $ = (jQuery = function () { return new jQuery(); }); // 为jQuery原型起一个别名 //这里没有直接赋值给fn，否则它属于window对象，容易造成全局污染 //后面要访问jquery的原型，可以直接通过jQuery.fn来实现 jQuery.fn = jQuery.prototype = { version: &quot;6.1.1&quot;, //添加原型属性，表示jquery的版本 //添加原型方法，表示返回jquery对象的长度 size: function () { return this.length; }, }; $().version; // var jq = new $(); // console.log(jq.version); // 6.1.1 // console.log(jq.size()); 在上面的代码中，给jQuery构造函数直接返回了它的实例，return new jQuery(); 然后获取原型对象中的size属性的值:$().version. 但是，出现了如下的错误： Uncaught RangeError: Maximum call stack size exceeded 以上错误的含义是栈内存溢出。 原因就是：当我们通过$()调用构造函数的时候，内部有执行了new操作，这时，又会重新执行jQuery的构造函数，这样就造成了死循环。 var $ = (jQuery = function () { return jQuery.fn.init(); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function () { return this; //返回jquery的原型对象 }, version: &quot;6.1.1&quot;, size: function () { return this.length; }, }; console.log($().version); 在上面的代码中，在jQuery的构造方法中，调用的是原型中的init方法，在该方法中，返回了jquery的原型对象。 最后进行输出:cosnole.log($().version) 但是，以上的处理还是隐藏一个问题，具体看如下代码： var $ = (jQuery = function () { return jQuery.fn.init(); }); jQuery.fn = jQuery.prototype = { init: function () { this.length = 0; //原型属性length this._size = function () { //原型方法 return this.length; }; return this; }, version: &quot;6.1.1&quot;, length: 1, // 原型属性 size: function () { return this.length; }, }; console.log($().version); console.log($()._size()); // 0 console.log($().size()); // 0 在上面的代码中，在init这个原型方法中添加了lenght属性与_size方法，在该方法中打印length的值。 var $ = (jQuery = function () { return new jQuery.fn.init(); //调用原型中的`init方法` }); 在jQuery的构造函数中，通过new操作符创建了一个实例对象，这样init()方法中的this指向的就是init方法的实例，而不是jQuery.prototype这个原型对象了。 console.log($().version); // 返回undefined console.log($()._size()); // 0 console.log($().size()); // 抛出异常：Uncaught TypeError: $(...).size is not a function 下面，我们来看一下怎样解决现在面临的问题。 var $ = (jQuery = function () { return new jQuery.fn.init(); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function () { this.length = 0; this._size = function () { return this.length; }; return this; }, version: &quot;6.1.1&quot;, length: 1, size: function () { return this.length; }, }; // 将`jQuery`的原型对象覆盖掉init的原型对象。 jQuery.fn.init.prototype = jQuery.fn; console.log($().version); //6.1.1 console.log($()._size()); // 0 console.log($().size()); // 0 在上面的代码中，我们添加了一行代码： jQuery.fn.init.prototype = jQuery.fn; console.log($().version); 下面，要实现的是选择器功能 jQuery构造函数包括两个参数，分别是selector和context,selector表示的是选择器，context表示匹配的上下文，也就是可选择的访问，一般表示的是一个DOM元素。这里我们只考虑标签选择器。 &lt;script&gt; // 给构造函数传递selector,context两个参数 var $ = (jQuery = function (selector, context) { return new jQuery.fn.init(selector, context); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function (selector, context) { selector = selector || document; //初始化选择器，默认值为document context = context || document; // 初始化上下文对象，默认值为document if (selector.nodeType) { // 如果是DOM元素 // 把该DOM元素赋值给实例对象 this[0] = selector; this.length = 1; //表示包含了1个元素 this.context = selector; //重新设置上下文对象 return this; //返回当前实例 } if (typeof selector === &quot;string&quot;) { //如果选择器是一个字符串 var e = context.getElementsByTagName(selector); // 获取指定名称的元素 //通过for循环将所有元素存储到当前的实例中 for (var i = 0; i &lt; e.length; i++) { this[i] = e[i]; } this.length = e.length; //存储元素的个数 this.context = context; //保存上下文对象 return this; //返回当前的实例 } else { this.length = 0; this.context = context; return this; } // this.length = 0; // console.log(&quot;init==&quot;, this); // this._size = function () { // return this.length; // }; // return this; }, // version: &quot;6.1.1&quot;, // length: 1, // size: function () { // return this.length; // }, }; jQuery.fn.init.prototype = jQuery.fn; window.onload = function () { console.log($(&quot;div&quot;).length); }; // console.log($().version); // console.log($()._size()); // 0 // console.log($().size()); // 0 // var jq = new $(); // console.log(jq.version); // 6.1.1 // console.log(jq.size()); &lt;/script&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; 在上面的代码中，当页面加载完以后，这时会触发onload事件，在该事件对应的处理函数中，通过$(&quot;div&quot;),传递的是字符串， selector参数表示的就是div这个字符串，这里没有传递context参数，表示的就是document对象。 最后打印元素的个数。 在使用jQuery库的时候，我们经常可以看到如下的操作： $('div').html() 以上代码的含义就是直接在jQuery对象上调用html( )方法来操作jQuery包含所有的DOM元素。 html()方法的实现如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 给构造函数传递selector,context两个参数 var $ = (jQuery = function (selector, context) { return new jQuery.fn.init(selector, context); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function (selector, context) { selector = selector || document; //初始化选择器，默认值为document context = context || document; // 初始化上下文对象，默认值为document if (selector.nodeType) { // 如果是DOM元素 // 把该DOM元素赋值给实例对象 this[0] = selector; this.length = 1; //表示包含了1个元素 this.context = selector; //重新设置上下文对象 return this; //返回当前实例 } if (typeof selector === &quot;string&quot;) { //如果选择器是一个字符串 var e = context.getElementsByTagName(selector); // 获取指定名称的元素 //通过for循环将所有元素存储到当前的实例中 for (var i = 0; i &lt; e.length; i++) { this[i] = e[i]; } this.length = e.length; //存储元素的个数 this.context = context; //保存上下文对象 return this; //返回当前的实例 } else { this.length = 0; this.context = context; return this; } // this.length = 0; // console.log(&quot;init==&quot;, this); // this._size = function () { // return this.length; // }; // return this; }, html: function (val) { jQuery.each( this, function (val) { this.innerHTML = val; }, val ); }, // version: &quot;6.1.1&quot;, // length: 1, // size: function () { // return this.length; // }, }; jQuery.fn.init.prototype = jQuery.fn; //提供each扩展方法 jQuery.each = function (object, callback, args) { //通过for循环的方式来遍历jQuery对象中的每个DOM元素。 for (var i = 0; i &lt; object.length; i++) { // 在每个DOM元素上调用回调函数 callback.call(object[i], args); } return object; //返回jQuery对象。 }; window.onload = function () { // console.log($(&quot;div&quot;).length); $(&quot;div&quot;).html(&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;); }; // console.log($().version); // console.log($()._size()); // 0 // console.log($().size()); // 0 // var jq = new $(); // console.log(jq.version); // 6.1.1 // console.log(jq.size()); &lt;/script&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，首先添加了jQuery.each方法。 //提供each扩展方法 jQuery.each = function (object, callback, args) { //通过for循环的方式来遍历jQuery对象中的每个DOM元素。 for (var i = 0; i &lt; object.length; i++) { // 在每个DOM元素上调用回调函数 //这里的让回调函数中的this指向了dom元素。 callback.call(object[i], args); } return object; //返回jQuery对象。 }; 在上面的代码中，通过for循环遍历jQuery对象中的每个DOM元素。然后执行回调函数callback 在jQuery的原型对象上，添加html方法 html: function (val) { jQuery.each( this, //表示jQuery原型对象 function (val) { //this表示的是dom元素，这里是div元素 this.innerHTML = val; }, val //表示传递过来的`&lt;h2&gt;hello&lt;h2&gt;` ); }, 在html方法中完成对jQuery.each方法的调用。 window.onload的方法修改成如下的形式： window.onload = function () { // console.log($(&quot;div&quot;).length); $(&quot;div&quot;).html(&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;); }; **下面我们实现jQuery的扩展功能jQuery 提供了良好的扩展接口，方便用户自定义 jQuery 方法。根据设计习惯，如果为 jQuery 或者 jQuery.prototype 新增方法时，我们可以直接通过点语法来实现，例如上面我们扩展的html方法，或者在 jQuery.prototype 对象结构内增加。但是，如果分析 jQuery 源码，会发现它是通过 extend() 函数来实现功能扩展的。 通过extend()方法来实现扩展的好处是：方便用户快速的扩展jQuery功能，但不会破坏jQuery框架的结构。如果直接在jQuery源码中添加方法，这样就破坏了Jquery框架的结构，不方便后期的代码维护。 如果后期不需要某个功能，可以直接使用Jquery提供的方法删除，而不需要从源码中在对该功能进行删除。 extend() 函数的功能很简单，它只是把指定对象的方法复制给 jQuery 对象或者 jQuery.prototype。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 给构造函数传递selector,context两个参数 var $ = (jQuery = function (selector, context) { return new jQuery.fn.init(selector, context); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function (selector, context) { selector = selector || document; //初始化选择器，默认值为document context = context || document; // 初始化上下文对象，默认值为document if (selector.nodeType) { // 如果是DOM元素 // 把该DOM元素赋值给实例对象 this[0] = selector; this.length = 1; //表示包含了1个元素 this.context = selector; //重新设置上下文对象 return this; //返回当前实例 } if (typeof selector === &quot;string&quot;) { //如果选择器是一个字符串 var e = context.getElementsByTagName(selector); // 获取指定名称的元素 //通过for循环将所有元素存储到当前的实例中 for (var i = 0; i &lt; e.length; i++) { this[i] = e[i]; } this.length = e.length; //存储元素的个数 this.context = context; //保存上下文对象 return this; //返回当前的实例 } else { this.length = 0; this.context = context; return this; } // this.length = 0; // console.log(&quot;init==&quot;, this); // this._size = function () { // return this.length; // }; // return this; }, // html: function (val) { // jQuery.each( // this, // function (val) { // this.innerHTML = val; // }, // val // ); // }, // version: &quot;6.1.1&quot;, // length: 1, // size: function () { // return this.length; // }, }; jQuery.fn.init.prototype = jQuery.fn; //提供each扩展方法 jQuery.each = function (object, callback, args) { //通过for循环的方式来遍历jQuery对象中的每个DOM元素。 for (var i = 0; i &lt; object.length; i++) { // 在每个DOM元素上调用回调函数 callback.call(object[i], args); } return object; //返回jQuery对象。 }; jQuery.extend = jQuery.fn.extend = function (obj) { for (var prop in obj) { this[prop] = obj[prop]; } return this; }; jQuery.fn.extend({ html: function (val) { jQuery.each( this, function (val) { this.innerHTML = val; }, val ); }, }); window.onload = function () { // console.log($(&quot;div&quot;).length); $(&quot;div&quot;).html(&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;); }; // console.log($().version); // console.log($()._size()); // 0 // console.log($().size()); // 0 // var jq = new $(); // console.log(jq.version); // 6.1.1 // console.log(jq.size()); &lt;/script&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们为jQuery的原型对象添加了extend方法 jQuery.extend = jQuery.fn.extend = function (obj) { for (var prop in obj) { this[prop] = obj[prop]; } return this; }; 把obj对象中的属性添加到jQuery原型对象上。 下面调用extend方法，同时设置html属性 jQuery.fn.extend({ html: function (val) { jQuery.each( this, function (val) { this.innerHTML = val; }, val ); }, }); 这样jQuery原型对象上就有了html方法。 而把原来的html方法的代码注释掉。 刷新浏览器，查看对应的效果。 参数传递 我们在使用jquery的方法的时候，需要进行参数的传递，而且一般都要求传递的参数都是对象。 使用对象作为参数进行传递的好处，就是方便参数的管理，例如参数个数不受限制。 如果使用对象作为参数进行传递，需要解决的问题：如何解决并提取参数，如何处理默认值等问题。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 给构造函数传递selector,context两个参数 var $ = (jQuery = function (selector, context) { return new jQuery.fn.init(selector, context); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function (selector, context) { selector = selector || document; //初始化选择器，默认值为document context = context || document; // 初始化上下文对象，默认值为document if (selector.nodeType) { // 如果是DOM元素 // 把该DOM元素赋值给实例对象 this[0] = selector; this.length = 1; //表示包含了1个元素 this.context = selector; //重新设置上下文对象 return this; //返回当前实例 } if (typeof selector === &quot;string&quot;) { //如果选择器是一个字符串 var e = context.getElementsByTagName(selector); // 获取指定名称的元素 //通过for循环将所有元素存储到当前的实例中 for (var i = 0; i &lt; e.length; i++) { this[i] = e[i]; } this.length = e.length; //存储元素的个数 this.context = context; //保存上下文对象 return this; //返回当前的实例 } else { this.length = 0; this.context = context; return this; } // this.length = 0; // console.log(&quot;init==&quot;, this); // this._size = function () { // return this.length; // }; // return this; }, // html: function (val) { // jQuery.each( // this, // function (val) { // this.innerHTML = val; // }, // val // ); // }, // version: &quot;6.1.1&quot;, // length: 1, // size: function () { // return this.length; // }, }; jQuery.fn.init.prototype = jQuery.fn; //提供each扩展方法 jQuery.each = function (object, callback, args) { console.log(&quot;args=&quot;, args); //通过for循环的方式来遍历jQuery对象中的每个DOM元素。 for (var i = 0; i &lt; object.length; i++) { // 在每个DOM元素上调用回调函数 callback.call(object[i], args); } return object; //返回jQuery对象。 }; // jQuery.extend = jQuery.fn.extend = function (obj) { // for (var prop in obj) { // this[prop] = obj[prop]; // } // return this; // }; jQuery.extend = jQuery.fn.extend = function () { var destination = arguments[0], source = arguments[1]; //如果存在两个参数，并且都是对象 if (typeof destination === &quot;object&quot; &amp;&amp; typeof source === &quot;object&quot;) { //把第二个对象合并到第一个参数对象中，并返回合并后的对象 for (var property in source) { destination[property] = source[property]; } return destination; } else { for (var prop in destination) { this[prop] = destination[prop]; } return this; } }; jQuery.fn.extend({ html: function (val) { jQuery.each( this, function (val) { this.innerHTML = val; }, val ); }, }); jQuery.fn.extend({ fontStyle: function (obj) { var defaults = { color: &quot;#ccc&quot;, size: &quot;16px&quot;, }; //如果有参数，会覆盖掉默认的参数 defaults = jQuery.extend(defaults, obj || {}); //为每个DOM元素执设置样式. jQuery.each(this, function () { this.style.color = defaults.color; this.style.fontSize = defaults.size; }); }, }); window.onload = function () { // console.log($(&quot;div&quot;).length); $(&quot;div&quot;).html(&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;); $(&quot;p&quot;).fontStyle({ color: &quot;red&quot;, size: &quot;30px&quot;, }); }; // console.log($().version); // console.log($()._size()); // 0 // console.log($().size()); // 0 // var jq = new $(); // console.log(jq.version); // 6.1.1 // console.log(jq.size()); &lt;/script&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;学习前端&lt;/p&gt; &lt;p&gt;学习前端&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，重新改造extend方法。 jQuery.extend = jQuery.fn.extend = function () { var destination = arguments[0], source = arguments[1]; //如果存在两个参数，并且都是对象 if (typeof destination === &quot;object&quot; &amp;&amp; typeof source === &quot;object&quot;) { //把第二个对象合并到第一个参数对象中，并返回合并后的对象 for (var property in source) { destination[property] = source[property]; } return destination; } else { for (var prop in destination) { this[prop] = destination[prop]; } return this; } }; 在extend方法中，首先获取两个参数，然后判断这两个参数是否都是对象，如果都是对象，把第二个参数对象合并到第一个参数对象中，并返回合并后的对象。 否则，将第一个参数对象复制到jquery的原型对象上。 jQuery.fn.extend({ fontStyle: function (obj) { var defaults = { color: &quot;#ccc&quot;, size: &quot;16px&quot;, }; //如果有参数，会覆盖掉默认的参数 defaults = jQuery.extend(defaults, obj || {}); // console.log(&quot;this==&quot;, this);//init {0: p, 1: p, length: 2, context: document} //为每个DOM元素执设置样式. jQuery.each(this, function () { //这里的this表示的是p标签，因为在each方法内部通过call改变了this指向，让this指向了每个遍历得到的p元素 this.style.color = defaults.color; this.style.fontSize = defaults.size; }); }, }); 在上面的代码中， 调用了extend方法，然后传递了fontStyle,这个fontStyle可以用来设置文本的颜色与字体大小。 当我们第一次调用extend方法的时候，只是传递了fontStyle这个对象，这时，会将该对象添加到jQuery原型对象上。 window.onload = function () { // console.log($(&quot;div&quot;).length); $(&quot;div&quot;).html(&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;); $(&quot;p&quot;).fontStyle({ color: &quot;red&quot;, size: &quot;30px&quot;, }); }; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;学习前端&lt;/p&gt; &lt;p&gt;学习前端&lt;/p&gt; 在onload事件中，调用fontStyle方法，并且传递了一个对象，这时在fontStyle方法的内部，首先会创建一个defaults默认的对象，然后再次调用extend方法，将传递的对象合并到默认对象上，当然完成了值的覆盖。 下面调用each方法，在each方法中遍历每个元素，执行回调函数，并且改变this的指向。 封装成独立的命名空间 以上已经实现了一个简单的jQuery库， 但是这里还有一个问题，需要解决：当编写了大量的javascript代码以后，引入该jquery库就很容易出现代码冲突的问题，所以这里需要将jquery库的代码与其他的javascript代码进行隔离，这里使用闭包。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; (function (window) { // 给构造函数传递selector,context两个参数 var $ = (jQuery = function (selector, context) { return new jQuery.fn.init(selector, context); //调用原型中的`init方法` }); jQuery.fn = jQuery.prototype = { init: function (selector, context) { selector = selector || document; //初始化选择器，默认值为document context = context || document; // 初始化上下文对象，默认值为document if (selector.nodeType) { // 如果是DOM元素 // 把该DOM元素赋值给实例对象 this[0] = selector; this.length = 1; //表示包含了1个元素 this.context = selector; //重新设置上下文对象 return this; //返回当前实例 } if (typeof selector === &quot;string&quot;) { //如果选择器是一个字符串 var e = context.getElementsByTagName(selector); // 获取指定名称的元素 //通过for循环将所有元素存储到当前的实例中 for (var i = 0; i &lt; e.length; i++) { this[i] = e[i]; } this.length = e.length; //存储元素的个数 this.context = context; //保存上下文对象 return this; //返回当前的实例 } else { this.length = 0; this.context = context; return this; } // this.length = 0; // console.log(&quot;init==&quot;, this); // this._size = function () { // return this.length; // }; // return this; }, // html: function (val) { // jQuery.each( // this, // function (val) { // this.innerHTML = val; // }, // val // ); // }, // version: &quot;6.1.1&quot;, // length: 1, // size: function () { // return this.length; // }, }; jQuery.fn.init.prototype = jQuery.fn; //提供each扩展方法 jQuery.each = function (object, callback, args) { //通过for循环的方式来遍历jQuery对象中的每个DOM元素。 for (var i = 0; i &lt; object.length; i++) { // 在每个DOM元素上调用回调函数 callback.call(object[i], args); } return object; //返回jQuery对象。 }; // jQuery.extend = jQuery.fn.extend = function (obj) { // for (var prop in obj) { // this[prop] = obj[prop]; // } // return this; // }; jQuery.extend = jQuery.fn.extend = function () { var destination = arguments[0], source = arguments[1]; //如果存在两个参数，并且都是对象 if (typeof destination === &quot;object&quot; &amp;&amp; typeof source === &quot;object&quot;) { //把第二个对象合并到第一个参数对象中，并返回合并后的对象 for (var property in source) { destination[property] = source[property]; } return destination; } else { for (var prop in destination) { this[prop] = destination[prop]; } return this; } }; // 开发jqueyr window.jQuery = window.$ = jQuery; })(window); jQuery.fn.extend({ html: function (val) { jQuery.each( this, function (val) { this.innerHTML = val; }, val ); }, }); jQuery.fn.extend({ fontStyle: function (obj) { var defaults = { color: &quot;#ccc&quot;, size: &quot;16px&quot;, }; //如果有参数，会覆盖掉默认的参数 defaults = jQuery.extend(defaults, obj || {}); // console.log(&quot;this==&quot;, this);//init {0: p, 1: p, length: 2, context: document} //为每个DOM元素执设置样式. jQuery.each(this, function () { //这里的this表示的是p标签，因为在each方法内部通过call改变了this指向，让this指向了每个遍历得到的p元素 this.style.color = defaults.color; this.style.fontSize = defaults.size; }); }, }); window.onload = function () { // console.log($(&quot;div&quot;).length); $(&quot;div&quot;).html(&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;); $(&quot;p&quot;).fontStyle({ color: &quot;red&quot;, size: &quot;30px&quot;, }); }; // console.log($().version); // console.log($()._size()); // 0 // console.log($().size()); // 0 // var jq = new $(); // console.log(jq.version); // 6.1.1 // console.log(jq.size()); &lt;/script&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;学习前端&lt;/p&gt; &lt;p&gt;学习前端&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，将jQuery库放在匿名函数中，然后进行自调用，并且传入window对象。 在上面所添加的代码中还要注意如下语句： window.jQuery = window.$ = jQuery; 以上语句的作用：把闭包中的私有变量jQuery传递给window对象的jQuery属性。这样就可以在全局作用域中通过jQuery变量来访问闭包体内的jQuery框架了。 以上就是我们模拟的jQuery库。 五、DOM与事件1、选择器getElementById():通过id来查找对应的元素。 getElementsByClassName():通过类名来查找对应的元素，返回的是一个HTMLCollection对象。 getElementsByName():通过元素的name属性查找对应的元素，返回的是NodeList对象，它是一个类似于数组的结构。 getElementsByTagName(): 通过标签的名称来查找对应的元素，返回的是HTMLCollection对象。 querySelector：该选择器返回的是在基准元素下，选择器匹配到的元素集合中的第一个元素。该选择器的参数接收的是一个css选择 &lt;body&gt; &lt;div&gt; &lt;h4&gt;标题内容&lt;/h4&gt; &lt;span&gt;span标签内容&lt;/span&gt; &lt;p&gt; 段落内容 &lt;span&gt;段落中的第一个span标签&lt;/span&gt;&lt;br /&gt; &lt;span&gt;段落中的第二个span标签&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; console.log(document.querySelector(&quot;p span&quot;).innerHTML);// 获取p标签中第一个span标签中的内容，所以输出结果为:段落中的第一个span标签 console.log(document.querySelector(&quot;h4,span&quot;).innerHTML);//获取第一个h4或者是span元素的内容：所以输出结果为：标题内容 var ele = document.querySelector(&quot;p&quot;); console.log(ele.querySelector(&quot;div span&quot;).innerHTML);//段落中的第一个span标签。 // 首先先找到`p`元素，然后看一下p元素下面有没有div,我们发现没有，但是依然能够匹配到span元素。 //原因是：在匹配的过程中会优先找出最外层div元素下的span元素的集合，然后在判断span元素是否属于p元素的子元素，最后返回 //第一个匹配到的span元素的值。 &lt;/script&gt; 下面，把HTML文档的结构修改成如下的形式： &lt;div&gt; &lt;h4&gt;标题内容&lt;/h4&gt; &lt;span&gt;span标签内容&lt;/span&gt; &lt;!--这里增加了一个p标签--&gt; &lt;p&gt;第一个段落&lt;/p&gt; &lt;p&gt; 段落内容 &lt;span&gt;段落中的第一个span标签&lt;/span&gt;&lt;br /&gt; &lt;span&gt;段落中的第二个span标签&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; 执行如下代码会出现异常： var ele = document.querySelector(&quot;p&quot;); console.log(ele.querySelector(&quot;div span&quot;).innerHTML);//Cannot read property 'innerHTML' of null 原因：会找到第一个p元素,然后看一下p标签中是否有div,发现没有，但是会找出最外层div下的所有span元素的集合，看一下span元素是否属于p元素，而第一个p元素中没有span元素，所以抛出异常。 querySelectorAll()选择器： querySelectorAll选择器与querySelector选择器的区别是：querySelectAll选择器会获取到基准元素下匹配到所有子元素的集合。返回的是一个NodeList集合。 &lt;div&gt; &lt;h4&gt;标题内容&lt;/h4&gt; &lt;span&gt;span标签内容&lt;/span&gt; &lt;p&gt; 段落内容 &lt;span&gt;段落中的第一个span标签&lt;/span&gt;&lt;br /&gt; &lt;span&gt;段落中的第二个span标签&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; console.log(document.querySelectorAll(&quot;span&quot;));//返回所有的span标签。 &lt;/script&gt; 下面，再来看一段代码： &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;foo&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取container下的所有div元素。 var div1 = document.querySelectorAll(&quot;#container div&quot;); console.log(div1);// NodeList(3) [div.bar, div.foo, div.inner] &lt;/script&gt; 2、HTMLCollection对象与NodeList对象区别在介绍前面的选择器的时候，它们返回的值有些是HTMLCollection对象，有些是NodeList对象，它们有什么区别？ HTMLCollection对象具有1ength属性，返回集合的长度，可以通过item()和namedItem()函数来访问特定的元素。 item()函数：通过序号索引值来获取特定的某个节点，超过索引则返回null. &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;foo&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var main = document.getElementById(&quot;container&quot;).children; console.log(main); //HTMLCollection console.log(main.item(0)); //输出:&lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; console.log(main.item(1)); // 输出:foo元素 &lt;/script&gt; namedItem()函数：该函数用来返回一个节点，首先通过id属性去匹配，然后如果没有匹配到则使用name属性匹配，如果还没有匹配到则返回null. 当出现重复的id或者name属性时，只返回匹配到的第一个值。 &lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/form&gt; &lt;script&gt; var form1 = document.getElementById(&quot;form1&quot;).children; console.log(form1.namedItem(&quot;userPwd&quot;));// &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/script&gt; NodeList对象也具有length属性，返回集合的长度，同样也有item函数，也是通过索引定位子元素的位置。但是NodeList对象没有namedItem方法。 HTMLCollection对象与NodeList对象都是类似数组的结构，如果想调用数组中的方法，需要通过call()函数或者是apply()函数，转换为真正的数组后，可以使用数组中的函数。 同时，当我们对DOM树新增或者是删除一个节点的时候，都会立即的放映在HTMLCollection对象与NodeList对象中。 &lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/form&gt; &lt;script&gt; //获取HTMLCollection集合 var form1Children = document.getElementById(&quot;form1&quot;).children; // 获取form元素 var form1 = document.getElementById(&quot;form1&quot;); console.log(form1Children.length); // 2 HTMLCollection中有两个子元素 var input = document.createElement(&quot;input&quot;); //创建input元素 form1.appendChild(input); // 把创建的input元素添加到form元素中 console.log(form1Children.length); // 3 可以看到HTMLCollection立即受到了影响 最后，总结一下HTMLCollection对象与NodeList对象的相同点与不同点 相同点： 第一：都是类似数组的结构，有length属性，可以通过call()函数或者是apply()函数转换成数组，使用数组中的函数。 第二：都用item函数，通过索引值获取相应的元素。 第三：都是实时的，当在DOM树上添加元素或者是删除元素，都会立即反应到HTMLCollection对象和NodeList对象上。 不同点： 第一：HTMLCollection对象中，有namedItem()函数，而NodeList对象中没有. 第二：NodeList对象中存储的是元素节点的集合，包括元素，以及节点，例如text文本节点，而HTMLCollection对象中只包含了元素的集合。 &lt;form id=&quot;form1&quot;&gt; 用户名&lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;br /&gt; 用户密码&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/form&gt; &lt;script&gt; //获取HTMLCollection集合 var form1Children = document.getElementById(&quot;form1&quot;).children; console.log(form1Children); //获取NodeList对象 var formNodes = document.getElementById(&quot;form1&quot;).childNodes; console.log(formNodes); &lt;/script&gt; 通过查看浏览器控制台输出的结果，可以看出HTMLCollection对象与NodeList对象的区别。 3、常见的DOM操作有哪些？添加节点 &lt;form id=&quot;form1&quot;&gt; 用户名&lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;br /&gt; 用户密码&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/form&gt; &lt;script&gt; var form1 = document.getElementById(&quot;form1&quot;); //创建一个input元素 var newInput = document.createElement(&quot;input&quot;); //创建属性 var newAttr = document.createAttribute(&quot;type&quot;); newAttr.value = &quot;password&quot;; //将属性绑定到元素上 newInput.setAttributeNode(newAttr); //创建一个文本节点 var newTextNode = document.createTextNode(&quot;用户密码&quot;); form1.appendChild(newTextNode); //添加文本节点 form1.appendChild(newInput); &lt;/script&gt; 删除节点 &lt;form id=&quot;form1&quot;&gt; 用户名&lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;br /&gt; 用户密码&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/form&gt; &lt;script&gt; var form1 = document.getElementById(&quot;form1&quot;); var nodeChilds = form1.childNodes; console.log(nodeChilds); form1.removeChild(nodeChilds[0]); form1.removeChild(nodeChilds[0]); &lt;/script&gt; 在上面的代码中，我们想将表单中的用户名这一项内容删除掉。 首先获取form表单，然后在获取对应的子元素。 通过执行removeChild方法删除第一个元素，而第一个元素是用户名这个文本字符串， 下面还要删除文本框，所以再次调用了removeChild函数，注意由于前面已经删除了用户名这个文本元素了，所以文本框成为了第一个元素，所以这里写到索引值也是0. 删除文本框的id属性 &lt;form id=&quot;form1&quot;&gt; 用户名&lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;br /&gt; 用户密码&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;userPwd&quot; /&gt; &lt;/form&gt; &lt;script&gt; var input = document.querySelector(&quot;#userName&quot;); input.removeAttribute(&quot;id&quot;); &lt;/script&gt; 修改节点 修改元素节点 修改元素的节点的操作，一般是直接用新的节点替换旧的节点。关于节点的替换可以使用，replaceChild函数来实现，该函数的调用是通过父元素来调用的，例如：把div1中的内容替换掉，这里就需要通过container.replaceChild方法来完成，replaceChild方法需要两个参数，第一个参数表示的是新元素，第二个参数表示的是旧元素。 &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt;hello&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var container = document.getElementById(&quot;container&quot;); //获取父元素container var div1 = document.getElementById(&quot;div1&quot;); //获取子元素 var newDiv = document.createElement(&quot;div&quot;); // 创建一个新的div元素 var newText = document.createTextNode(&quot;nihao&quot;); //创建一个文本内容 newDiv.appendChild(newText); //把创建的文本内容添加到新的div中 container.replaceChild(newDiv, div1); //用新的div替换旧的div,完成节点的修改操作。 &lt;/script&gt; 修改属性节点 修改属性的节点，我们可以通过setAttribute()函数来完成，如果想获取属性节点可以通过getAttribute()函数来完成。 &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot; style=&quot;color: red&quot;&gt;hello&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&quot;div1&quot;); div1.setAttribute(&quot;style&quot;, &quot;color:blue&quot;); //设置style属性 console.log(div1.getAttribute(&quot;style&quot;)); // 获取style属性的值 &lt;/script&gt; 修改属性节点除了通过setAttribute()方法完成以外，还可以通过属性名直接进行修改 &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot; style=&quot;color: red&quot;&gt;hello&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&quot;div1&quot;); div1.style.color = &quot;blue&quot;; &lt;/script&gt; 但是通过这种方式进行修改，还需要注意一个问题：直接修改的属性名与元素节点中的属性名不一定是一致的。例如class这个属性，在javascript中是关键字，不能直接作为属性使用，这时需要通过className来完成。 &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot; style=&quot;color: red&quot;&gt;hello&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;foo&quot;&gt;前端学习&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var div2 = document.getElementById(&quot;div2&quot;); div2.className = &quot;bar&quot;; //注意这里使用的是className &lt;/script&gt; 通过查看浏览器控制台，可以看到对应的样式发生了修改。 修改文本节点 文本节点的修改，可以通过innerHTML属性来完成。 &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot; style=&quot;color: red&quot;&gt;hello&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;foo&quot;&gt;前端学习&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var div2 = document.getElementById(&quot;div2&quot;); div2.innerHTML = &quot;Vue 学习&quot;; &lt;/script?&gt; 4、DOM性能问题Dom操作非常消耗性能，应该尽量避免频繁的操作DOM. 导致浏览器重绘，重新渲染，比较消耗cpu资源，比较消耗性能。 提升性能的方案： 第一：对DOM查询操作进行缓存 第二：将频繁操作修改为一次性操作 首先看第一种情况： 这里需要对页面中所有p标签内文字调整大小(单击按钮完成) //不缓存的结果 for (let i = 0; i &lt; document.getElementsByTagName(&quot;p&quot;).length; i++) { //每次循环，都会计算lenght,频繁进行DOM查询 } const pList = document.getElementsByTagName(&quot;p&quot;); const length = pList.length; for (let i = 0; i &lt; length; i++) { //缓存length,只进行一次DOM查询 } 下面看一下第二种情况： 需求：页面中有一个ul列表，需要单击按钮一次性插入10个或者100个li? 传统的做法： &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt; const listNode = document.getElementById(&quot;list&quot;); for (let i = 0; i &lt; 10; i++) { const li = document.createElement(&quot;li&quot;); li.innerHTML = `item${i}`; list.appendChild(li); } 执行上面的代码，可以实现对应的需求，但是问题是上面的操作是频繁操作dom，性能比较低。 const listNode = document.getElementById(&quot;list&quot;); //创建一个文档片段，文档片段存在于内存中，并不在DOM树中，所以此时还没有插入到DOM中 //也就是先将dom插入到临时区域中 const frag = document.createDocumentFragment(); //执行插入 for (let i = 0; i &lt; 10; i++) { const li = document.createElement(&quot;li&quot;); li.innerHTML = `item${i}`; frag.appendChild(li); } //都完成后，再插入到DOM树中 listNode.appendChild(frag); 5、什么是事件传播在浏览器中，JavaScript和HTML之间的交互是通过事件实现的，常用的事件包括了鼠标点击的事件，鼠标移动事件等等。 当事件发生以后，会触发绑定在元素上的事件处理程序，执行相应的操作。 问题是当事件发生后，事件是怎样传播的呢？ 事件发生后会在目标节点和根节点之间按照特定的顺序进行传播，路径经过的节点都会接收到事件。 这里的特定顺序是怎样的顺序呢？ 第一种：事件传递的顺序是先触发最外层的元素，然后依次向内传播，这样的传递顺序我们称之为事件的捕获阶段。 第二种：事件传递的顺序是先触发最内层的元素，然后依次向外进行传播，这样的传递顺序我们称之为事件冒泡阶段。 当然，一个完整的事件传播包含了三个阶段 首先就是事件的捕获阶段 然后是事件的目标阶段，目标阶段指的就是事件已经到达目标元素。 最后是事件的冒泡阶段 以上就是关于事件传播的描述 6、什么是事件的捕获关于事件捕获，在上一小节，我们已经介绍过：事件的传递是从最外层开始，依次向内传播，在捕获阶段，事件从window开始，一直到触发事件的元素。 window----&gt; document----&gt; html----&gt; body ----&gt;目标元素 如下代码所示： &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; var table = document.querySelector(&quot;table&quot;); var tbody = document.querySelector(&quot;tbody&quot;); var tr = document.querySelector(&quot;tr&quot;); var td = document.querySelector(&quot;td&quot;); table.addEventListener( &quot;click&quot;, function () { console.log(&quot;table&quot;); }, true ); tbody.addEventListener( &quot;click&quot;, function () { console.log(&quot;tbody&quot;); }, true ); tr.addEventListener( &quot;click&quot;, function () { console.log(&quot;tr&quot;); }, true ); td.addEventListener( &quot;click&quot;, function () { console.log(&quot;td&quot;); }, true ); &lt;/script&gt; &lt;/body&gt; 在上面的代码中，有一个表格，给表格中的每个元素通过addEventListener方法绑定了单击事件，同时该方法的第三个参数，设置为了true,这样就表明事件将在捕获阶段发生。 所以当我们单击td单元格的时候，事件的执行结果是：table,tbody,tr,td.也就是说事件从table开始，依次向下传播。这个传播的过程就是事件捕获。 7、什么是事件冒泡关于事件的冒泡，在前面也已经提到过：事件传递的顺序是先触发最内层的元素，然后依次向外进行传播，这样的传递顺序我们称之为事件冒泡阶段。 如下代码所示： &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; var table = document.querySelector(&quot;table&quot;); var tbody = document.querySelector(&quot;tbody&quot;); var tr = document.querySelector(&quot;tr&quot;); var td = document.querySelector(&quot;td&quot;); table.addEventListener(&quot;click&quot;, function () { console.log(&quot;table&quot;); }); tbody.addEventListener(&quot;click&quot;, function () { console.log(&quot;tbody&quot;); }); tr.addEventListener(&quot;click&quot;, function () { console.log(&quot;tr&quot;); }); td.addEventListener(&quot;click&quot;, function () { console.log(&quot;td&quot;); }); &lt;/script&gt; &lt;/body&gt; 上面的代码，我们将addEventListener方法的第三个参数true去掉了，这时就有事件的捕获变成了事件的冒泡。默认值为(false). 但单击单元格的时候，执行的结果为：td,tr,tbody,table, 这个过程就是事件的冒泡。 8、阻止事件冒泡现在，我们已经了解了事件冒泡的过程，但是在很多的情况下，我们需要阻止事件冒泡的发生。 例如：在上一小节的案例中，当我们单击了单元格后，不仅触发单元格元素的事件，同时也会触发其它元素的事件，而这里我们只希望触发单元格的事件。所以这里需要阻止事件的冒泡。 阻止事件的冒泡需要使用：event.stopPropagation()函数 如下案例： &lt;script&gt; var table = document.querySelector(&quot;table&quot;); var tbody = document.querySelector(&quot;tbody&quot;); var tr = document.querySelector(&quot;tr&quot;); var td = document.querySelector(&quot;td&quot;); table.addEventListener(&quot;click&quot;, function () { console.log(&quot;table&quot;); }); tbody.addEventListener(&quot;click&quot;, function () { console.log(&quot;tbody&quot;); }); tr.addEventListener(&quot;click&quot;, function () { console.log(&quot;tr&quot;); }); td.addEventListener(&quot;click&quot;, function (event) { //阻止了事件的冒泡操作 event.stopPropagation(); console.log(&quot;td&quot;); }); &lt;/script&gt; 在单元格的事件处理函数中，通过event.stopPropagation()方法阻止了事件的冒泡。 与stopPropagation()函数相对的还有一个stopImmediatePropagation函数，它们两者之间有什么区别呢？ stopPropagation()：函数会阻止事件冒泡，其它事件处理程序仍然可以调用 stopImmediatePropagation函数不仅可以阻止事件冒泡，也会阻止其它事件处理程序的调用。 如下代码所示： &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; var table = document.querySelector(&quot;table&quot;); var tbody = document.querySelector(&quot;tbody&quot;); var tr = document.querySelector(&quot;tr&quot;); var td = document.querySelector(&quot;td&quot;); table.addEventListener(&quot;click&quot;, function () { console.log(&quot;table&quot;); }); tbody.addEventListener(&quot;click&quot;, function () { console.log(&quot;tbody&quot;); }); tr.addEventListener(&quot;click&quot;, function () { console.log(&quot;tr&quot;); }); //单元格第一个单击事件 td.addEventListener(&quot;click&quot;, function (event) { console.log(&quot;td1&quot;); }); //单元格第二个单击事件 td.addEventListener(&quot;click&quot;, function (event) { //阻止了事件的冒泡操作 // event.stopImmediatePropagation(); event.stopPropagation(); console.log(&quot;td2&quot;); }); // 单元格第三个单击事件 td.addEventListener(&quot;click&quot;, function (event) { console.log(&quot;td3&quot;); }); &lt;/script&gt; &lt;/body&gt; 在上面的代码中，给单元格添加了三个单击的事件，同时第二个单击事件使用了stopPropagation方法来阻止冒泡行为。 执行结果如下：td1,td2,td3 通过执行结果，可以看到单元格的三个单击事件全部触发，并且阻止了冒泡的行为。 如果使用stopImmediatePropagation方法，执行结果为：td1,td2 通过执行的结果可以看到，阻止了冒泡的行为，但是没有触发单元格的第三个单击的事件，也就是说会阻止其它事件的执行。 9、事件冒泡与事件捕获问题下面我们来看一段代码： &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; var table = document.querySelector(&quot;table&quot;); var tbody = document.querySelector(&quot;tbody&quot;); var tr = document.querySelector(&quot;tr&quot;); var td = document.querySelector(&quot;td&quot;); //事件捕获 table.addEventListener( &quot;click&quot;, function () { console.log(&quot;table&quot;); }, true ); //事件冒泡 tbody.addEventListener(&quot;click&quot;, function () { console.log(&quot;tbody&quot;); }); //事件捕获 tr.addEventListener( &quot;click&quot;, function () { console.log(&quot;tr&quot;); }, true ); //事件冒泡 td.addEventListener(&quot;click&quot;, function (event) { console.log(&quot;td&quot;); }); &lt;/script&gt; &lt;/body&gt; 在上面的代码中，既有事件捕获又有事件冒泡，那么执行的结果是怎样的呢？ 当单击td单元格后 执行结果：table,tr,td,tbody 分析：前面我们讲解过，事件传播的循序是：先事件捕获阶段，然后事件的目标阶段，最后是事件冒泡阶段 所以说，在一个程序中有事件的捕获阶段，又有事件的冒泡阶段，会优先执行捕获阶段的事件。 所以上面代码整个执行的流程： 先执行table这个捕获阶段，输出table这个字符串 下面执行tbody，但是tbody绑定的是冒泡类的事件，所以不执行，跳过。 下面是tr,而tr是捕获类型的事件，所以会执行，输出字符串tr 下面是td,由于我们单击的是td元素，所以该元素就是事件目标元素，则会执行，输出td字符串。 当单击了td元素以后，就开始进入了事件冒泡阶段。这时会冒泡到tr元素，但是tr元素绑定的是捕获阶段的事件，所以不执行，直接跳过，下面继续冒泡到了tbody元素，该元素绑定的是冒泡类型的事件，所以执行，输出字符串tbody. 下面继续冒泡，执行到table元素，该原生是捕获类型的事件，所以直接跳过，没有输出。 10、Event对象使用在JavaScrip中，每触发一个事件，就会产生一个Event对象，在该对象中包含了所有与事件相关的内容，包括事件的元素，事件类型等。 当给某个元素绑定了事件处理程序后，就可以获取到Event对象，但是在不同的浏览器下，Event对象的实现还是有一定的差异的。 关于获取Event对象的方式有两种： 第一种：在事件的处理程序中，可以通过参数来获取Event对象。 第二种：在事件的处理程序中，可以通过window.event属性获取Event对象。 具体的示例代码如下： &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;单击&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&quot;btn&quot;); btn.addEventListener(&quot;click&quot;, function (event) { //通过参数获取Event对象 console.log(&quot;event=&quot;, event); //通过window.event的方式来获取Event对象 var windEvent = window.event; console.log(&quot;windEvent=&quot;, windEvent); //判断两种方式是否相等 console.log(event === windEvent); }); &lt;/script&gt; &lt;/body&gt; 在谷歌浏览器中，测试上面的代码，可以发现两种获取Event对象的方式是相等的。 但是注意，在其它的浏览中进行测试可能会出现不相等的情况，也就是有的浏览器会出现不支持window.event这种方式来获取Event对象，这里可以自行进行测试。 为了能够在获取事件对象的时候，支持不同的浏览器，我们可以做兼容性的处理。 &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;单击&lt;/button&gt; &lt;script&gt; var eventFn = { event: function (e) { return e || window.event; }, }; var btn = document.getElementById(&quot;btn&quot;); btn.addEventListener(&quot;click&quot;, function (event) { //通过参数获取Event对象 console.log(&quot;event=&quot;, eventFn.event(event)); //通过window.event的方式来获取Event对象 var windEvent = eventFn.event(window.event); console.log(&quot;windEvent=&quot;, windEvent); //判断两种方式是否相等 console.log(event === windEvent); }); &lt;/script&gt; 在上面的代码中定义了eventFn对象，在该对象中有一个属性event,在该属性中，判断返回Eevent对象的方式。 在对应的事件处理函数中，可以调用eventFn对象中的event方法来获取Event对象。 获取事件的目标元素 在事件的处理程序中，我们可能需要获取 事件的目标元素。 在IE浏览器中，可以使用event对象中的srcElement属性来获取事件的目标元素，在非IE浏览器中可以通过event对象的target属性来获取事件的目标元素，当然在有的非IE浏览器下也支持event对象中的srcElement属性，目的是为了保持与ie保持一致，但是要注意的是并不是所有的非IE浏览器都支持srcElement属性。 &lt;script&gt; var eventFn = { event: function (e) { return e || window.event; }, }; var btn = document.getElementById(&quot;btn&quot;); btn.addEventListener(&quot;click&quot;, function (event) { var event = eventFn.event(event); console.log(&quot;target=&quot;, event.target); console.log(&quot;srcElement=&quot;, event.srcElement); }); &lt;/script&gt; 在谷歌浏览器中进行测试，都可以获取target属性和srcElement属性的值。 关于其它浏览器的情况，可以自行测试。 当然为了能够兼容其它的浏览器，可以做一下兼容的处理。 var eventFn = { event: function (e) { return e || window.event; }, target: function (e) { return e.target || e.srcElement; }, }; var btn = document.getElementById(&quot;btn&quot;); btn.addEventListener(&quot;click&quot;, function (event) { var event = eventFn.event(event); console.log(&quot;target=&quot;, eventFn.target(event)); console.log(&quot;srcElement=&quot;, eventFn.target(event)); }); 这里在eventFn对象中封装了一个target属性。 阻止默认行为 &lt;a href=&quot;https://www.baidu.com&quot; id=&quot;a1&quot;&gt;链接&lt;/a&gt; &lt;script&gt; var a1 = document.getElementById(&quot;a1&quot;); a1.addEventListener(&quot;click&quot;, function (event) { event.preventDefault(); //阻止默认行为 alert(&quot;你点击了链接&quot;); }); &lt;/script&gt; 关于Event对象中的其他内容，可以参考文档。 11、介绍一下三种事件模型关于JavaScript的事件模型有三类，分别是DOM0，DOM2,DOM3 DOM0事件模型 DOM0的事件模型指的是：将一个函数赋值给一个事件处理属性。 如下代码： var btn=document.getElementById('btn') btn.onclick=function(){} 或者也可以采用如下的方式： &lt;button onclick=&quot;fn()&quot;&gt; 单击 &lt;/button&gt; &lt;script&gt; function fn(){ console.log('hello') } &lt;/script&gt; 需要注意的是：DOM0事件模型的处理程序只支持冒泡阶段。 DOM0事件模型的优点与缺点： 优点：实现起来非常简单，并且可以跨浏览器。 缺点：一个事件处理程序只能绑定一个函数。 &lt;body&gt; &lt;button id=&quot;btn&quot; onclick=&quot;btnClick()&quot;&gt;单击按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function () { console.log(&quot;hello&quot;); }; function btnClick() { console.log(&quot;123&quot;); } &lt;/script&gt; &lt;/body&gt; 在上面的代码中，我们给按钮使用两种方法绑定了事件处理程序，但是DOM0这种事件模型只能绑定一个函数，并且在JavaScript中绑定事件处理程序的优先级高于在HTML元素中定义的事件处理程序，所以打印结果为hello. 如果删除元素绑定的事件，只需要将对应的事件处理程序设置为null即可 btn.onclick=null DOM2事件模型 针对DOM2事件模型不同的浏览器厂商制定了不同的的实现方式，主要分为IE浏览器和非IE浏览器 在IE10及以下版本中只支持事件的冒泡，在IE11中同时支持事件的捕获与事件冒泡。在IE10及以下版本中，可以通过attachEvent函数来添加事件处理程序，通过detachEvent函数删除事件处理程序。 element.attachEvent('on'+ eventName,handler) // 添加事件处理程序 element.detachEvent('on'+ eventName,handler) // 删除事件处理程序 在IE11和非IE浏览器中，同时支持事件捕获和事件冒泡两个阶段，可以通过addEventListener()函数添加事件处理程序，可以通过removeEventListener() 函数删除事件处理程序。 addEventListener(eventName,handler,useCapture) //添加事件处理程序 removeEventListener(eventName,handler,useCapture) // 删除事件处理程序 其中useCapture如果为true表示支持事件捕获，为falseb表示支持事件冒泡，默认是为false 通过上面的介绍，我们知道了DOM2的事件处理程序存在两种情况，那这两种实现的方式之间有没有相同点和不同点呢？ 相同点 第一：在DOM2的事件处理中不管是IE浏览器还是非IE浏览器都支持对同一个事件绑定多个处理函数。 &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;单击按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&quot;btn&quot;); btn.addEventListener(&quot;click&quot;, function () { console.log(&quot;hello&quot;); }); btn.addEventListener(&quot;click&quot;, function () { console.log(&quot;nihao&quot;); }); &lt;/script&gt; &lt;/body&gt; 以上程序的输出结果为：hello,nihao 第二：在需要删除绑定的事件的时候，，不能删除匿名函数，因为添加的函数和删除的函数必须是同一个函数。 下面的代码中，同时绑定和删除了handler函数，这样做是完全可以的。 var btn=document.getElementById('btn') var handle=function(){ console.log('hello'); } btn.addEventListener('click',handle,false); btn.removeEventListener('click',handle) 但是如果采用如下的删除方式是无法取消绑定的事件的。因为它们都是匿名函数，而并不是同一个函数。 btn.addEventListener('click',function(){ console.log('hello') },false) btn.removeEventListener('click',function(){}) 不同点 第一：在IE浏览器中，使用attachEvent函数为同一个事件添加多个处理程序时，会按照添加的相反顺序执行。 &lt;script&gt; var btn = document.getElementById(&quot;btn&quot;); btn.attachEvent(&quot;onclick&quot;, function () { console.log(&quot;hello&quot;); }); btn.attachEvent(&quot;onclick&quot;, function () { console.log(&quot;nihao&quot;); }); &lt;/script&gt; 当单击按钮的时候，先输出nihao,再输出hello. 第二：在IE浏览中，attachEvent函数添加的事件处理程序会在全局作用域中运行，因此this指向的是window. 在非IE浏览器中，addEventListener()函数添加的处理程序在指定的元素内部执行，this指向所绑定的元素。 既然DOM2事件的处理有浏览器的兼容性问题，那应该怎样进行处理呢？ var EventHandler = { addEventHandler: function (ele, type, handler) { if (ele.addEventListener) { ele.addEventListener(type, handler); } else if (ele.attachEvent) { ele.attachEvent(&quot;on&quot; + type, handler); } else { ele[&quot;on&quot; + type] = handler; } }, removeEventHandler: function (ele, type, handler) { if (ele.addEventListener) { ele.removeEventHandler(type, handler); } else if (ele.detachEvent) { ele.detachEvent(&quot;on&quot; + type, handler); } else { ele[&quot;on&quot; + type] = null; } }, }; DOM3事件模型 DOM3事件模型中允许自定义事件，自定义事件有createEvent(&quot;CustomEvent&quot;)函数来完成。返回的对象有一个initCustomEvent（）方法接收如下四个参数。 1）type：字符串，触发的事件类型，自定义。例如 “keyDown”，“selectedChange”; 2）bubble（布尔值）：标示事件是否应该冒泡； 3）cancelable(布尔值)：标示事件是否可以取消； 4）detail（对象）：任意值，保存在event对象的detail属性中； 具体的示例代码如下 &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;监听自定义事件&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;单击&lt;/button&gt; &lt;script&gt; var customeEvent; //在立即执行函数中创建自定义事件 (function () { //判断浏览器是否支持DOM3事件处理程序，如果条件成立表示支持,固定写法 if (document.implementation.hasFeature(&quot;CustomEvents&quot;, &quot;3.0&quot;)) { var user = { userName: &quot;zhangsan&quot; }; customeEvent = document.createEvent(&quot;CustomEvent&quot;); //创建自定义事件 customeEvent.initCustomEvent(&quot;myEvent&quot;, true, false, user); } })(); //监听自定义事件 //通过addEventListener()函数监听自定义的事件`myEvent` var div1 = document.getElementById(&quot;div1&quot;); div1.addEventListener(&quot;myEvent&quot;, function (e) { console.log(&quot;用户名是:&quot;, e.detail.userName); }); //触发自定义事件 var btn1 = document.getElementById(&quot;btn&quot;); btn.addEventListener(&quot;click&quot;, function () { div1.dispatchEvent(customeEvent); }); &lt;/script&gt; &lt;/body&gt; 以上就是DOM3事件模型的案例。 12、介绍一下事件委托事件冒泡的一个应用就是事件代理，也叫做事件委托 事件委托：利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上。 例如： &lt;div id=&quot;div1&quot;&gt; &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt; &lt;button&gt;增加按钮&lt;/button&gt; &lt;/div&gt; 在上面的代码中有很多的a标签，如果给每个a标签添加单击事件比较麻烦，同时采用这种方式添加事件还会导致占用内存比较多，你可以想象一下，如果a标签比较多的话，是不是会占用更多的内存。 那应该怎样解决这个问题呢？ 可以通过事件委托的机制。也就是将事件绑定到父元素上，然后通过事件冒泡的原理，来解决这个问题。 如下代码所示： &lt;script&gt; const div1 = document.getElementById(&quot;div1&quot;); div1.addEventListener(&quot;click&quot;, function (e) { var target = e.target; if (target.nodeName.toLowerCase() === &quot;a&quot;) { console.log(target.innerHTML); } }); &lt;/script&gt; 在上面的代码中，我们通过事件委托的方式解决了对应的问题，当然，这里你可能问，在div标签下的a标签所做的操作都是一样的，那么能不能针对不同的元素所做的操作如果不一样，事件委托能否处理呢？ 答案是可以处理的。 下面我们把上面的程序改造一下： &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;a1&quot;&gt;a1&lt;/a&gt; &lt;a href=&quot;#&quot; id=&quot;a2&quot;&gt;a2&lt;/a&gt; &lt;a href=&quot;#&quot; id=&quot;a3&quot;&gt;a3&lt;/a&gt; &lt;button&gt;增加按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const div1 = document.getElementById(&quot;div1&quot;); div1.addEventListener(&quot;click&quot;, function (e) { var target = e.target; switch (target.id) { case &quot;a1&quot;: console.log(&quot;针对a1进行操作&quot;); break; case &quot;a2&quot;: console.log(&quot;针对a2进行操作&quot;); break; case &quot;a3&quot;: console.log(&quot;针对a3进行操作&quot;); break; } }); &lt;/script&gt; &lt;/body&gt; 在上面的代码中，给每个a标签，添加了id属性，通过switch结构进行判断，然后执行不同的操作。 下面，我们再来看一个关于事件委托的应用问题： 在一个ul标签中，包含了5个li，需要单击每个li标签，输出标签中的内容。同时在页面中添加一个按钮，单击按钮创建一个新的li元素，单击新创建的li元素也可以输出对应的内容。 我们想到的实现方式如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;a1&lt;/li&gt; &lt;li&gt;a2&lt;/li&gt; &lt;li&gt;a3&lt;/li&gt; &lt;li&gt;a4&lt;/li&gt; &lt;li&gt;a5&lt;/li&gt; &lt;/ul&gt; &lt;button id=&quot;btn&quot;&gt;添加&lt;/button&gt; &lt;script&gt; //通过querySelectorAll方法获取所有的li元素 //通过for循环遍历的方式，给每个li添加单击事件 var children = document.querySelectorAll(&quot;li&quot;); for (var i = 0; i &lt; children.length; i++) { children[i].addEventListener(&quot;click&quot;, function () { console.log(this.innerHTML); }); } //获取按钮 var btn = document.querySelector(&quot;#btn&quot;); //获取ul标签 var ul = document.querySelector(&quot;ul&quot;); //给按钮添加单击事件 btn.addEventListener(&quot;click&quot;, function () { //创建li var newLi = document.createElement(&quot;li&quot;); //创建文本节点 var newText = document.createTextNode(&quot;a6&quot;); //将文本添加到新创建的li标签上 newLi.appendChild(newText); //把创建的li添加到ul上 ul.appendChild(newLi); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 执行上面的代码：打击a1--a5都可以获取内容，单击按钮也可以添加一个新的li元素，但是问题是单击新创建的li元素，并没有输出元素中的内容。 原因是：我们通过querySelectorAll方法获取所有li元素，但是通过这个方法不能实时对增加的事件进行绑定。也就是说无法完成对新元素事件的绑定。 解决办法：先创建新元素，然后在进行事件的绑定。 &lt;script&gt; function bindEvent() { var children = document.querySelectorAll(&quot;li&quot;); for (var i = 0; i &lt; children.length; i++) { children[i].addEventListener(&quot;click&quot;, function () { console.log(this.innerHTML); }); } } var btn = document.querySelector(&quot;#btn&quot;); var ul = document.querySelector(&quot;ul&quot;); btn.addEventListener(&quot;click&quot;, function () { //创建li var newLi = document.createElement(&quot;li&quot;); var newText = document.createTextNode(&quot;a6&quot;); newLi.appendChild(newText); //把创建的li添加到ul上 ul.appendChild(newLi); //重新添加事件处理程序 bindEvent(); }); &lt;/script&gt; 在上面的代码中，我们创建了一个bindEvent函数，把对li元素添加事件的操作封装到了该方法中。 然后在按钮对应的事件处理函数中，先完成新元素的创建，然后在调用bindEvent方法，完成对li元素事件的绑定操作。 虽然以上完成了我们的需求，但是还有一个问题需要解决，就是我们前面所讲的：由于给每个li元素都添加了单击事件，导致占用内存比较多，性能比较低，所以可以使用事件委托的方式来改造上面的程序。 改造后的程序如下所示： &lt;script&gt; var ul = document.querySelector(&quot;ul&quot;); // var parent = document.querySelector(&quot;ul&quot;); ul.addEventListener(&quot;click&quot;, function (e) { var target = e.target; if (target.nodeName.toLowerCase() === &quot;li&quot;) { console.log(target.innerHTML); } }); var btn = document.querySelector(&quot;#btn&quot;); btn.addEventListener(&quot;click&quot;, function () { //创建li var newLi = document.createElement(&quot;li&quot;); var newText = document.createTextNode(&quot;a6&quot;); newLi.appendChild(newText); //把创建的li添加到ul上 ul.appendChild(newLi); //重新添加事件处理程序 // bindEvent(); }); &lt;/script&gt; 在上面的代码中，我们通过querySelector方法获取ul这个父元素，然后给该元素添加单击事件，在对应的事件处理程序中，判断获取到的元素是否为li，如果是打印li元素中的内容。 由于这里我们没有在使用querySelectorAll函数，所以这里我们也没有必要在封装到一个函数中了。 关于按钮的单击事件的处理，没有任何的变化。 以上我们就是通过事件委托的方式，给父元素添加了事件，对应的子元素都具有了相应的事件，这样的处理方式性能更高。 关于事件委托，在这里我们就介绍完了，通过前面的讲解，希望对事件委托有一个比较深刻的理解。 在JavaScript中还有一些其它的比较常用的事件，例如： 焦点相关的事件:focus,blur等事件 鼠标相关的事件:mouseover,mouseout等事件 键盘相关的事件：keydown,keyup,keypress等 其它事件... 关于这些事件，大家可以查看相应的文档，了解对应的基本使用。 13、介绍一下浏览器的重排与重绘在前面的课程中，我们也提到过对DOM的操作是比较消耗性能的，这是因为它会带来浏览器的重绘与重排。 在讲解什么是重排与重绘之前,先来说一下浏览器渲染HTML的过程。 浏览器渲染HTML的过程大体上可以分为4步 第一：HTML代码被HTML解析器解析成对应的DOM树，CSS代码被CSS解析器解析成对应的样式规则集。 第二：DOM树与CSS解析完成后，附加在一起形成一个渲染树 第三：节点信息的计算，即根据渲染树计算出每个节点的几何信息（宽，高等信息） 第四：渲染绘制，根据计算完成的节点信息绘制整个页面。 而我们所要讲解的重排与重绘就发生在第三步和第四步中。 什么是重排 当对一个DOM节点信息进行修改的时候，需要对该DOM结构进行重新的计算。并且该DOM结构的修改会决定周边DOM结构的更改范围，主要分为全局范围和局部范围。 全局范围就是从页面的根节点html标签开始，对整个渲染树进行重新计算，例如：我们修改窗口的尺寸或者修改了根元素的字体大小的时，都会导致对整个渲染树进行重新计算。 局部范围只会对渲染树的某部分进行重新计算。例如要改变页面中某个div的宽度，只需要重新计算渲染树中与该div相关的内容就可以了。 而重排的过程发生在DOM节点信息修改的时候，重排实际是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息，例如DOM元素的位置，尺寸，大小等。然后将其放在页面中的正确的位置上。 综上所述，我们明白了重排其实就是一种改变页面布局的操作。那么常见的引起重排的操作有哪些呢？ （1）页面首次渲染 在页面首次渲染的时候，HTML页面中的各个元素位置，尺寸，大小等信息都是未知的，需要通过与css样式规则集才能够确定出各个元素的几何信息。这个过程中会产生很多元素集合信息的计算，所以会产生重排。 (2)浏览器窗口大小的改变 页面渲染完成后，就会得到一个固定的渲染树。如果此时对浏览器窗口进行缩放或者是拉伸操作，渲染树中从根元素html标签开始的所有元素，都会重新计算其几何信息，从而产生重排的操作。 (3)元素位置改变和尺寸的改变 (4)元素内容改变,例如，文本内容被另外一个不同尺寸的图片替换。 (5)添加或者删除可见的DOM元素 (6)获取某些特定的属性 当我们对javascript某些操作属性的修改也会导致重排的操作，而频繁的重排操作会对浏览器引擎产生很大的消耗。所以浏览器不会对js的每个操作都进行一次重排，而是维护一个会引起重排操作的队列，等到队列中的操作达到了一定的数量或者是到了一定的时间间隔的时候，浏览器才会去刷新一次队列，进行真正的重排操作。 虽然浏览器有这样的优化，但是我们写的一些代码还会导致浏览器提取刷新队列，例如以下的操作。 offsetLeft,offsetWidth,offsetHeight,offsetTop scrollTop,scrollLeft,scrollWidth,scrollHeight clientTop,clientLeft,clientWidth,clientHeight widht,height 当我们进行以上属性操作的时候，浏览器为了返回最精确的信息，需要刷新队列，因为队列中的某些操作会影响到这些属性值的获取。 以上就是浏览器重排的介绍 浏览器重绘 浏览器的重绘指的就是改变元素在页面中的展示样式，而不会引起元素在文档中位置的改变。例如：改变元素的颜色，背景色，透明度等。 常见的引起重绘的操作如下： color:颜色 border-style:边框样式 visibility: 元素是否可见 background:背景样式，包括背景颜色，背景图片等 text-decoration:文本下划线，上划线等 border-radius:边框圆角 box-shadow:元素的阴影 以上就是浏览器的重绘的介绍。 通过对浏览器重排与重绘的介绍，相信大家已经有所了解了，那么它们两者之间有什么关系呢？ 简单的说，重排一定会引起重绘，而重绘却不一定会引起重排的操作。 因为当元素在重排的过程中，元素的位置等几何信息会重新计算，并会引起元素的重新渲染，这样就会产生重绘的操作，而在重绘的时候，只是改变了元素的展示的样式，而不会引起元素在文档中位置的改变，所以一般不会引起重排的操作。 性能优化 浏览器的重排与重绘是比较消耗性能的，所以我们应该尽量减少重排与重绘的操作，这也是优化网页性能的一种方式。 常见的方法如下： 第一：将样式属性值的修改合并为一次。 例如，我们需要修改一个元素的样式，可以通过如下的代码实现： var mainDiv = document.getElementById(&quot;div1&quot;); mainDiv.style.width = &quot;200px&quot;; mainDiv.style.height = &quot;100px&quot;; mainDiv.style.background = &quot;#ccc&quot;; 但是问题是，在上面的操作中多次修改了style属性，会引发多次的重排与重绘操作。 所以为了解决这个问题，可以将这些样式合并在一个class类中。 &lt;style&gt; .changeStyle { width: 200px; height: 100px; background: &quot;#ccc&quot;; } &lt;/style&gt; 然后通过通过javascript直接修改元素的样式 document.getElementById(&quot;div1&quot;).className = &quot;changeStyle&quot;; 这样我们可以在最后一步完成样式的修改，从而只引起一次的重排与重绘的操作。 第二： 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 第三：在对多节点操作的时候，可以现在内测中完成，然后在添加到文档中。 如下代码所示： function createTable(list) { var table = $(&quot;#table&quot;); var rowHtml = &quot;&quot;; list.forEach(function (item) { rowHtml += &quot;&lt;tr&gt;&quot;; rowHtml += &quot;&lt;td&gt;&quot; + item.userName + &quot;&lt;/td&gt;&quot;; rowHtml += &quot;&lt;td&gt;&quot; + item.userPwd + &quot;&lt;/td&gt;&quot;; rowHtml += &quot;&lt;/tr&gt;&quot;; table.append(rowHtml); rowHtml = &quot;&quot;; }); } 当调用createTable方法的时候，会从list集合中取出一条数据，然后放在tr标签中，紧跟着添加到表格中，这样就会导致每添加一行数据，都会引发一次浏览器的重排和重绘的操作，如果数据很多，则会对渲染造成很大的影响。 修改后的代码 function createTabel(list) { var table = $(&quot;#table&quot;); var rowHtml = &quot;&quot;; list.forEach(function (item) { rowHtml += &quot;&lt;tr&gt;&quot;; rowHtml += &quot;&lt;td&gt;&quot; + item.userName + &quot;&lt;/td&gt;&quot;; rowHtml += &quot;&lt;td&gt;&quot; + item.userPwd + &quot;&lt;/td&gt;&quot;; rowHtml += &quot;&lt;/tr&gt;&quot;; }); //将数据一次性追加到表格中，完成一次渲染 table.append(rowHtml); } 通过上面的改造以后，只会引起一次浏览器的重绘与重排的操作，从而带来很大的新能提升。 第四：由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。 第五： 尽量减少table布局,随便修改一个单元格的高度或宽度都会让整个表格进行重排，性能非常差。 第六：在对多个同级元素做事件绑定的时候，推荐使用事件委托机制来处理。 第七：文档片段DocumentFragment的使用，关于这块内容，在前面的课程中已经使用过。 使用批量插入元素，例如：向页面的ul元素中添加100个li元素， const listNode = document.getElementById(&quot;list&quot;); //创建一个文档片段，文档片段存在于内存中，并不在DOM树中，所以此时还没有插入到DOM中 //也就是先将dom插入到临时区域中 const frag = document.createDocumentFragment(); //执行插入 for (let i = 0; i &lt; 10; i++) { const li = document.createElement(&quot;li&quot;); li.innerHTML = `item${i}`; frag.appendChild(li); } //都完成后，再插入到DOM树中 listNode.appendChild(frag); 以上就是关于浏览器重绘与重排的内容。 六、AJAX1、什么是AJAXAjax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。 Ajax的目的是提高用户体验，较少网络数据的传输量。同时，由于AJAX请求获取的是数据而不是html文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。 关于提高用户的体验，可以通过下面来进行体会 下图是普通的请求方式 下图是ajax请求的方式 2、AJAX原理是什么Ajax相当于在用户和服务器之间加了一个中间层,使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器，像一些数据验证和数据处理等都交给Ajax引擎自己来做，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是JavaScript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 3、AJAX基本的使用这里主要掌握的是能够手动创建AJAX. 创建步骤： 创建xhr对象 let xhr = null; if (window.XMLHttpRequest) {// 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr = new XMLHttpRequest(); } else {// 兼容 IE6, IE5 xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } 配置请求地址与发送请求 xhr.open(method, url, async); send(string);//`POST`请求时才使用字符串参数，否则不用带参数。 // method：请求的类型；GET 或 POST // url：文件在服务器上的位置 // async：true（异步）或 false（同步） 注意：POST请求一定要设置请求头的格式内容 xhr.open(&quot;POST&quot;, &quot;test.html&quot;, true); xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;); //`POST`请求参数放在send里面，即请求体 处理响应 xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200){ document.GetElementById(&quot;mydiv&quot;).innerHTML = xhr.responseText; } } 什么是readyState？readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。 readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义： 0：未初始化 — 尚未调用.open()方法； 1：启动 — 已经调用.open()方法，但尚未调用.send()方法； 2：发送 — 已经调用.send()方法，但尚未接收到响应； 3：接收 — 已经接收到部分响应数据； 4：完成 — 已经接收到全部响应数据，而且已经可以在客户端使用了； 什么是status？HTTP状态码(status)由三个十进制数字组成。HTTP状态码共分为5种类型： 1xx（临时响应）：表示临时响应并需要请求者继续执行操作的状态码。 2xx（成功）：表示成功处理了请求的状态码。 3xx（重定向）：表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。 4xx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理。 5xx（服务器错误）：这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 4、AJAX优缺点分析优点 (1)无刷新更新数据 AJAX最大的优点是在不需要刷新浏览器的情况下，能够与服务器保持通信，并且能够减少不必要的数据数据传输，降低网络数据流量，这样可以加快响应用户的请求，避免不必要的等待时间，提高用户的体验。 (2)前后端分离 前端人员只关注前端页面逻辑的开发，通过ajax获取后端数据然后进行展示处理，而后端专注于请求的获取，响应的处理，职责明确。 缺点： (1) 破坏浏览器的后退功能 浏览器有一个比较重要的功能就是历史记录的功能，通过后退按钮可以后退到浏览器之前访问的页面，但是使用了ajax后无法后退，也就是破坏了浏览器的后退机制。 （2）不利于搜索引擎的优化 百度，谷歌在进行搜索引擎优化的时候(SEO),会获取页面中的内容，而通过ajax请求返回的数据是通过javascript动态添加到页面上的，而百度等搜索引擎无法抓取到这些通过javascript动态生成的内容，所以不利于SEO (3) 破坏了URL统一资源定位的功能。 由于AJAX的请求并不会修改浏览器中地址栏的URL，因此对于相同的URL，不同的用户看到的内容是不一样的，例如，你访问某个电商网站，在该电商网站中搜索到一件非常好的商品，你现在把地址发给你的同学，而你的同学打开这个地址后，却看不到这件商品。 所以网站的搜索的实现，一般不是通过ajax来发送请求。 5、Get和Post请求数据的区别(1)参数传递 get请求会将参数添加到URL地址的后面，在调用ajax的send方法的时候，传递的参数是null，即xhr.send(); post请求的数据会放在请求体中，用户是无法通过URL地址直接看到的，调用send方法的时候，需要指定要发送到服务端的数据，即xhr.send(data) (2)服务端的处理 针对get请求与post请求，在服务端的处理也是不一样的。如果以Express来作为服务端，get的请求需要通过Request.query来获取参数，而post请求的处理，需要通过Request.body来获取数据。 （3）传递的数据量 get请求的数据量小，对于不同的浏览器是有差异 ，谷歌浏览器限制8k.post请求传递的数据量比较大，一般默认不受限制。但是服务器一般会做限制。 （4）安全性 get请求的安全性比较低，因为请求的数据会出现在url上，通过浏览器的缓存或者是历史记录很容易获取到请求的数据。post请求是将数据放在请求体中进行传递，数据不会出现在URL，安全性比较高。 6、Get和Post请求的应用场景在了解了get方式和post请求方式的区别以后，下面看一下它们的应用场景。 get的应用场景 （1）数据的搜索，单击搜索按钮，搜索网站中指定的数据。 (2) 传递的数据量小，适合用于url方式进行传递 (3) 数据安全性要求不高的情况 post请求的应用场景 (1) 传递数据量比较大的情况，例如上传文件 (2) 表单提交，例如用户登录，注册，要求数据安全性比较高的情况。 (3) 请求会修改数据库中数据的情况，例如，添加数据，修改数据等。 7、浏览器同源策略浏览器同源策略是浏览器最基本也是最核心的安全功能，它规定客户端脚本在没有明确授权的情况下，不能读写不同源的目标资源。 所谓的同源指的是相同协议，域名和端口号，如果两个资源路径在协议，域名，端口号上有任何一点不同，则它们就不属于同源的资源， 另外在同源策略上，又分为两种表现形式： 第一：禁止对不同页面进行DOM操作 第二：禁止使用XMLHttpRequest向不是同源的服务器发送ajax请求。 8、为什么浏览器会有跨域限制的问题？什么是跨域呢？ 访问同源的资源是被浏览器允许的，但是如果访问不同源的资源，浏览器默认是不允许的。访问不同源的资源那就是我们所说的跨域。 如下表格所示： 从表中可以看出域名，子域名，端口号，协议不同都属于不同源，当脚本被认为是来至不同源时，均被浏览器拒绝请求。 浏览器对跨域访问的限制，可以在很大的程度上保护用户数据的安全。 第一：假如没有Dom同源策略的限制，就有可能会出现如下的安全隐患 黑客做了一个假的的网站，通过iframe嵌套了一个银行的网站，然后把iframe的高度宽度调整到占据浏览器的可视区域 ，这样用户进入这个假的网站后，看到就是和真正的银行网站是一样的内容。如果用户输入了用户名和密码，这个假的网站就可以跨域访问到所嵌套的银行网站的DOM节点，从而黑客就可以获取到用户输入的用户名和密码了。 第二：如果浏览器没有XMLHttpRequest同源策略限制，黑客可以进行跨站请求伪造(CSRF)攻击，具体方式如下： (1)用户登录了个人银行页面A,页面A会在Cookie中保存用户信息 (2)后来用户又访问了一个恶意的页面B,在该页面中执行了恶意Ajax请求的代码 (3)这时页面B会向页面A发送Ajax请求，该请求会默认发送用户Cookie信息。 (4)页面A会从请求的Cookie中获取用户信息，验证无误后，就会返回用户的一系列相关的数据，而这些数据就会被恶意的页面B所获取，从而造成用户数据的泄漏。 正是存在这些危险的场景存在，所以同源策略的限制就显得非常总要。 9、跨域问题演示创建一个文件夹，在该文件夹中创建index.html文件，该文件中的代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload = function () { var btn = document.getElementById(&quot;btnLogin&quot;); btn.addEventListener(&quot;click&quot;, function () { sendRequest(); }); }; function sendRequest() { var userName = document.getElementById(&quot;userName&quot;).value; //这里为了简单，暂时不考虑浏览器兼容性问题 var xhr = new XMLHttpRequest(); let url = &quot;http://localhost:3000/getUserNameInfo?name=&quot; + userName; xhr.open(&quot;get&quot;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { console.log(xhr.responseText); } }; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;br /&gt; &lt;button id=&quot;btnLogin&quot;&gt;登录&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 在该文件夹下面安装express npm install express 同时创建server.js文件，该文件的代码如下： var express = require('express') var app = express(); app.get('/getUserNameInfo', function (req, res) { var userName = req.query.name; var result = { id: 10001, userName: userName, userAge:21 }; var data = JSON.stringify(result); res.writeHead(200, { 'Content-type': 'application/json' }) res.write(data); res.end() }) app.listen(3000, function () { console.log('服务端启动....') }) 下面启动服务端 同时index.html文件也通过vscode自带的服务器进行访问。 这时会出现如下错误： Access to XMLHttpRequest at 'http://localhost:3000/getUserNameInfo?name=admin' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 通过以上错误可以发现，现在的程序出现 跨域的问题， 下面看一下具体的解决方案 10、CORS通过上面的错误，我们明白了，客户端不能发送跨域请求是因为服务端并不接收跨域的请求，所以为了解决跨域请求的问题，我们可以将服务端设置为可以接收跨域请求。 这里我们需要使用CORS(‘跨域资源共享’),来解决跨域请求的问题。CORS主要的实现方式是服务端通过对响应头的设置，接收跨域请求的处理。 服务端修改后的代码如下： var express = require('express') var app = express(); app.all('*', function (req, res) { //设置可以接收请求的域名 res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); res.header('Access-Control-Allow-Methods', 'GET, POST,PUT'); res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Content-Type', 'application/json;charset=utf-8'); req.next(); }) app.get('/getUserNameInfo', function (req, res) { var userName = req.query.name; console.log('userName=',userName) var result = { id: 10001, userName: userName, userAge:21 }; var data = JSON.stringify(result); res.writeHead(200, { 'Content-type': 'application/json' }) res.write(data); res.end() }) app.listen(3000, function () { console.log('服务端启动....') }) 在原有的代码中，我们主要是添加了如下的代码： app.all('*', function (req, res) { //设置可以接收请求的域名 res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); res.header('Access-Control-Allow-Methods', 'GET, POST,PUT'); res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Content-Type', 'application/json;charset=utf-8'); req.next(); }) 在上面的代码中，最主要的是 res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:5500');这行代码， 这行代码是必须的，表示服务器可以接收哪个域发送的请求，可以用通配符*，表示接收全部的域，但是为了安全，我们最好设置特定的域。我们这里测试的是http://127.0.0.1:5500(注意：如果客户端地址是127.0.0.1,这里不能写成localhost,同时还需要注意，这里地址最后没有/) 后面请求头信息可以根据情况进行选择设置，例如接收请求的方法，数据传输的格式等。 通过对服务端的处理不会对前端代码做任何的处理，但是由于不同系统服务端采用的语言与框架是不同的，所以导致服务端的处理方式不同。 11、JSONPJSONP是客户端与服务端进行跨域通信比较常用的解决办法，它的特点是简单，兼容老式浏览器，并且对服务器影响小。 JSONP的实现的实现思想可以分为两步： 第一：在网页中动态添加一个script标签，通过script标签向服务器发送请求，在请求中会携带一个请求的callback回调函数名。 第二: 服务器在接收到请求后，会进行相应处理，然后将参数放在callback回调函数中对应的位置，并将callback回调函数通过json格式进行返回。 前端代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload = function () { var btn = document.getElementById(&quot;btnLogin&quot;); btn.addEventListener(&quot;click&quot;, function () { sendRequest(); }); }; function sendRequest() { var userName = document.getElementById(&quot;userName&quot;).value; //请求参数，其中包含回调函数 var param = &quot;name=&quot; + userName + &quot;&amp;callback=successFn&quot;; //请求的url var url = &quot;http://localhost:3000/getUserNameInfo?&quot; + param; var script = document.createElement(&quot;script&quot;); script.src = url; document.body.appendChild(script); } function successFn(result) { console.log(&quot;result=&quot;, result); } // function sendRequest() { // var userName = document.getElementById(&quot;userName&quot;).value; // //这里为了简单，暂时不考虑浏览器兼容性问题 // var xhr = new XMLHttpRequest(); // let url = &quot;http://localhost:3000/getUserNameInfo?name=&quot; + userName; // xhr.open(&quot;get&quot;, url, true); // xhr.send(); // xhr.onreadystatechange = function () { // if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { // console.log(xhr.responseText); // } // }; // } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;userName&quot; /&gt; &lt;br /&gt; &lt;button id=&quot;btnLogin&quot;&gt;登录&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们重新改造了sendRequest方法，在该方法中构建了param参数，该参数的内容包括了用户输入的用户名以及回调函数名。下面构建好所要请求的服务端的url地址，将该url地址交给script标签的src属性，通过该属性向服务器发送请求。 同时定义回调函数successFn,接收服务端返回的数据。可以对服务端返回的数据做进一步的处理。 这里需要注意的一点就是：回调函数必须设置为全局的函数。因为服务端返回响应后，会在全局环境下查找回调函数。 下面看一下服务端的处理： var express = require('express') var app = express(); // app.all('*', function (req, res) { // //设置可以接收请求的域名 // res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); // res.header('Access-Control-Allow-Methods', 'GET, POST,PUT'); // res.header('Access-Control-Allow-Headers', 'Content-Type'); // res.header('Content-Type', 'application/json;charset=utf-8'); // req.next(); // }) app.get('/getUserNameInfo', function (req, res) { var userName = req.query.name; //获取请求的回调函数 var callbackFn = req.query.callback console.log('callbackFn==',callbackFn) console.log('userName=',userName) var result = { id: 10001, userName: userName, userAge:21 }; var data = JSON.stringify(result); res.writeHead(200, { 'Content-type': 'application/json' }) //返回值是对对回调函数的调用 res.write(callbackFn+'('+data+')') // res.write(data); res.end() }) app.listen(3000, function () { console.log('服务端启动....') }) 在服务的代码中，需要接收回调函数的名称。 同时返回的内容中，包含了回调函数的名称，以及传递给该回调函数的具体数据。 这样当回调函数返回给浏览器后，浏览器可以从全局的环境中查找该回调函数，并进行执行。 使用JSONP的优点与缺点： 优点： 简单，不存在浏览器兼容性的问题 缺点： 只能实现get请求，如果是post请求则无法进行跨域的处理。","link":"/2022/08/15/JavaScript%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/"},{"title":"TypeSctipt常用类型","text":"TypeScript 常用类型 TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：类型系统 所有的 JS 代码都是 TS 代码 JS 有类型（比如，number/string 等），但是 JS 不会检查变量的类型是否发生变化，而 TS 会检查 TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性 类型注解 常用基础类型 类型注解示例代码: let age: number = 18 说明：代码中的 : number 就是类型注解 作用：为变量添加类型约束。比如，上述代码中，约定变量 age 的类型为 number 类型 解释：约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错 错误演示： // 错误代码： // 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致 let age: number = '18' 常用基础类型可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型 JS 已有类型 原始类型：number/string/boolean/null/undefined/symbol 对象类型：object（包括，数组、对象、函数等对象） TS 新增类型 联合类型、自定义类型(类型别名)、接口、元组、字面量类型、枚举、void、any 等 注意： 原始类型在 TS 和 JS 中写法一致 对象类型在 TS 中更加细化，每个具体的对象（比如，数组、对象、函数）都有自己的类型语法 原始类型 原始类型：number/string/boolean/null/undefined/symbol 特点：简单，这些类型，完全按照 JS 中类型的名称来书写 let age: number = 18 let myName: string = '老师' let isLoading: boolean = false // 等等... 数组类型 数组类型的两种写法： 推荐使用 number[] 写法 // 写法一： let numbers: number[] = [1, 3, 5] // 写法二： let strings: Array&lt;string&gt; = ['a', 'b', 'c'] 联合类型需求：数组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写? let arr: (number | string)[] = [1, 'a', 3, 'b'] 解释：|（竖线）在 TS 中叫做联合类型，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种 注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（|| 或）混淆了 类型别名 类型别名（自定义类型）：为任意类型起别名 使用场景：当同一类型（复杂）被多次使用时，可以通过类型别名，简化该类型的使用 type CustomArray = (number | string)[] let arr1: CustomArray = [1, 'a', 3, 'b'] let arr2: CustomArray = ['x', 'y', 6, 7] 解释: 使用 type 关键字来创建自定义类型 类型别名（比如，此处的 CustomArray）可以是任意合法的变量名称 推荐使用大写字母开头 创建类型别名后，直接使用该类型别名作为变量的类型注解即可 函数类型 函数的类型实际上指的是：函数参数和返回值的类型 为函数指定类型的两种方式： 单独指定参数、返回值的类型 同时指定参数、返回值的类型 单独指定参数、返回值的类型： // 函数声明 function add(num1: number, num2: number): number { return num1 + num2 } // 箭头函数 const add = (num1: number, num2: number): number =&gt; { return num1 + num2 } 同时指定参数、返回值的类型: type AddFn = (num1: number, num2: number) =&gt; number const add: AddFn = (num1, num2) =&gt; { return num1 + num2 } 解释：当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型 注意：这种形式只适用于函数表达式 void 类型 如果函数没有返回值，那么，函数返回值类型为：void function greet(name: string): void { console.log('Hello', name) } 注意： 如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 void 类型 // 如果什么都不写，此时，add 函数的返回值类型为： void const add = () =&gt; {} // 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同 const add = (): void =&gt; {} // 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以 const add = (): undefined =&gt; { // 此处，返回的 undefined 是 JS 中的一个值 return undefined } 函数可选参数 使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到可选参数了 比如，数组的 slice 方法，可以 slice() 也可以 slice(1) 还可以 slice(1, 3) function mySlice(start?: number, end?: number): void { console.log('起始索引：', start, '结束索引：', end) } 可选参数：在可传可不传的参数名称后面添加 ?（问号） 注意：可选参数只能出现在参数列表的最后，也就是说可选参数后面不能再出现必选参数 对象类型 JS 中的对象是由属性和方法构成的，而 TS 对象的类型就是在描述对象的结构（有什么类型的属性和方法） 对象类型的写法: // 空对象 let person: {} = {} // 有属性的对象 let person: { name: string } = { name: '同学' } // 既有属性又有方法的对象 // 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔 let person: { name: string; sayHi(): void } = { name: 'jack', sayHi() {} } // 对象中如果有多个类型，可以换行写： // 通过换行来分隔多个属性类型，可以去掉 `;` let person: { name: string sayHi(): void } = { name: 'jack', sayHi() {} } 解释: 使用 {} 来描述对象结构 属性采用属性名: 类型的形式 方法采用方法名(): 返回值类型的形式 使用类型别名 注意：直接使用 {} 形式为对象添加类型，会降低代码的可读性（不好辨识类型和值） 推荐：使用类型别名为对象添加类型 // 创建类型别名 type Person = { name: string sayHi(): void } // 使用类型别名作为对象的类型： let person: Person = { name: 'jack', sayHi() {} } 带有参数的方法类型 如果方法有参数，就在方法名后面的小括号中指定参数类型 type Person = { greet(name: string): void } let person: Person = { greet(name) { console.log(name) } } 箭头函数形式的方法类型 方法的类型也可以使用箭头函数形式 type Person = { greet: (name: string) =&gt; void } let person: Person = { greet(name) { console.log(name) } } 对象可选属性 对象的属性或方法，也可以是可选的，此时就用到可选属性了 比如，我们在使用 axios({ ... }) 时，如果发送 GET 请求，method 属性就可以省略 可选属性的语法与函数可选参数的语法一致，都使用 ? 来表示 type Config = { url: string method?: string } function myAxios(config: Config) { console.log(config) } 接口当一个对象类型被多次使用时，一般会使用接口（interface）来描述对象的类型，达到复用的目的 解释： 使用 interface 关键字来声明接口 接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 I 开头 声明接口后，直接使用接口名称作为变量的类型 因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号) interface IPerson { name: string age: number sayHi(): void } let person: IPerson = { name: 'jack', age: 19, sayHi() {} } interface vs type interface（接口）和 type（类型别名）的对比： 相同点：都可以给对象指定类型 不同点: 接口，只能为对象指定类型 类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名 推荐：能使用 type 就是用 type interface IPerson { name: string age: number sayHi(): void } // 为对象类型创建类型别名 type IPerson = { name: string age: number sayHi(): void } // 为联合类型创建类型别名 type NumStr = number | string 接口继承 如果两个接口之间有相同的属性或方法，可以将公共的属性或方法抽离出来，通过继承来实现复用 比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐 interface Point2D { x: number; y: number } interface Point3D { x: number; y: number; z: number } 更好的方式: interface Point2D { x: number; y: number } // 继承 Point2D interface Point3D extends Point2D { z: number } 解释： 使用 extends(继承)关键字实现了接口 Point3D 继承 Point2D 继承后，Point3D 就有了 Point2D 的所有属性和方法(此时，Point3D 同时有 x、y、z 三个属性) 元组 场景：在地图中，使用经纬度坐标来标记位置信息 可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型 number[] let position: number[] = [116.2317, 39.5427] 使用 number[] 的缺点：不严谨，因为该类型的数组中可以出现任意多个数字 更好的方式：元组 Tuple 元组类型是另一种类型的数组，它确切地知道包含多少个元素，以及特定索引对应的类型 let position: [number, number] = [39.5427, 116.2317] 解释： 元组类型可以确切地标记出有多少个元素，以及每个元素的类型 该示例中，元素有两个元素，每个元素的类型都是 number 类型推论 在 TS 中，某些没有明确指出类型的地方，TS 的类型推论机制会帮助提供类型 换句话说：由于类型推论的存在，这些地方，类型注解可以省略不写 发生类型推论的 2 种常见场景: 声明变量并初始化时 决定函数返回值时 // 变量 age 的类型被自动推断为：number let age = 18 // 函数返回值的类型被自动推断为：number function add(num1: number, num2: number) { return num1 + num2 } 推荐：能省略类型注解的地方就省略（偷懒，充分利用TS类型推论的能力，提升开发效率） 技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型 推荐：在 VSCode 中写代码的时候，多看方法、属性的类型，养成写代码看类型的习惯 console.log() document.createElement() 字面量类型 思考以下代码，两个变量的类型分别是什么? let str1 = 'Hello TS' const str2 = 'Hello TS' 通过 TS 类型推论机制，可以得到答案： 变量 str1 的类型为：string 变量 str2 的类型为：’Hello TS’ 解释: str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string str2 是一个常量(const)，它的值不能变化只能是 ‘Hello TS’，所以，它的类型为:’Hello TS’ 注意：此处的 ‘Hello TS’，就是一个字面量类型，也就是说某个特定的字符串也可以作为 TS 中的类型 任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用 字面量：{ name: 'jack' } [] 18 20 'abc' false function() {} let str1 = 'Hello TS' const str2 = 'Hello TS123' str1 = str2 // str2 = str1 不行 使用模式和场景 使用模式：字面量类型配合联合类型一起使用 使用场景：用来表示一组明确的可选值列表 比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个 // 使用自定义类型: type Direction = 'up' | 'down' | 'left' | 'right' function changeDirection(direction: Direction) { console.log(direction) } // 调用函数时，会有类型提示： changeDirection('up') 解释：参数 direction 的值只能是 up/down/left/right 中的任意一个 优势：相比于 string 类型，使用字面量类型更加精确、严谨 【了解】枚举 枚举的功能类似于字面量类型+联合类型组合的功能，也可以表示一组明确的可选值 枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个 // 创建枚举 enum Direction { Up, Down, Left, Right } // 使用枚举类型 function changeDirection(direction: Direction) { console.log(direction) } // 调用函数时，需要应该传入：枚举 Direction 成员的任意一个 // 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员 changeDirection(Direction.Up) 解释: 使用 enum 关键字定义枚举 约定枚举名称以大写字母开头 枚举中的多个值之间通过 ,（逗号）分隔 定义好枚举后，直接使用枚举名称作为类型注解 数字枚举 问题：我们把枚举成员作为了函数的实参，它的值是什么呢? 解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0 注意：枚举成员是有值的，默认为：从 0 开始自增的数值 我们把，枚举成员的值为数字的枚举，称为：数字枚举 当然，也可以给枚举中的成员初始化值 // Down -&gt; 11、Left -&gt; 12、Right -&gt; 13 enum Direction { Up = 10, Down, Left, Right } enum Direction { Up = 2, Down = 4, Left = 8, Right = 16 } 字符串枚举 字符串枚举：枚举成员的值是字符串 注意：字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值 enum Direction { Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT' } 枚举实现原理 枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一 因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的) 也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，枚举类型会被编译为 JS 代码 enum Direction { Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT' } // 会被编译为以下 JS 代码： var Direction; (function (Direction) { Direction['Up'] = 'UP' Direction['Down'] = 'DOWN' Direction['Left'] = 'LEFT' Direction['Right'] = 'RIGHT' })(Direction || Direction = {}) 说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表 一般情况下，推荐使用字面量类型+联合类型组合的方式，因为相比枚举，这种方式更加直观、简洁、高效 any 类型 原则:不推荐使用 any!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势) 因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示 let obj: any = { x: 0 } obj.bar = 100 obj() const n: number = obj 解释:以上操作都不会有任何类型错误提示，即使可能存在错误 尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型 其他隐式具有 any 类型的情况 声明变量不提供类型也不提供默认值 函数参数不加类型 注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型 在项目开发中，尽量少用any类型 类型断言有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如， const aLink = document.getElementById('link') 注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性 因此，这个**类型太宽泛(不具体)**，无法操作 href 等 a 标签特有的属性或方法 解决方式：这种情况下就需要使用类型断言指定更加具体的类型 使用类型断言： const aLink = document.getElementById('link') as HTMLAnchorElement 解释: 使用 as 关键字实现类型断言 关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型） 通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了 另一种语法，使用 &lt;&gt; 语法，这种语法形式不常用知道即可: // 该语法，知道即可：在react的jsx中使用会报错 const aLink = &lt;HTMLAnchorElement&gt;document.getElementById('link') 技巧：在浏览器控制台，通过 __proto__ 获取 DOM 元素的类型 typeof 众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型 console.log(typeof 'Hello world') // ? 实际上，TS 也提供了 typeof 操作符：可以在类型上下文中引用变量或属性的类型（类型查询） 使用场景:根据已有变量的值，获取该值的类型，来简化类型书写 let p = { x: 1, y: 2 } function formatPoint(point: { x: number; y: number }) {} formatPoint(p) function formatPoint(point: typeof p) {} 解释: 使用 typeof 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同 typeof 出现在类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文(区别于 JS 代码) 注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）","link":"/2022/08/20/TypeSctipt%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"title":"初识TypeScript","text":"TypeScript TypeScript 介绍 TypeScript 初体验 TypeScript 常用类型 TypeScript 高级类型 TypeScript 类型声明文件 在 React 中使用 TypeScript TypeScript 介绍 TS 官方文档 TS 中文参考 - 不再维护 TypeScript 是什么 TypeScript 为什么要为 JS 添加类型支持? TypeScript 相比 JS 的优势 TypeScript 是什么 TypeScript 简称：TS，是 JavaScript 的超集，简单来说就是：JS 有的 TS 都有 TypeScript = Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持） TypeScript 是微软开发的开源编程语言，可以在任何运行 JavaScript 的地方运行 TypeScript 为什么要为 JS 添加类型支持? 背景：JS 的类型系统存在“先天缺陷”，JS 代码中绝大部分错误都是类型错误（Uncaught TypeError） 这些经常出现的错误，导致了在使用 JS 进行项目开发时，增加了找 Bug、改 Bug 的时间，严重影响开发效率 为什么会这样？ 从编程语言的动静来区分，TypeScript 属于静态类型的编程语言，JavaScript 属于动态类型的编程语言 静态类型：编译期做类型检查 动态类型：执行期做类型检查 代码编译和代码执行的顺序：1 编译 2 执行 对于 JS 来说：需要等到代码真正去执行的时候才能发现错误（晚） 对于 TS 来说：在代码编译的时候（代码执行前）就可以发现错误（早） 并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 Bug、改 Bug 时间 对比： 使用 JS： 在 VSCode 里面写代码 在浏览器中运行代码 –&gt; 运行时，才会发现错误【晚】 使用 TS： 在 VSCode 里面写代码 –&gt; 写代码的同时，就会发现错误【早】 在浏览器中运行代码 TypeScript 相比 JS 的优势 更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率 程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验 强大的类型系统提升了代码的可维护性，使得重构代码更加容易 支持最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿 TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了学习负担 除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端 项目的首选编程语言 目前，前端最新的开发技术栈： React： TS + Hooks Vue： TS + Vue3 注意： Vue2 对 TS 的支持不好~ TypeScript 初体验 安装编译 TS 的工具包 编译并运行 TS 代码 简化运行 TS 的步骤 安装编译 TS 的工具包 问题：为什么要安装编译 TS 的工具包? 回答：Node.js/浏览器，只认识 JS 代码，不认识 TS 代码。需要先将 TS 代码转化为 JS 代码，然后才能运行 安装命令：npm i -g typescript typescript 包：用来编译 TS 代码的包，提供了 tsc 命令，实现了 TS -&gt; JS 的转化 注意：Mac 电脑安装全局包时，需要添加 sudo 获取权限：sudo npm i -g typescript yarn 全局安装：sudo yarn global add typescript 验证是否安装成功：tsc –v(查看 typescript 的版本) 编译并运行 TS 代码 创建 hello.ts 文件（注意：**TS 文件的后缀名为 .ts**） 将 TS 编译为 JS：在终端中输入命令，tsc hello.ts（此时，在同级目录中会出现一个同名的 JS 文件） 执行 JS 代码：在终端中输入命令，node hello.js 1 创建 ts 文件 ===&gt; 2 编译 TS ===&gt; 3 执行 JS 说明：所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可 注意：由 TS 编译生成的 JS 文件，代码中就没有类型信息了 简化运行 TS 的步骤 问题描述：每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐 简化方式：使用 ts-node 包，直接在 Node.js 中执行 TS 代码 安装命令：npm i -g ts-node ts-node 包提供了 ts-node 命令 使用方式：ts-node hello.ts 相当于：1 tsc 命令 2 node（注意：ts-node 不会生成 js 文件） 解释：ts-node 命令在内部偷偷的将 TS -&gt; JS，然后，再运行 JS 代码","link":"/2022/08/15/%E5%88%9D%E8%AF%86TypeScript/"},{"title":"Vue知识点","text":"一、Vue知识点串讲复习一下Vue中的核心知识点。 复习完基本的知识点以后，后面再来看一下其它的面试内容 1、基本使用下面，先来看一段最简单的代码，如下所示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vue基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{msg}} &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建vue实例 const app = new Vue({ el: &quot;#app&quot;, data() { return { msg: &quot;hello world&quot;, }; }, }); setTimeout(() =&gt; { app.msg = &quot;hello Vue&quot;; }, 1000); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中,创建了vue的实例，并且指定了数据，最终数据展示在id 为app的这个div中，并且在停顿了1秒中以后，通过Vue的实例来修改对应的msg数据。 通过上面的代码，我们能够够看到Vue的核心理念是数据驱动的理念，所谓的数据驱动的理念：当数据发生变化的时候，用户界面也会发生相应的变化，开发者并不需要手动的去修改dom. 简单的理解：就是vue.js帮我们封装了数据和dom对象操作的映射，我们只需要关心数据的逻辑处理，数据的变 化就能够自然的通知页面进行页面的重新渲染。 这样做给我们带来的好处就是，我们不需要在代码中去频繁的操作dom了，这样提高了开发的效率，同时也避免了在操作Dom的时候出现的错误。 Vue.js的数据驱动是通过MVVM这种框架来实现的，MVVM 框架主要包含三部分：Model,View,ViewMode Model:指的是数据部分，对应到前端就是JavaScript对象。 View:指的就是视图部分 ViewModel: 就是连接视图与数据的中间件(中间桥梁) 以上三部分对应到代码中的位置如下图所示： 下面，我们再来看一张图来理解一下MVVM框架的作用: 数据(Model)和视图(View)是不能直接通讯的，而是需要通过ViewModel来实现双方的通讯。当数据(Model)变化的时候，ViewModel能够监听到这种变化，并及时通知View视图做出修改。同样的，当页面有事件触发的时候，ViewModel也能够监听到事件，并通知数据(Model)进行响应。所以ViewModel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。 简单的理解就是：MVVM 实现了将业务(数据)与视图进行分离的功能。 在这里还需要注意的一点就是： MVVM框架的三要素：响应式，模板引擎，渲染 响应式：vue如何监听数据的变化？ 模板：Vue的模板如何编写和解析？怎样将具体的值替换掉{{msg}}内容，这就是模板引擎的解析。 渲染：Vue如何将模板转换成html? 其实就是有虚拟DOM 向真实DOM的转换。 在后面的课程中，我们还会深入探讨这块内容，包括我们自己模拟实现一个数据驱动的框架。 以上内容也是面试的时候，会问到的问题。 2、模板语法2.1 属性绑定属性的绑定，下面先来看一下关于对属性的绑定 &lt;div id=&quot;app&quot;&gt; &lt;h2 v-bind:title=&quot;msg&quot;&gt; {{msg}} &lt;/h2&gt; &lt;/div&gt; 在上面的代码中，我们通过v-bind的方式给h2绑定了一个title属性。 当然，上面的代码我们也可以使用如下的方式来进行简化 &lt;div id=&quot;app&quot;&gt; &lt;h2 :title=&quot;msg&quot;&gt; {{msg}} &lt;/h2&gt; &lt;/div&gt; 为了避免闪烁的问题，也就是最开始的时候，出现:{{msg}}的情况，可以使用如下的绑定方式。 &lt;div id=&quot;app&quot;&gt; &lt;h2 :title=&quot;msg&quot;&gt; &lt;!-- {{msg}} --&gt; &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/div&gt; 3、 列表渲染我们可以使用v-for指令基于一个数组来渲染一个列表.v-for指令需要使用item in items形式的语法。其中items 是源数组，而item则是被迭代的数组元素的别名。 基本实现的代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!-- users表示数组，item表示从数组中取出的对象,这个名字可以随意取 --&gt; &lt;!-- 注意 v-for必须结合key属性来使用，它会唯一标识数组中的每一项，未来当数组中的那一项改变的时候，它会只更新那一项，好处就是提升性能。注意key的值唯一，不能重复 --&gt; &lt;!-- index表示数组的索引值，该名字可以随意定义 --&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot;&gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { users: [ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：为了能够保证列表渲染的性能，我们需要给v-for添加key属性。key值必须唯一，而且不能使用index与random作为key的值。 关于这一点是与虚拟DOM算法密切相关的。在后面的课程中会最为一个重点来探讨虚拟DOM的内容。这也是面试的时候经常被问到的问题。 4、v-model在前面讲解vue简介的时候，我们说过，如果model中的数据发生了改变，会通过ViewModel通知View更新数据，这个效果前面我们也已经演示了，现在演示一下当view中的数据发生了变化后，怎样通过ViewModel来通知model来完成数据的更新。 其实这就是我们常说的，“双向数据绑定” 怎样实现这种效果呢？可以通过v-model来实现。 &lt;!-- v-model指令用来双向数据绑定：就是model和view中的值进行同步变化 --&gt; &lt;!-- v-model只能在input/textarea/selet 也就是表单元素--&gt; 具体代码实现如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;双向数据绑定&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;userName&quot; /&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, data: { userName: &quot;zhangsan&quot;, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 怎样验证v-model实现了双向数据绑定呢？ 可以打开控制台，然后输入：vm.userName 发现输出的值为&quot;zhangsan&quot;, 取的是模型中的数据。 当在文本框中输入新的值后，在敲一下vm.userName发现对应的数据发生了变化，也就是视图中的数据发生了变化，模型中的数据也 会发生变化。 那么在控制台中直接给vm.userName=&quot;lisi&quot;,发现文本框中的值也发生了变化。 关于v-model 这个知识点，面试的时候经常会被问到的一个问题就是，自己能否模拟实现一个类似于v-model的双向数据绑定的效果。关于这个问题你可以先思考一下，在后面的课程中，我们会详细的讲解。 5、v-on怎样监听dom的事件呢？可以通过v-on指令完成，具体的代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;{{name}}&lt;/span&gt; &lt;!-- 通过v-on来指定对应的事件，然后后面跟上对应的方法名，方法的定义在methods完成 --&gt; &lt;button v-on:click=&quot;changeName&quot;&gt;更换姓名&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new new Vue({ el: '#app', data: { name: 'zhangsan' }, // 通过methods完成函数或方法的定义 methods: { changeName() { // 在methods中要获取data中的属性，需要通过this来完成，this表示的是vue实例。 this.name = &quot;itcast&quot; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 还可以通过简写的形式。建议以后都使用简写的形式 &lt;button @click=&quot;changeName&quot;&gt;更换姓名&lt;/button&gt; 带参数的形式如下： &lt;button @click=&quot;changeNameByArg('laowang')&quot;&gt;带参数的情况&lt;/button&gt; &lt;script&gt; var vm = new new Vue({ el: '#app', data: { name: 'zhangsan' }, // 通过methods完成函数或方法的定义 methods: { changeName() { // 在methods中要获取data中的属性，需要通过this来完成，this表示的是vue实例。 this.name = &quot;itcast&quot; }, changeNameByArg(userName) { this.name = userName } } }) &lt;/script&gt; 除了绑定鼠标的单击事件以外，也可以绑定键盘的实际。 例如，页面有有一个文本框，用户在该文本框中输入内容，按下回车键，获取到用户输入的内容。 &lt;div id=&quot;app&quot;&gt; &lt;span&gt;{{name}}&lt;/span&gt; &lt;!-- 通过v-on来指定对应的事件，然后后面跟上对应的方法名，方法的定义在methods完成 --&gt; &lt;button @click=&quot;changeName&quot;&gt;更换姓名&lt;/button&gt; &lt;button @click=&quot;changeNameByArg('laowang')&quot;&gt;带参数的情况&lt;/button&gt; &lt;!--给文本框添加键盘事件--&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;changeUserName&quot; v-model=&quot;name&quot; /&gt; &lt;/div&gt; 在mehtods中定义changeUserName方法 // 通过methods完成函数或方法的定义 methods: { changeName() { // 在methods中要获取data中的属性，需要通过this来完成，this表示的是vue实例。 this.name = &quot;itcast&quot;; }, changeNameByArg(userName) { this.name = userName; }, //定义处理文本框键盘事件的方法。 changeUserName() { console.log(this.name); }, }, 在上面的案例中，我们使用了按键的修饰符：.enter,在官方文档中，还有其它的按键修饰符，如下所示： https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6 与之相关的就是事件修饰符，如下所示： https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6 以上内容，大家可以在课下的时候，仔细看一下。 6、Class与Style绑定这块主要内容主要与样式设置有关。 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 下面先来看一下Class的绑定。 在”列表渲染”中给每个列表项添加对应的样式。 &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; 下面给li列表添加上面所定义的样式。 &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :class=&quot;{actived:true}&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; 在上面的代码中，我们可以看到，给li标签绑定了class属性，同时actived的值为true,表示给li添加actived样式。 现在有一个需求，就是当鼠标移动到列表项上的时候，更改对应的背景色。 &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :class=&quot;{actived:selectItem===item}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 在对class进行绑定的时候，做了一个判断，判断一下selectItem是否与item相等，如果相等添加样式。 当鼠标移动到某个li 列表上的时候，触发mousemove事件，将item的值给selectItem. 在data中定义selectItem. 如下所示： data: { selectItem: &quot;&quot;, users: [ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ], }, 完整 代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!-- users表示数组，item表示从数组中取出的对象,这个名字可以随意取 --&gt; &lt;!-- 注意 v-for必须结合key属性来使用，它会唯一标识数组中的每一项，未来当数组中的那一项改变的时候，它会只更新那一项，好处就是提升性能。注意key的值唯一，不能重复 --&gt; &lt;!-- index表示数组的索引值，该名字可以随意定义 --&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :class=&quot;{actived:selectItem===item}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { selectItem: &quot;&quot;, users: [ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面，我们再来看一下Style的绑定。 &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; 通过上面的代码，可以看到通过绑定style的方式来处理样式是非常麻烦的。 7、条件渲染 v-if和v-show指令可以用来控制元素的显示和隐藏 下面，我们先来看一下v-if的应用。 这里还是对用户数据进行判断。 &lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;!-- users表示数组，item表示从数组中取出的对象,这个名字可以随意取 --&gt; &lt;!-- 注意 v-for必须结合key属性来使用，它会唯一标识数组中的每一项，未来当数组中的那一项改变的时候，它会只更新那一项，好处就是提升性能。注意key的值唯一，不能重复 --&gt; &lt;!-- index表示数组的索引值，该名字可以随意定义 --&gt; &lt;!-- &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :class=&quot;{actived:selectItem===item}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; --&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 在上面的代码中，我们首先对users数组做了一个判断，如果没有数据，就在页面上展示：“没有任何用户数据” 否则渲染整个列表。 上面是关于v-if的使用，下面看一下v-show. v-show 是通过css属性display控制元素显示，元素总是存在的。 v-if:通过控制dom来控制元素的显示和隐藏,如果一开始条件为false,元素是不存在的。 什么时候使用v-show,什么时候使用v-if呢？ 如果需要频繁的控制元素的显示与隐藏，建议使用v-show. 从而避免大量DOM操作，提高性能。 而如果某个元素满足条件后，渲染到页面中，并且以后变化比较少，可以使用v-if 8、计算属性计算属性出现的目的是解决模板中放入过多的逻辑会让模板过重且难以维护的问题. 计算属性是根据data中已有的属性，计算得到一个新的属性. 下面，我们可以通过一个案例来学习一下计算属性、 在一个文本框中输入第一个名字，第二个文本框中输入第二个名字，然后展示全部名称。 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 这样是模板逻辑变得非常复杂，不易维护 --&gt; &lt;div&gt;全名：{{firstName + lastName}}&lt;/div&gt; &lt;div&gt;全名：{{fullName}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { firstName: '', lastName: '' }, // 创建计算属性通过computed关键字，它是一个对象 computed: { // 这里fullName就是一个计算属性，它是一个函数，但这个函数可以当成属性来使用 fullName() { return this.firstName + this.lastName } } }) &lt;/script&gt; &lt;/body&gt; 了解了计算属性后，下面对用户列表添加一个功能，要求是计算总人数。 可以在ul列表下面，添加如下的代码。 &lt;p&gt; 总人数：{{users.length+\"个\"}} &lt;/p&gt; 最终展示出了，对应的人数，但是这里在模板中做了运算（在这里做了字符串拼接，虽然计算简单，但是最好还是通过计算属性来完成），为了防止在模板中放入过多的逻辑计算，这里可以使用计算属性来解决。 下面对代码进行改造： &lt;p&gt; &lt;!-- 总人数：{{users.length+\"个\"}} --&gt; 总人数：{{total}} &lt;/p&gt; 计算属性实现： &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { selectItem: &quot;&quot;, users: [ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ], }, computed: { total() { // 计算属性是有缓存性：如果值没有发生变化，则页面不会重新渲染 return this.users.length + &quot;个&quot;; }, }, }); &lt;/script&gt;v 通过上面的代码，可以看到使用计算属性，让界面变得更加的简洁。 使用计算属性还有一个好处： 其实细心的话就会发现，调用methods里的方法也能实现和计算属性一样的效果，既然使用methods就可以实现，那为什么还需要计算属性呢？原因就是计算属性是基于他的依赖缓存的（所依赖的还是data中的数据）。一个计算属性所依赖的数据发生变化时，他才会重新取值 也就是说：只要相关依赖没有改变，对此访问计算属性得到的是之前缓 存的结果，不会多次执行。 下面我们测试一下： &lt;p&gt; &lt;!-- 总人数：{{users.length+\"个\"}} --&gt; 总人数：{{total}} 总人数：{{total}} &lt;/p&gt; 在上面的代码中，我们使用total了两次。 下面在看一下关于计算属性中的代码修改： computed: { total() { console.log(&quot;aaa&quot;); // 计算属性是有缓存性：如果值没有发生变化，则页面不会重新渲染 return this.users.length + &quot;个&quot;; }, }, 这里，我们通过console输出字符串aaa,但是在控制台上只是输出了一次，因为，第二次使用total的时候，发现值没有变化，所以直接从缓存中获取了对应的值。并没有重新进行计算，这样带来的好处就是，性能得到了提升。 下面，我们换成methods函数的形式来看一下： &lt;p&gt; &lt;!-- 总人数：{{users.length+\"个\"}} --&gt; 总人数：{{total}} 总人数：{{total}} 总人数：{{getTotal()}} 总人数：{{getTotal()}} &lt;/p&gt; 在上面的代码中，调用了两次getTotal方法。 getTotal方法的实现如下： methods: { getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, }, 实现的方式是差不多的，但是这里却执行了两次。（注意：由于本案例中给每一个li标签添加了 *@mousemove*,所以只要鼠标移动到列表上，就会导致页面重新渲染，这时会不断的调用getTotal方法。） 所以通过上面案例的演示，可以明确的看出计算属性是有缓存的，也就是所依赖的data属性中的数据没有变化，那么是不会重新计算的。所以提升了对应的性能。 所以说，在进行大量耗时计算的时候，建议使用计算属性来完成。 如下代码： data: { selectItem: &quot;&quot;, num: 100 } 在data中定义了num 属性，并且初始值为100、 下面在计算属性中进行求和的运算，代码实现如下： computed: { total() { console.log(&quot;aaa&quot;); // 计算属性是有缓存性：如果值没有发生变化，则页面不会重新渲染 // return this.users.length + &quot;个&quot;; let count = 0; for (let i = 0; i &lt;= this.num; i++) { count += i; } return count; }, }, 通过演示，可以发现计算属性只是在第一次调用的时候，执行了一次，后续由于所依赖的数据num没有发生变化，所以即时调用多次，也并没有重新进行计算，而是获取上次计算的结果，所以说在进行大量耗时计算的时候，通过计算属性可以提升性能。 9、侦听器侦听器就是侦听data中的数据变化，如果数据一旦发生变化就通知侦听器所绑定方法，来执行相应的操作。从这一点上，与计算属性是非常类似的。 但是，侦听器也有自己独有的应用场景。 执行异步或开销较大的操作。 下面，先来看一下侦听器的基本使用 我们使用侦听器来统计总人数。 &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; 在data中定义totalCount属性。 data: { selectItem: &quot;&quot;, num: 100, totalCount: 0 } 使用watch来监听users数组的数据变化。 watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, } 当users数组发生了变化后，就会执行handler这个函数，同时用于加上了immediate属性，并且该属性的值为true，表示的就是在初始化绑定的时候，也会去执行侦听器。因为watch在初始化绑定的时候是不会执行的，等到所监听的内容改变之后才会去侦听执行。 以上就是watch侦听器的基本使用，但是通过这个案例，我们发现还是使用计算属性来统计总人数更加的方便一些。 当然，侦听器有自己的应用场景，它的应用场景就是在执行异步请求或者进行开销比较大的操作的时候，会使用侦听器。 下面我们在通过一个案例，来体会一下watch侦听器的应用场景。 下面我们来看一个异步操作的情况。就是当用户在一个文本框中输入了用户名以后，要将输入的用户名发送到服务端，来检查该用户名是否已经被占用。 具体的实现代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;侦听器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;!--这里使用了lazy,保证当文本框失去焦点后，才去执行对应操作--&gt; &lt;span&gt;&lt;input type=&quot;text&quot; v-model.lazy=&quot;uname&quot; /&gt;&lt;/span&gt; &lt;span&gt;{{message}}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, data: { uname: &quot;&quot;, message: &quot;&quot;, }, methods: { checkUserName: function (userName) { let that = this; setTimeout(function () { if (userName === &quot;admin&quot;) { that.message = &quot;用户名已经存在,请更改....&quot;; } else { that.message = &quot;该用户名可以使用.....&quot;; } }, 3000); }, }, watch: { uname: function (value) { //调用后台接口，来验证用户名是被占用 this.checkUserName(value); this.message = &quot;正在校验用户名....&quot;; }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 以上的案例，就是通过watch来监听uname的值是否发生变化，如果发生了变化，就通过发送异步请求来检查uname中的值，是否已经被占用。 通过以上的案例：我们可以看到watch是允许异步操作的，并且在我们得到最终的结果前，可以设置中间状态，这些都是计算属性无法做到的。 最后我们把计算属性与侦听器做一个总结，看一下它们的应用场景。 第一点：语境上的差异： watch适合一个值发生了变化，对应的要做一些其它的事情，适合一个值影响多个值的情形。 例如，上面案例中的用户名检测，这里是一个uname发生了变化，但是这里做了很多其它的事情，例如修改message的值，发送异步请求。 而计算属性computed:一个值由其它的值得来，其它值发生了变化，对应的值也会变化，适合做多个值影响一个值的情形。 例如如下代码： computed:{ fullName(){ return this.firstName+' '+this.lastName } } 第二点：计算属性有缓存性。 由于这个特点，我们在实际的应用中，能用计算属性的，会首先考虑先使用计算属性。 第三点：侦听器选项提供了更加通用的方法，适合执行异步操作或者较大开销操作。 10、生命周期简介每个Vue实例在被创建时都要经过一系列的初始化过程，例如：需要设置数据的监听，编译模板，将实例挂载到DOM上，并且在数据变化时更新DOM等，这些过程统称为Vue实例的生命周期。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 下面，我们来看一下这些钩子函数的应用。 通过一个异步获取列表数据的案例，来查看这些生命周期的钩子函数应用。 在这里是通过异步的方式获取用户列表的数据。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;!-- users表示数组，item表示从数组中取出的对象,这个名字可以随意取 --&gt; &lt;!-- 注意 v-for必须结合key属性来使用，它会唯一标识数组中的每一项，未来当数组中的那一项改变的时候，它会只更新那一项，好处就是提升性能。注意key的值唯一，不能重复 --&gt; &lt;!-- index表示数组的索引值，该名字可以随意定义 --&gt; &lt;!-- &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :class=&quot;{actived:selectItem===item}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; --&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; &lt;!-- 总人数：{{users.length+\"个\"}} --&gt; &lt;!-- 总人数：{{total}} 总人数：{{total}} 总人数：{{getTotal()}} 总人数：{{getTotal()}} --&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { selectItem: &quot;&quot;, num: 100, totalCount: 0, //指定users默认数据为一个空数组。 users: [], }, //组件实例已创建时，执行created方法，来调用getUserList方法，发送异步请求获取数据 //将获取到的数据交个users这个状态数组。 async created() { const users = await this.getUserList(); this.users = users; }, methods: { getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, //在getUserList方法中，模拟一个异步请求。 getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, // computed: { // total() { // console.log(&quot;aaa&quot;); // // 计算属性是有缓存性：如果值没有发生变化，则页面不会重新渲染 // // return this.users.length + &quot;个&quot;; // let count = 0; // for (let i = 0; i &lt;= this.num; i++) { // count += i; // } // return count; // }, // }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上面的代码，还是对原有的“列表渲染”内容进行更改。 第一：将users的值定义为空数组 第二：定义getUserList方法，在该方法中模拟异步操作，最终返回的是一个Promise对象。 第三：在created阶段调用getUserList方法来获取数据，将获取到的数据赋值给users这个状态数组，注意这里需要将created修改成async与await的形式。同时还要注意created的执行时机：组件实例已创建时，执行created方法。 现在已经对生命周期有了一个简单的了解，下面我们继续探讨生命周期的内容。 11、生命周期探讨在这一小节中，我们看一下vue生命周期中其它的一些钩子函数内容。 其实Vue实例的生命周期，主要分为三个阶段，分别为 挂载(初始化相关属性,例如watch属性，method属性) beforeCreate created beforeMount mounted 更新(元素或组件的变更操作) beforeUpdate updated 销毁（销毁相关属性） beforeDestroy destroyed 下面，我们再来看一道面试题： 关于Vue的生命周期，下列哪项是不正确的？()[单选题] A、Vue 实例从创建到销毁的过程，就是生命周期。 B、页面首次加载会触发beforeCreate, created, beforeMount, mounted, beforeUpdate, updated。 C、created表示完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来。 D、DOM渲染在mounted中就已经完成了。 分析： 选项A是没有问题的，Vue实例从创建到销毁的过程就是生命周期。 关于B选项，我们可以通过写一个程序来进行验证。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生命周期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;{{foo}}&lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, data: { foo: &quot;foo&quot;, }, beforeCreate() { console.log(&quot;beforCreate&quot;); }, created() { console.log(&quot;created&quot;); }, beforeMount() { console.log(&quot;beforeMount&quot;); }, mounted() { console.log(&quot;mounted&quot;); }, beforeUpdate() { console.log(&quot;beforeUpdate&quot;); }, updated() { console.log(&quot;updated&quot;); }, beforeDestroy() { console.log(&quot;beforeDestroy&quot;); }, destroyed() { console.log(&quot;destroyed&quot;); }, }); &lt;/script&gt; &lt;script&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们将所有的钩子函数都添加上了，然后打开浏览器，看下执行结果： beforCreate created beforeMount mounted 以上就是初次加载时所执行的钩子函数，并没有beforeUpdate 与updated,所以选项B是错误的。 那么beforeUpdate与updated什么时候会执行呢？是在，组件或者是元素更新的时候。 下面，我们来测试一下，看一下效果。 首先增加一个”更新”按钮 &lt;div id=&quot;app&quot;&gt; {{foo}} &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt; &lt;/div&gt; 对应的update方法的实现如下： methods: { update: function () { this.foo = &quot;hello&quot;; }, }, 在update方法中，修改了foo属性的值。打开浏览器，单击“更新”按钮后，看到的效果如下： beforeUpdate updated 通过以上的测试，可以验证在更新元素的时候，会执行在“更新”阶段的钩子函数。 下面，我们在测试一下，看一下“销毁”阶段的钩子函数的执行。 &lt;div id=&quot;app&quot;&gt; {{foo}} &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt; &lt;button @click=&quot;destroy&quot;&gt;销毁&lt;/button&gt; &lt;/div&gt; 在上面的代码中增加了一个销毁的按钮，对应的destroy方法的实现如下： methods: { update: function () { this.foo = &quot;hello&quot;; }, destroy: function () { //销毁资源 this.$destroy(); }, }, 在destroy方法中，调用了系统中的$destroy方法销毁了所有资源，这时会触发销毁阶段的钩子函数，所以这时会输出 beforeDestroy destroyed 这时，如果你去单击“更新”按钮，就会发现什么效果也没有了，也就是无法完成元素的更新了，因为元素已经被销毁了。 下面，我们通过官方的生命周期图来再次看一下整个生命周期的流程。也是为了看一下上面所出题的C和D的选项是说法否正确。 beforeCreate: Vue实例初始化之后，以及事件初始化，以及组件的父子关系确定后执行该钩子函数，一般在开发中很少使用 created: 在调用该方法之前，初始化会被使用到的状态，状态包括props,methods,data,computed,watch. 而且会实现对data中属性的监听，也就是在created的时候数据已经和data属性进行了绑定。(放在data中的属性当值发生改变的时候，视图也会改变)。同时也会对传递到组件中的数据进行校验。 所以在执行created的时候，所有的状态都初始化完成，我们也完全可以在该阶段发送异步的ajax请求，获取数据。 但是，在created方法中，是无法获取到对应的的$el选项,也就是无法获取Dom. 所以说上题中选项c的说法是正确的。 如下代码所示： created() { console.log(&quot;created&quot;); console.log(&quot;el===&quot;, this.$el);// undefined console.log(&quot;data==&quot;, this.$data);// 可以获取数据 console.log(&quot;foo==&quot;, this.foo);//可以获取数据 }, created方法执行完毕后，下面会判断对象中有没有el选项。如果有，继续执行下面的流程，也就是判断是否有template选项，如果没有el选项，则停止整个生命周期的流程，直到执行了vm.$mount(el) 后，才会继续向下执行生命周期的流程。 下面我们测试一下： &lt;script&gt; const vm = new Vue({ // el: &quot;#app&quot;, //去掉了el选项 data: { foo: &quot;fooData&quot;, }, methods: { update: function () { this.foo = &quot;hello&quot;; }, destroy: function () { //销毁资源 this.$destroy(); }, }, beforeCreate() { console.log(&quot;beforCreate&quot;); }, created() { console.log(&quot;created&quot;); console.log(&quot;el===&quot;, this.$el); console.log(&quot;data==&quot;, this.$data); console.log(&quot;foo==&quot;, this.foo); }, beforeMount() { console.log(&quot;beforeMount&quot;); }, mounted() { console.log(&quot;mounted&quot;); }, beforeUpdate() { console.log(&quot;beforeUpdate&quot;); }, updated() { console.log(&quot;updated&quot;); }, beforeDestroy() { console.log(&quot;beforeDestroy&quot;); }, destroyed() { console.log(&quot;destroyed&quot;); }, }); &lt;/script&gt; 在上面的代码中，我们将el选项去掉了，运行上面的代码后，我们发现执行完created方法后，整个流程就停止了。 现在，我们不添加el选项，但是手动执行vm.$mount(el),也能够使暂停的生命周期进行下去。 如下代码所示： &lt;script&gt; const vm = new Vue({ // el: &quot;#app&quot;,//去掉了el选项 data: { foo: &quot;fooData&quot;, }, methods: { update: function () { this.foo = &quot;hello&quot;; }, destroy: function () { //销毁资源 this.$destroy(); }, }, beforeCreate() { console.log(&quot;beforCreate&quot;); }, created() { console.log(&quot;created&quot;); console.log(&quot;el===&quot;, this.$el); console.log(&quot;data==&quot;, this.$data); console.log(&quot;foo==&quot;, this.foo); }, beforeMount() { console.log(&quot;beforeMount&quot;); }, mounted() { console.log(&quot;mounted&quot;); }, beforeUpdate() { console.log(&quot;beforeUpdate&quot;); }, updated() { console.log(&quot;updated&quot;); }, beforeDestroy() { console.log(&quot;beforeDestroy&quot;); }, destroyed() { console.log(&quot;destroyed&quot;); }, }); vm.$mount(&quot;#app&quot;);//添加了$mount方法 &lt;/script&gt; 运行上面的代码，可以看到，虽然vm对象中没有el参数，但是通过$mount(el)动态添加的方式，也能够使生命周期顺利进行。 我们继续向下看，就是判断在对象中是否有template选项。 第一：如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数，来完成渲染。 第二：如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高 第三：如果第一条,第二条件都不具备，则报错 下面，我们看一下添加template的情况。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生命周期2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, template: &quot;&lt;p&gt;Hello {{message}}&lt;/p&gt;&quot;, data: { message: &quot;vue&quot;, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 以上是在Vue实例中添加template的情况。 那么这里有一个比较有趣的问题就是，当模板同时放在template参数选项和外部HTML中，会出现什么情况呢？ 如下代码所示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;生命周期2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;你好&lt;/p&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, template: &quot;&lt;p&gt;Hello {{message}}&lt;/p&gt;&quot;, data: { message: &quot;vue&quot;, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们添加了template属性，同时也在外部添加了模板内容，但是最终在页面上显示的是Hello vue 而不是“你好”。就是因为template参数的优先级比外部HTML的优先级要高。 当然，我们在开发中，基本上都是使用外部的HTML模板形式，因为更加的灵活。 在这里，还需要你再次思考一个问题，就是为什么先判断 el 选项，然后在判断template选项呢？ 其实通过上面的总结，我们是可以完全总结出来的。 就是因为Vue需要通过el的“选择器”找到对应的template.也就是说，Vue首先通过el参数去查找对应的template.如果没有找到template参数，则到外部HTML中查找，找到后将模板编译成render 函数（Vue的编译实际上就是指Vue把模板编译成render函数的过程）。 下面，我们继续看一下生命周期的流程图。 接下来会触发beforeMount这个钩子函数： 在执行该钩子函数的时候，虚拟DOM已经创建完成，马上就要渲染了，在这里可以更改data中的数据，不会触发updated, 其实在created中也是可以更改数据，也不会触发updated函数 测试代码如下： beforeMount() { console.log(&quot;beforeMount&quot;); console.log(&quot;beforeMount el===&quot;, this.$el); console.log(&quot;data==&quot;, this.$data); //this.foo = &quot;abc&quot;; //修改数据 console.log(&quot;foo==&quot;, this.foo); }, 通过上面的代码，我们可以获取el中的内容，同时也可以修改数据。 但是，这里需要注意的输入的el中的内容，{{foo}}还没有被真正的数据替换掉。而且对应的内容还没有挂载到页面上。 下面执行了Create VM.$el and replace &quot;el&quot; with it 经过这一步后，在模板中所写的{{foo}}会被具体的数据所替换掉。 所以下面执行mounted的时候，可以看到真实的数据。同时整个组件内容已经挂载到页面中了，数据以及真实DOM都已经处理好了，可以在这里操作真实DOM了，也就是在mounted的时候，页面已经被渲染完毕了，在这个钩子函数中，我们可以去发送ajax请求。 mounted() { console.log(&quot;mounted&quot;); console.log(&quot;mounted el===&quot;, this.$el); console.log(&quot;data==&quot;, this.$data); console.log(&quot;foo==&quot;, this.foo); } 所以说，最开始的问题中，D选项：DOM渲染在mounted中就已经完成了这句话的描述也是正确的。 下面继续看生命周期的流程，如下图所示： 当整个组件挂在完成后，有可能会进行数据的修改，当Vue发现data中的数据发生了变化，会触发对应组件的重新渲染，先后调用了beforeUpdate 和updated钩子函数。 在updated之前beoreUpdate之后有一个非常重要的操作就是虚拟DOM会重新构建，也就是新构建的虚拟DOM与上一次的虚拟DOM树利用diff算法进行对比之后重新渲染。 而到了updated这个方法，就表示数据已经更新完成，dom也重新render完成。 下面如果我们调用了vm.$destroy方法后，就会销毁所有的资源。 ) 首先会执行beforeDestroy 这个钩子函数，这个钩子函数在实例销毁前调用，在这一步，实例仍然可用。 在该方法中，可以做一些清理的工作，例如：清除定时器等。 但是执行到destroyed钩子函数的时候，Vue实例已经被销毁，所有的事件监听器会被移除，所有的子实例也会被销毁。 最后做一个简单的总结： beforeCreate( )// 该钩子函数执行时，组件实例还未创建. created()//组件初始化完毕，各种数据可以使用，可以使用ajax发送异步请求获取数据 beforeMounted()// 未执行渲染，更新，虚拟DOM完成，真实DOM未创建 mounted()// 初始化阶段结束，真实DOM已经创建，可以发送异步请求获取数据,也可以访问dom元素 beforeUpdate()//更新前，可用于获取更新前各种状态数据 updated()//更新后执行该钩子函数，所有的状态数据是最新的。 beforeDestroy() // 销毁前执行，可以用于一些定时器的清除。 destroyed()//组件已经销毁，事件监听器被移除，所有的子实例也会被销毁。 以上为生命周期的内容。 12、组件化应用12.1 组件概述在这一小节中，重点要理解的就是组件的编程思想。 组件表示页面中的部分功能（包含自己的逻辑与样式），可以组合多个组件实现完整的页面功能。 如下图所示： 问题是，如何确定页面中哪些内容划分到一个组件中呢？ 但你如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑（函数的功能是单一的），根据[单一功能原则]来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。 当然，在上图中，我们发现’Name‘和’Price’ 表头 并没有单独的划分到一个组件中，主要考虑的是功能简单，就是展示的作用，所以没有划分到单独一个组件中。如果，该表头具有了一些比较复杂的功能，例如排序。那么这里可以单独的将表头内容划分到一个组件中。 组件有什么特点呢？ 可复用、维护、可组合 可复用：每个组件都是具有独立功能的，它可以被使用在多个场景中。 可组合：一个组件可以和其它的组件一起使用或者可以直接嵌套在另一个组件内部。 可维护：每个组件仅仅包含自身的逻辑，更容易被理解和维护。 下面，看一下怎样创建组件？ 12.2 组件的基本使用组件具体的创建过程如下： Vue.component('index', { template: '&lt;div&gt;我是首页的组件&lt;/div&gt;' }) 第一个参数指定了所创建的组件的名字，第二个参数指定了模板。 组件创建好以后，具体的使用方式如下： &lt;div id=&quot;app&quot;&gt; &lt;index&gt;&lt;/index&gt; &lt;/div&gt; 注意：1. 模板template中只能有一个根节点;2. 组件的名字，如果采用驼峰命令的话，在使用的时候，就要加上 “-”，比如组件名字叫indexA，那么在使用的时候就叫index-a。 例如： Vue.component('componentA', { template: &quot;&lt;div&gt;创建一个新的组件&lt;/div&gt;&quot; }) 组件的使用 &lt;component-a&gt;&lt;/component-a&gt; 在Vue实例中所使用的选项，在组件中都可以使用，但是要注意data,在组件中使用时必须是一个函数。 下面创建一个about组件。 Vue.component('about', { template: '&lt;div&gt;{{msg}}&lt;button @click=&quot;showMsg&quot;&gt;单击&lt;/button&gt;&lt;/div&gt;', data() { return { msg: '大家好' } }, methods: { showMsg() { this.msg = &quot;关于组件&quot; } } }) 组件的使用如下： &lt;about&gt;&lt;/about&gt; 在组件中关于data不是一个对象，而是一个函数的原因，官方文档有明确的说明 https://cn.vuejs.org/v2/guide/components.html 组件创建完整的代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;组件创建&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;index&gt;&lt;/index&gt; &lt;index&gt;&lt;/index&gt; &lt;about&gt;&lt;/about&gt; &lt;/div&gt; &lt;script&gt; Vue.component('componentA', { template: &quot;&lt;div&gt;创建一个新的组件&lt;/div&gt;&quot; }) Vue.component('index', { template: '&lt;div&gt;我是首页的组件&lt;/div&gt;' }) Vue.component('about', { template: '&lt;div&gt;{{msg}}&lt;button @click=&quot;showMsg&quot;&gt;单击&lt;/button&gt;&lt;/div&gt;', data() { return { msg: '大家好' } }, methods: { showMsg() { this.msg = &quot;关于组件&quot; } } }) var vm = new Vue({ el: '#app', data: { } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在使用组件的时候，需要注意以下几点内容： 第一点：data必须是一个函数 关于这一点，官方文档有比较详细清楚的说明：https://cn.vuejs.org/v2/guide/components.html 第二：组件模板中必须有一个跟元素。 第三：组件模板内容可以使用模板字符串。 Vue.component(&quot;about&quot;, { template: `&lt;div&gt; {{msg}} &lt;button @click='showMsg'&gt;单击 &lt;/button&gt; &lt;/div&gt;`, data() { return { msg: &quot;大家好&quot;, }; }, methods: { showMsg() { this.msg = &quot;关于VUE组件&quot;; }, }, }); 在上面的代码中，我们在组件的模板中使用类模板字符串，这样就可以调整对应的格式，例如换行等。 第四：现在我们创建的组件是全局组件，可以在其它组件中使用。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;组件基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;index&gt;&lt;/index&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;about&gt;&lt;/about&gt; &lt;!-- 使用HelloWorld组件 --&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;index&quot;, { template: &quot;&lt;div&gt;我是Index组件&lt;/div&gt;&quot;, }); // 创建了HelloWorld组件 Vue.component(&quot;HelloWorld&quot;, { data() { return { msg: &quot;Hello World&quot;, }; }, template: &quot;&lt;div&gt;{{ msg}}&lt;/div&gt;&quot;, }); // 使用HelloWorld组件 Vue.component(&quot;componentA&quot;, { template: &quot;&lt;div&gt;我是一个新的组件:&lt;HelloWorld&gt;&lt;/HelloWorld&gt;&lt;/div&gt;&quot;, }); Vue.component(&quot;about&quot;, { template: `&lt;div&gt; {{msg}} &lt;button @click='showMsg'&gt;单击 &lt;/button&gt; &lt;/div&gt;`, data() { return { msg: &quot;大家好&quot;, }; }, methods: { showMsg() { this.msg = &quot;关于VUE组件&quot;; }, }, }); const vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们又创建了一个HelloWorld组件，并且在componentA组件中去使用了HelloWorld组件，这里还需要注意的一点就是，在componentA这个组件中使用HelloWorld这个组件的时候，可以使用驼峰命名的方式，但是在&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;这个普通的标签模板中，必须使用短横线的方式，才能使用组件。 12.3 局部组件注册我们可以在一个组件中，再次注册另外一个组件，这样就构成了父子关系。 可以通过components 来创建对应的子组件。 组件的创建过程如下： &lt;script&gt; Vue.component('father', { template: '&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;', components: { // 创建一个子组件 son: { template: '&lt;p&gt;我是子组件&lt;/p&gt;' } } }) var vm = new Vue({ el: '#app', data: { } }) &lt;/script&gt; 组件的使用 &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;父子组件创建&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;script&gt; Vue.component('father', { template: '&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;', components: { // 创建一个子组件 son: { template: '&lt;p&gt;我是子组件&lt;/p&gt;' } } }) var vm = new Vue({ el: '#app', data: { } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们是在全局的father组件中，又创建了一个子组件son. 那么son这个子组件也就是一个局部的组件。也就是它只能在father组件中使用。 当然，我们在father中定义子组件son的时候，直接在其内部构件模板内容，这样如果代码非常多的时候，就不是很直观。 所以这里，我们可以将son组件，单独的进行定义，然后在father组件中进行注册。 改造后的代码如下所示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;局部组件&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;script&gt; const son = { data() { return { msg: &quot;Hello 我是子组件&quot;, }; }, template: `&lt;div&gt;{{msg}}&lt;/div&gt;`, }; Vue.component(&quot;father&quot;, { template: &quot;&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { // 创建一个子组件 // son: { // template: &quot;&lt;p&gt;我是子组件&lt;/p&gt;&quot;, // }, son: son, }, }); var vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们将son组件单独的进行了定义，这时注意写法，是一个对象的格式，在对象中包含了关于组件很重要的内容为data函数与template属性。 同时在father组件中通过components属性完成了对son组件的注册。 我们说过son组件是一个局部的组件，那么只能在其注册的父组件中使用。 现在，我们可以测试一下： 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;局部组件&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;!-- 使用ComponentA组件 --&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;/div&gt; &lt;script&gt; const son = { data() { return { msg: &quot;Hello 我是子组件&quot;, }; }, template: `&lt;div&gt;{{msg}}&lt;/div&gt;`, }; //定义ComponentA组件 Vue.component(&quot;ComponentA&quot;, { template: &quot;&lt;div&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, }); Vue.component(&quot;father&quot;, { template: &quot;&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { // 创建一个子组件 // son: { // template: &quot;&lt;p&gt;我是子组件&lt;/p&gt;&quot;, // }, son: son, }, }); var vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们又创建了一个全局的组件ComponentA,并且在该组件中使用了son组件，注意这里没有在ComponentA中使用components来注册son组件，而是直接使用。同时在&lt;div id='app'&gt;&lt;/div&gt;中使用了ComponentA组件。这时在浏览器中，打开上面的程序，会出现错误。 如果现在就想在ComponentA组件中使用son组件，就需要使用components来注册。 Vue.component(&quot;ComponentA&quot;, { template: &quot;&lt;div&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { son: son, }, }); 现在在ComponentA组件中已经注册了son组件，这时刷新浏览器就不会出错了。 在上面这些案例中，我们是在一个全局的组件中注册一个局部的组件，其实，我们也可以在Vue实例中， 注册对应的局部组件。因为，我们也可以将vue实例作为一个组件。 详细代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;局部组件&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;hello-msg&gt;&lt;/hello-msg&gt; &lt;/div&gt; &lt;script&gt; const son = { data() { return { msg: &quot;Hello 我是子组件&quot;, }; }, template: `&lt;div&gt;{{msg}}&lt;/div&gt;`, }; // 定义HelloMsg组件 const HelloMsg = { data() { return { msg: &quot;Hello World&quot;, }; }, template: `&lt;div&gt;{{msg}}&lt;/div&gt;`, }; Vue.component(&quot;ComponentA&quot;, { template: &quot;&lt;div&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { son: son, }, }); Vue.component(&quot;father&quot;, { template: &quot;&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { // 创建一个子组件 // son: { // template: &quot;&lt;p&gt;我是子组件&lt;/p&gt;&quot;, // }, son: son, }, }); var vm = new Vue({ el: &quot;#app&quot;, data: {}, components: { &quot;hello-msg&quot;: HelloMsg, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们又创建了一个组件HelloMsg 然后将HelloMsg组件注册到了 Vue实例中，注意：在进行注册的时候的语法格式。 左侧为组件的名称，由于这个组件创建的时候采用的是驼峰命名的方式，所以组件的名称采用短横线的方式。 右侧为组件的内容。 下面就可以在其&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;中使用了。 同理，在其他的组件中是无法使用HelloMsg组件的。 13、组件通信13.1 父组件向子组件传值当我们将整个页面都拆分了不同的组件以后，这样就会涉及到组件之间的数据传递问题。 常见的组件的通信可以分为三类： 第一类: 父组件向子组件传递数据 第二类: 子组件向父组件传递数据 第三类：兄弟组件的数据传递。 下面，我们先来看一下父组件向子组件传递数据的情况 第一：子组件内部通过props接收传递过来的值。 Vue.component('menu-item',{ props:['title'] // props后面跟一个数组，数组中的内容为字符串，这个字符串可以当做属性类使用。 template:'&lt;div&gt;{{title}}&lt;/div&gt;' }) 第二: 父组件通过属性将值传递给子组件 &lt;menu-item title=&quot;向子组件传递数据&quot;&gt; &lt;/menu-item&gt; &lt;menu-item :title=&quot;title&quot;&gt;&lt;/menu-item&gt; &lt;!--可以使用动态绑定的方式来传值--&gt; 下面看一下具体的案例演示： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;script&gt; // 创建一个父组件 Vue.component('father', { // 2、在使用子组件的地方，通过v-bind指令来给子组件中的props赋值。 template: '&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son :myName=&quot;mySonName&quot;&gt;&lt;/son&gt;&lt;/div&gt;', data() { return { mySonName: '小强' } }, components: { // 创建一个子组件 // 1.声明props,它的作用是：用来接收父组件传递过来的数据。 // props可以跟一个数组，数组里面的内容可以是字符串，这个字符串可以当属性来使用。 son: { props: ['myName'], template: '&lt;p&gt;我是子组件,我的名字叫{{myName}}&lt;/p&gt;' } } }) var vm = new new Vue({ el: '#app', data: { } }) &lt;/script&gt; &lt;/body&gt; 下面我们在看一个例子，这个例子是前面我们写的关于局部组件的案例，我们在这个案例的基础上实现组件的传值。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;局部组件&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;hello-msg title=&quot;你好&quot; :pcontent=&quot;content&quot;&gt;&lt;/hello-msg&gt; &lt;/div&gt; &lt;script&gt; const son = { data() { return { msg: &quot;Hello 我是子组件&quot;, }; }, template: `&lt;div&gt;{{msg}}&lt;/div&gt;`, }; // 定义HelloMsg组件 const HelloMsg = { props: [&quot;title&quot;, &quot;pcontent&quot;], data() { return { msg: &quot;Hello World&quot;, }; }, template: `&lt;div&gt;{{msg+'----------'+title+'-----------'+pcontent}}&lt;/div&gt;`, }; Vue.component(&quot;ComponentA&quot;, { template: &quot;&lt;div&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { son: son, }, }); Vue.component(&quot;father&quot;, { template: &quot;&lt;div&gt;&lt;p&gt;我是父组件&lt;/p&gt;&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&quot;, components: { // 创建一个子组件 // son: { // template: &quot;&lt;p&gt;我是子组件&lt;/p&gt;&quot;, // }, son: son, }, }); var vm = new Vue({ el: &quot;#app&quot;, data: { content: &quot;来自父组件中的内容&quot;, }, components: { &quot;hello-msg&quot;: HelloMsg, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们首先给hello-msg 这个组件传递了一个属性title,该属性的值是固定的。在对应的HelloMsg组件内容定义props,来接收传递过来的title属性的值。然后在template模板中展示title的值。 接下来，又在vue实例中指定了一个content的属性，下面要将该属性的值传递给HelloMsg组件。 &lt;hello-msg title=&quot;你好&quot; :pcontent=&quot;content&quot;&gt;&lt;/hello-msg&gt; 这里需要动态绑定的方式将content的值传递到HelloMsg组件。这里动态绑定的属性为pcontent,所以在HelloMsg组件内部，需要在props的数组中添加一个pcontent,最后在template模板中展示出pcontent的内容。 // 定义HelloMsg组件 const HelloMsg = { props: [&quot;title&quot;, &quot;pcontent&quot;], data() { return { msg: &quot;Hello World&quot;, }; }, template: `&lt;div&gt;{{msg+'----------'+title+'-----------'+pcontent}}&lt;/div&gt;`, }; 通过上面的案例，我们可以看到，在子组件中可以使用props来接收父组件中传递过来的数据。 但是，props在进行命名的时候，也是有一定的规则的。 如果在props中使用驼峰形式，模板中需要短横线的形式，如下代码案例所示： Vue.component('menu-item',{ //在JavaScript中是驼峰形式 props:['menuTitle'], template:'&lt;div&gt;{{menuTitle}}&lt;/div&gt;' }) &lt;!--在html中是短横线方式---&gt; &lt;menu-item menu-title=&quot;hello world&quot;&gt;&lt;/menu-item&gt; 下面看一下具体的代码演示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;组件传值&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;menu-item :menu-title=&quot;ptitle&quot;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;menu-item&quot;, { props: [&quot;menuTitle&quot;], template: `&lt;div&gt;来自{{menuTitle}}&lt;/div&gt;`, }); const vm = new Vue({ el: &quot;#app&quot;, data: { ptitle: &quot;父组件中的数据&quot;, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面再来看一下props属性值的类型。 props 可以接收各种类型的值。 如下： 字符串（String） 数值(Number) 布尔值(Boolean) 数组(Array) 对象(Object) 下面，将上面的类型都演示一下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;props类型&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;menu-item :str=&quot;str&quot; :num=&quot;10&quot; b=&quot;true&quot; :marr=&quot;arr&quot; :obj=&quot;obj&quot; &gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;menu-item&quot;, { props: [&quot;str&quot;, &quot;num&quot;, &quot;b&quot;, &quot;marr&quot;, &quot;obj&quot;], template: `&lt;div&gt; &lt;div&gt;{{str}}&lt;/div&gt; &lt;div&gt;{{typeof num}}&lt;/div&gt; &lt;div&gt;{{typeof b}}&lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li :key=item.id v-for='item in marr'&gt;{{item.userName}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; 姓名： {{obj.name}} 年龄:{{obj.age}} &lt;/div&gt; &lt;/div&gt;`, }); const vm = new Vue({ el: &quot;#app&quot;, data: { str: &quot;hello&quot;, arr: [ { id: 1, userName: &quot;zhangsan&quot; }, { id: 2, userName: &quot;lisi&quot;, }, ], obj: { name: &quot;wangwu&quot;, age: 18, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，向menu-item组件中传递了各种类型的数据。 注意： &lt;menu-item :str=&quot;str&quot; :num=&quot;10&quot; b=&quot;true&quot; :marr=&quot;arr&quot;&gt;&lt;/menu-item&gt; 在上面的代码中，:num=&quot;10&quot;表示传递的是数字，如果写成num='10' 表示传递的是字符， 同理b=&quot;true&quot;传递的是字符，如果修改成:b=true表示传递的是布尔类型。 最后还传递了数组类型与对象类型的内容。 13.2 子组件向父组件传值 第一：子组件通过自定义事件向父组件传递信息。 &lt;button v-on:click='$emit(&quot;countSum&quot;)'&gt; 计算&lt;/button&gt; 第二：父组件监听子组件的事件 &lt;menu-item v-on:countSum='sum+=1'&gt;&lt;/menu-item&gt; 具体的实现步骤如下： 1、构建基本的结构 &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { } }) 2、构建相应的父组件。 Vue.component('father', { template: '&lt;div&gt;我的儿子叫{{mySonName}}&lt;/div&gt;', data() { return { mySonName: '' } } } 3、 构建相应的子组件, 并且单击子组件中的按钮给父组件传值。 Vue.component('father', { template: '&lt;div&gt;我的儿子叫{{mySonName}}&lt;/div&gt;', data() { return { mySonName: '' } }, components: { son: { data() { return { myName: '小强' } }, template: '&lt;button @click=&quot;emitMyName&quot;&gt;我叫{{myName}}&lt;/button&gt;', methods: { emitMyName() { // 子组件传值给父组件需要用到$emit()方法，这个方法可以传递两个参数，一个是事件名称，一个是需要传递的数据 this.$emit('tellMyFatherMyName', this.myName) } } } } } 4、父组件接收子组件传递过来的数据。 注意在父组件中引用子组件，同时指定在子组件中定义的事件。 Vue.component('father', { template: '&lt;div&gt;我的儿子叫{{mySonName}}&lt;son @tellMyFatherMyName=&quot;getMySonName&quot;&gt;&lt;/son&gt;&lt;/div&gt;', data() { return { mySonName: '' } }, methods: { getMySonName(data) { this.mySonName = data; } } } 5、组件使用 &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; 6、完整代码如下： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;script&gt; Vue.component('father', { template: '&lt;div&gt;我的儿子叫{{mySonName}}&lt;son @tellMyFatherMyName=&quot;getMySonName&quot;&gt;&lt;/son&gt;&lt;/div&gt;', data() { return { mySonName: '' } }, methods: { getMySonName(data) { this.mySonName = data; } }, components: { son: { data() { return { myName: '小强' } }, template: '&lt;button @click=&quot;emitMyName&quot;&gt;我叫{{myName}}&lt;/button&gt;', methods: { emitMyName() { // 子组件传值给父组件需要用到$emit()方法，这个方法可以传递两个参数，一个是事件名称，一个是需要传递的数据 this.$emit('tellMyFatherMyName', this.myName) } } } } }) var vm = new new Vue({ el: '#app', data: { } }) &lt;/script&gt; &lt;/body&gt; 13.3 兄弟组件之间数据传递兄弟组件传值，通过事件总线完成。 1、定义父组件并且在父组件中，完成两个兄弟组件的创建。 &lt;script&gt; Vue.component('father', { template: '&lt;div&gt;&lt;son&gt;&lt;/son&gt;&lt;daughter&gt;&lt;/daughter&gt;&lt;/div&gt;', components: { son: { data() { return { mySisterName: '' } }, template: '&lt;div&gt;我妹妹叫{{mySisterName}}&lt;/div&gt;' }, daughter: { data() { return { myName: '小雪' } }, template: '&lt;button @click=&quot;emitMyName&quot;&gt;告诉哥哥我叫{{myName}}&lt;/button&gt;', methods: { emitMyName() { } } } } }) var vm = new Vue({ el: '#app', data: { } }) &lt;/script&gt; 2、创建事件总线 通过事件总线发射一个事件名称和需要传递的数据 。 // 创建一个空的vue实例，作为事件总线 var eventbus = new Vue() daughter: { data() { return { myName: '小雪' } }, template: '&lt;button @click=&quot;emitMyName&quot;&gt;告诉哥哥我叫{{myName}}&lt;/button&gt;', methods: { emitMyName() { // 通过事件总线发射一个事件名称和需要传递的数据 eventbus.$emit('tellBroMyName', this.myName) } } } 3、通过eventbus的$on()方法去监听兄弟节点发射过来的事件 son: { data() { return { mySisterName: '' } }, template: '&lt;div&gt;我妹妹叫{{mySisterName}}&lt;/div&gt;', mounted() { // 通过eventbus的$on()方法去监听兄弟节点发射过来的事件 // $on有两个参数，一个是事件名称，一个是函数，该函数的默认值就是传递过来的数据 eventbus.$on('tellBroMyName', data =&gt; { this.mySisterName = data }) } }, 4、组件的使用 &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; 5、完整的代码如下： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;script&gt; // 创建一个空的vue实例，作为事件总线 var eventbus = new Vue() Vue.component('father', { template: '&lt;div&gt;&lt;son&gt;&lt;/son&gt;&lt;daughter&gt;&lt;/daughter&gt;&lt;/div&gt;', components: { son: { data() { return { mySisterName: '' } }, template: '&lt;div&gt;我妹妹叫{{mySisterName}}&lt;/div&gt;', mounted() { // 通过eventbus的$on()方法去监听兄弟节点发射过来的事件 // $on有两个参数，一个是事件名称，一个是函数，该函数的默认值就是传递过来的数据 eventbus.$on('tellBroMyName', data =&gt; { this.mySisterName = data }) } }, daughter: { data() { return { myName: '小雪' } }, template: '&lt;button @click=&quot;emitMyName&quot;&gt;告诉哥哥我叫{{myName}}&lt;/button&gt;', methods: { emitMyName() { // 通过事件总线发射一个事件名称和需要传递的数据 eventbus.$emit('tellBroMyName', this.myName) } } } } }) var vm = new Vue({ el: '#app', data: { } }) &lt;/script&gt; &lt;/body&gt; 14、组件插槽应用14.1 插槽基本使用生活中的插槽 其实我们生活中有很多很多的插槽。比如电脑的USB插槽、插板中的电源插槽等等。每个插槽都有它们之间的价值。比如电脑的USB插槽，可以用来插U盘，链接鼠标，链接手机、音响等等，通过这些插槽，大大拓展了原有设备的功能。 组件中的插槽 组件中的插槽，让使用者可以决定组件内部的一些内容到底展示什么，也就是，插槽可以实现父组件向子组件传递模板内容。具有插槽的组件将会有更加强大的拓展性， 下面看一个实际应用的例子来体会一下插槽的引用场景。 三个页面中都有导航栏，基本结构都是一样的：左中右分别有一个东西，只是显示的内容不同而已。那我们如何来实现这种结构相似但是内容不同呢？ 你一定是想着，直接定义三个组件，然后在模板中分别显示不同的内容，对不对？恭喜你，你就快要被炒了。 首先，如果我们封装成三个组件，显然不合适，比如每个页面都有返回，这部分的内容我们就要重复去封装 其次，如果我们封装成一个，还是不合理，因为有些左侧是菜单栏，有些中间是搜索框，有些是文字。 那我们该怎么办呢？其实很简单，用组件插槽。 上面最佳的解决办法是将共性抽取到组件中，将不同暴露给插槽，一旦我们使用了插槽，就相当于预留了空间，空间的内容取决于使用者 如下图所示： 通过上图，我们可以在父组件中使用子组件，同时由于在子组件中创建插槽slot，也就是相当于预留了空间，这时在父组件中使用子组件时，可以传递不同的内容。 下面看一下插槽的应用 基本使用方式 第一：确定插槽的位置 Vue.component('alert-box',{ template:` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;子组件&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; ` }) 在子组件中，通过&lt;slot&gt;确定出插槽的位置。 第二：插槽内容 &lt;alert-box&gt;Hello World&lt;/alert-box&gt; 向插槽中传递内容。 下面看一下具体的代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;插槽基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;alert-box&gt;程序出现了bug&lt;/alert-box&gt; &lt;alert-box&gt;程序出现了警告&lt;/alert-box&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;alert-box&quot;, { template: ` &lt;div&gt; &lt;strong&gt;ERROR:&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过上面的代码我们可以看到，在alert-box这个组件中，定义了一个插槽，也就是预留了一个位置，下面使用该组件的时候，都可以向该插槽中传递数据。而&lt;strong&gt;标签中的内容就相当于是一个公共的内容了。 当然在插槽中也是可以添加默认的内容的。 &lt;div id=&quot;app&quot;&gt; &lt;alert-box&gt;程序出现了bug&lt;/alert-box&gt; &lt;alert-box&gt;程序出现了警告&lt;/alert-box&gt; &lt;alert-box&gt;&lt;/alert-box&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;alert-box&quot;, { template: ` &lt;div&gt; &lt;strong&gt;ERROR:&lt;/strong&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; 在上面的代码中，我们给插槽添加了默认的内容，如果在使用alert-box组件的时候，没有给插槽传递值，就会展示插槽中的默认内容。 14.2 具名插槽所谓的具名插槽就是有名字的插槽。 第一：插槽定义 &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; 第二：插槽内容 &lt;base-layout&gt; &lt;h1 slot=&quot;header&quot;&gt; 标题内容&lt;/h1&gt; &lt;p&gt; 主要内容 &lt;/p&gt; &lt;p&gt; 主要内容 &lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt; 底部内容 &lt;/p&gt; &lt;/base-layout&gt; 下面我们来看一下具体的代码实现 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;具名插槽&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;base-layout&gt; &lt;p slot=&quot;header&quot;&gt;头部内容&lt;/p&gt; &lt;p&gt;主要内容1&lt;/p&gt; &lt;p&gt;主要内容2&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;底部信息&lt;/p&gt; &lt;/base-layout&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;base-layout&quot;, { template: ` &lt;div&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中， &lt;p slot=&quot;header&quot;&gt;头部内容&lt;/p&gt;会插入到base-layout 组件的header这个插槽中。 &lt;p slot=&quot;footer&quot;&gt;底部信息&lt;/p&gt;会插入到footer这个插槽中。 剩余的内容会插入到默认的（没有名称）的插槽内。 在上面的应用中，有一个问题就是，我们把插槽的名称给了某个html标签，例如p标签，这样就只能将该标签插入到插槽中。 但是，在实际的应用中，有可能需要向插槽中插入大量的内容，这时就需要用到template标签。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;具名插槽&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;base-layout&gt; &lt;p slot=&quot;header&quot;&gt;头部内容&lt;/p&gt; &lt;p&gt;主要内容1&lt;/p&gt; &lt;p&gt;主要内容2&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;底部信息&lt;/p&gt; &lt;/base-layout&gt; --&gt; &lt;base-layout&gt; &lt;template slot=&quot;header&quot;&gt; &lt;div&gt;标题名称&lt;/div&gt; &lt;div&gt;标题区域的布局&lt;/div&gt; &lt;/template&gt; &lt;div&gt; 中间内容区域的布局实现 &lt;/div&gt; &lt;template slot=&quot;footer&quot;&gt; &lt;div&gt;底部信息&lt;/div&gt; &lt;div&gt;对底部内容区域进行布局&lt;/div&gt; &lt;/template&gt; &lt;/base-layout&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;base-layout&quot;, { template: ` &lt;div&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们给template标签添加了插槽的名称，并且在template标签中嵌入了其它的多个标签，从而完成布局。 在这里，可以统一查看浏览器端所生成的代码结构。 14.3 作用域插槽应用场景：父组件对子组件的内容进行加工处理。这也是作用域插槽的一个很重要特性， 下面我们通过一个例子来体会一下这句话的作用。 首先，我们先创建一个用户列表。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;作用域插槽&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;user-list :list=&quot;userList&quot;&gt;&lt;/user-list&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;user-list&quot;, { props: [&quot;list&quot;], template: `&lt;div&gt; &lt;ul&gt; &lt;li :key=&quot;item.id&quot; v-for='item in list'&gt;{{item.userName}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;`, }); const vm = new Vue({ el: &quot;#app&quot;, data: { userList: [ { id: 1, userName: &quot;张三&quot;, }, { id: 2, userName: &quot;李四&quot;, }, { id: 3, userName: &quot;王五&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们首先创建了一个user-list组件，在这个组件中接收父组件传递过来的用户数据，通过循环的方式展示传递过来的用户数据。 现在，这里有一个新的需求，就是修改某个用户名的颜色，让其高亮显示。这个需求应该怎样来处理呢？ 我们是否可以在子组件user-list中实现这个功能呢？ 虽然可以，但是一般不建议你这么做，因为一个组件创建好以后，一般不建议修改。你可以想一下，如果这个组件是其它人创建的，而且很多人都在用，如果直接修改这个子组件，就会造成很多的问题。 所以这里，还是从父组件中进行修改。也是通过父组件来决定子组件中的哪个用户名进行高亮显示。 下面对代码进行修改： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;作用域插槽&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;user-list :list=&quot;userList&quot;&gt; &lt;template slot-scope=&quot;slotProps&quot;&gt; &lt;strong v-if=&quot;slotProps.info.id===2&quot; &gt;{{slotProps.info.userName}}&lt;/strong &gt; &lt;span v-else&gt;{{slotProps.info.userName}}&lt;/span&gt; &lt;/template&gt; &lt;/user-list&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;user-list&quot;, { props: [&quot;list&quot;], template: `&lt;div&gt; &lt;ul&gt; &lt;li :key=&quot;item.id&quot; v-for='item in list'&gt; &lt;slot :info=&quot;item&quot;&gt; {{item.userName}} &lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;`, }); const vm = new Vue({ el: &quot;#app&quot;, data: { userList: [ { id: 1, userName: &quot;张三&quot;, }, { id: 2, userName: &quot;李四&quot;, }, { id: 3, userName: &quot;王五&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过上面的代码可以看到，为了能够实现父组件决定子组件中哪个用户名能够高亮显示，需要在设计子组件的时候，为其添加对应的插槽。 template: `&lt;div&gt; &lt;ul&gt; &lt;li :key=&quot;item.id&quot; v-for='item in list'&gt; &lt;slot :info=&quot;item&quot;&gt; {{item.userName}} &lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;`, 在子组件的template模板中，添加了插槽，同时为其动态绑定一个属性info(这个属性的名字是可以随意命名的)，该属性的值为用户的信息。 绑定该属性的目的就是为了能够在父组件中获取用户的信息。 下面看一下父组件中的修改 &lt;div id=&quot;app&quot;&gt; &lt;user-list :list=&quot;userList&quot;&gt; &lt;template slot-scope=&quot;slotProps&quot;&gt; &lt;strong v-if=&quot;slotProps.info.id===2&quot; &gt;{{slotProps.info.userName}}&lt;/strong &gt; &lt;span v-else&gt;{{slotProps.info.userName}}&lt;/span&gt; &lt;/template&gt; &lt;/user-list&gt; &lt;/div&gt; 父组件在使用子组件user-list的时候，这里为其添加了template这个标签，而且这个标签的属性slot-scope是固定的，为其指定了一个值为slotProps,该值中，存储的就是从子组件中获取到的用户数据。 所以接下来通过slotProps获取info（注意这里要与子组件中的slot属性保持一致）中的用户数据。然后进行判断，如果用户编号为2的，为其加错，否者正常展示。 通过以上的案例，我们可以看到父组件通过作用域插槽实现了对子组件中数据的处理。其实这也就是为什么叫做作用域插槽的原因： 是因为模板虽然是在父级作用域（父组件）中渲染的，却能拿到子组件的数据。 14.4. 作用域插槽案例下面，我们通过一个列表的案例，来体会一下作用域插槽的应用。 首先我们先来做一个基本的列表组件 这里，我们首先使用的是具名插槽完成的，如下代码所示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;作用域插槽案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;my-list&gt; &lt;template slot=&quot;title&quot;&gt; 用户列表 &lt;/template&gt; &lt;template slot=&quot;content&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in listData&quot; :key=&quot;item.id&quot;&gt;{{item.userName}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/my-list&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;my-list&quot;, { template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;list-title&quot;&gt; &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;list-content&quot;&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: { listData: [ { id: 1, userName: &quot;张三&quot; }, { id: 2, userName: &quot;李四&quot;, }, { id: 3, userName: &quot;王五&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们在子组件my-list中使用了具名插槽。然后父组件在使用子组件my-list的时候，可以通过template标签加上slot属性向具名插槽中传递数据。 虽然以上的写法满足了基本的需求，但是作为组件的使用者，这样的一个组件会让我们感觉非常的麻烦，也就是我们在使用my-list这个组件的时候，还需要自己去编写content区域的循环逻辑。这样就比较麻烦了，下面对上面的代码在做一些修改。 为了解决这个问题，我们可以把循环写到子组件中，这样我们在使用的时候，不需要写循环了，只是传递数据就可以了，这样就方便多了。其实这里我们就可以不用具名插槽了。 所以修改后的代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;作用域插槽案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;my-list title=&quot;用户列表&quot; :content=&quot;listData&quot;&gt; &lt;/my-list&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;my-list&quot;, { props: [&quot;title&quot;, &quot;content&quot;], template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;list-title&quot;&gt; {{title}} &lt;/div&gt; &lt;div class=&quot;list-content&quot;&gt; &lt;ul class=&quot;list-content&quot;&gt; &lt;li v-for=&quot;item in content&quot; :key=&quot;item.id&quot;&gt;{{item.userName}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: { listData: [ { id: 1, userName: &quot;张三&quot; }, { id: 2, userName: &quot;李四&quot;, }, { id: 3, userName: &quot;王五&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们没有使用插槽，直接将数据传递到子组件my-list中，然后在该子组件中接收到数据，并进行了循环遍历。 经过这一次的改造，满足了我们前面所提到的易用性问题，但是现在又有了新的问题，组件的拓展性不好。 每次只能生成相同结构的列表，一旦业务需要发生了变化，组件就不再使用了。比如，我现在有了新的需求，在一个列表的每个列表项前面加上一个小的logo,我总不能又写一个新的组件来适应需求的变化吧？ 这里就可以使用作用域插槽来解决这个问题。 具体的实现代码如下所示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;作用域插槽案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 如果没有传递模板，那么子组件的插槽中只会展示用户名 --&gt; &lt;my-list title=&quot;用户列表&quot; :content=&quot;listData&quot;&gt;&lt;/my-list&gt; &lt;!-- 传递模板 --&gt; &lt;my-list title=&quot;用户列表2&quot; :content=&quot;listData&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;img src=&quot;./one.png&quot; width=&quot;20&quot;/&gt; &lt;span&gt;{{scope.item.userName}}&lt;/span&gt; &lt;/template&gt; &lt;/my-list&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&quot;my-list&quot;, { props: [&quot;title&quot;, &quot;content&quot;], template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;list-title&quot;&gt; {{title}} &lt;/div&gt; &lt;div class=&quot;list-content&quot;&gt; &lt;ul class=&quot;list-content&quot;&gt; &lt;li v-for=&quot;item in content&quot; :key=&quot;item.id&quot;&gt; &lt;!--这里将content中的每一项数据绑定到slot的itemb变量上，在父组件中就可以获取到item变量--&gt; &lt;slot :item=&quot;item&quot;&gt;{{item.userName}}&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; `, }); const vm = new Vue({ el: &quot;#app&quot;, data: { listData: [ { id: 1, userName: &quot;张三&quot; }, { id: 2, userName: &quot;李四&quot;, }, { id: 3, userName: &quot;王五&quot;, }, ], }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们首先在子组件my-list中，添加了作用域的插槽。 &lt;ul class=&quot;list-content&quot;&gt; &lt;li v-for=&quot;item in content&quot; :key=&quot;item.id&quot;&gt; &lt;!--这里将content中的每一项数据绑定到slot的itemb变量上，在父组件中就可以获取到item变量--&gt; &lt;slot :item=&quot;item&quot;&gt;{{item.userName}}&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; 同时在父组件中，使用对应的插槽 &lt;div id=&quot;app&quot;&gt; &lt;!-- 如果没有传递模板，那么子组件的插槽中只会展示用户名 --&gt; &lt;my-list title=&quot;用户列表&quot; :content=&quot;listData&quot;&gt;&lt;/my-list&gt; &lt;!-- 传递模板 --&gt; &lt;my-list title=&quot;用户列表2&quot; :content=&quot;listData&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;img src=&quot;./one.png&quot; width=&quot;20&quot;/&gt; &lt;span&gt;{{scope.item.userName}}&lt;/span&gt; &lt;/template&gt; &lt;/my-list&gt; &lt;/div&gt; 再回到开始的问题，作用域插槽到底是干嘛用的？很显然，它的作用就如官网所说的一样：将组件的数据暴露出去。而这么做，给了组件的使用者根据数据定制模板的机会，组件不再是写死成一种特定的结构。 以上就是作用域插槽的应用，需要你仔细体会。 那么，在这里再次问一个问题，就是在你所使用的Vue插件或者是第三方的库中，有没有遇到使用作用域插槽的情况呢？ 其实，比较典型的就是element-ui的table组件，它就可以通过添加作用域插槽改变渲染的原始数据。 如下图所示： 14.5 插槽应用总结 为什么要使用插槽 组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力。 组件的复用性常见情形如在有相似功能的模块中，他们具有类似的UI界面，通过使用组件间的通信机制传递数据，从而达到一套代码渲染不同数据的效果。 然而这种利用组件间通信的机制只能满足在结构上相同，渲染数据不同的情形；假设两个相似的页面，他们只在某一模块（区域）有不同的UI效果(例如，前面所做的列表，发现可以显示不同的ui效果)，以上办法就做不到了。可能你会想，使用 v-if 和 v-else来特殊处理这两个功能模块，不就解决了？很优秀，解决了，但不完美。极端一点，假设我们有一百个这种页面，就需要写一百个v-if、v-else-if、v-else来处理？那组件看起来将不再简小精致，维护起来也不容易。 而 插槽 “**SLOT**”就可以完美解决这个问题 什么情况下使用插槽 顾名思义，插槽即往卡槽中插入一段功能块。还是举刚才的例子。如果有一百个基本相似，只有一个模块功能不同的页面，而我们只想写一个组件。可以将不同的那个模块单独处理成一个卡片，在需要使用的时候将对应的卡片插入到组件中即可实现对应的完整的功能页。而不是在组件中把所有的情形用if-else罗列出来（这里还是体会用户列表的案例） 可能你会想，那我把一个组件分割成一片片的插槽，需要什么拼接什么，岂不是只要一个组件就能完成所有的功能？思路上没错，但是需要明白的是，卡片是在父组件上代替子组件实现的功能，使用插槽无疑是在给父组件页面增加规模，如果全都使用拼装的方式，和不用组件又有什么区别（例如，用户列表案例中需要其他的显示方式，需要在父组件中进行添加）。因此，插槽并不是用的越多越好。 插槽是组件最大化利用的一种手段，而不是替代组件的策略，当然也不能替代组件。如果能在组件中实现的模块，或者只需要使用一次v-else， 或一次v-else-if，v-else就能解决的问题，都建议直接在组件中实现。 15、Vue组件化的理解关于Vue组件的内容，我们已经学习很多了，那么你能谈一下对Vue组件化的理解吗？ 其实这也是一个比较常见的面试题。 当然，这个问题的面是非常广的。可以通过以下几点来描述： 定义：组件是可复用的Vue实例，准确讲它是VueComponent的实例，继承自Vue 优点：组件化可以增加代码的复用性，可维护性和可测试性。 使用场景：什么时候使用组件？以下分类可以作为参数 第一：通用组件：实现最基本的功能，具有通用性，复用性。例如按钮组件，输入框组件，布局组件等。(Element UI组件库就是属于这种通用的组件) 第二：业务组件，用于完成具体的业务，具有一定的复用性。例如登录组件，轮播图组件。 第三：页面组件，组织应用各部分独立内容，需要时在不同页面组件间切换，例如：商品列表页，详情页组件。 如何使用组件 定义：Vue.component()，components选项 分类：有状态组件(有data属性)，functional 通信：props，$emit()/$on()，provide/inject 内容分发：&lt;slot&gt;，&lt;template&gt;，v-slot 使用及优化：is，keep-alive，异步组件(这些内容在后面的课程中会详细的讲解) 组件的本质 vue中的组件经历如下过程 组件配置 =&gt; VueComponent实例 =&gt; render() =&gt; Virtual DOM=&gt; DOM所以组件的本质是产生虚拟DOM 关于这块内容，在后面的课程中还会深入的探讨，包虚拟dom,以及vue的源码。 16、常用API说明16.1 Vue.set向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且会触发视图更新。 使用方法：Vue.set(target,propertyName,value) 下面通过一个案例来演示一下,这个案例是在以前所做的用户列表的案例上进行修改的， 这里需求是给每个用户动态的添加身高。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { selectItem: &quot;&quot;, num: 100, totalCount: 0, users: [], }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { c.height = 0; }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我首先把列表中，展示的内容做了一个修改，这里不在显示索引值，而是展示身高。 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} 但是我们知道在users中是没有height这个属性的，所以下面可以动态添加这个属性。 所以在create方法中，调用了batchUpdate方法，来动态更新。 //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, 在methods中，添加了batchUpdate方法。 //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { c.height = 0; }); }, 在上面的代码中，对users进行遍历，每遍历一次，取出一个对象后，动态添加一个属性height,并且初始值为0. 这样刷新浏览器，可以看到对应的效果。 下面，我们在做一个功能，就是用户在一个文本框中，输入一个身高值，单击按钮，统一把所有用户的身高进行更新。 首先在data中添加一个属性height,该属性会与文本框进行绑定。 data: { selectItem: &quot;&quot;, num: 100, totalCount: 0, users: [], height: 0, }, 下面创建文本框，以及更新按钮 &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; 在这里我们需要在文本框中输入的值为数字类型，所以添加了一个number的后缀。现在，文本框与height属性绑定在一起了。下面单击按钮后，还是去执行batchUpdate方法。 //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { c.height = this.height; }); }, 这里我们可以看到，我们是用文本框中输入的值，更新了users数组中的height属性的值。 但是，当我们在浏览器中，单击按钮进行更新的时候，发现不起作用。 因为，现在动态所添加的height属性并不是响应式的。 但是，当把鼠标移动到列表项的时候，数据发生了变化，就是因为这时触发了我们给列表所添加的mousemove 这个事件，导致页面重新刷新，这时发现数据发生变化了。 那么我们应该怎样解决这个问题呢？ 这就需要，在batchUpdate方法中，使用Vue.set()方法 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; Vue.set(c, &quot;height&quot;, this.height); }); }, 修改的代码含义就是通过Vue.set方法，给users数组中每个对象，设置一个height属性，这时该属性就变成了响应式的，同时把 data中的height属性的值赋值给height. 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { selectItem: &quot;&quot;, num: 100, totalCount: 0, users: [], height: 0, }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 16.2 Vue.delete 删除对象的属性，如果对象是响应式的，确保删除能触发更新视图。 使用方式：Vue.delete(target,propertyName) 如果使用delete obj['property'] 是不能更新页面的。 以上两个方法Vue.set()和Vue.delete()等同于以下两个实例方法。 vm.$set() vm.$delete() vm 表示的是Vue的实例。 所以我们在batchUpdate中也可以采用如下的方式，来批量更新用户的身高数据。 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, 16.3 vm.$on与vm.$emit16.3.1 列表组件设计这两个api在前面的课程中，我们也已经讲解过，主要用来实现:事件总线。 下面，我们将这两个API应用到用户列表这个案例中。主要是把事件总线这个应用再次复习一下。 当然，这里首先是把用户列表这个案例，按照我们前面所学习的组件的知识，进行拆分一下，实现组件化的应用。 初步改造后的代码，如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 用户列表组件创建 Vue.component(&quot;user-list&quot;, { data() { return { selectItem: &quot;&quot;, }; }, props: { users: { type: Array, default: [], }, }, template: ` &lt;div&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, }); new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们首先创建了一个user-list组件，该组件首先会通过props接收传递过来的用户数据。 在这里我们将props定义成了对象的形式，这样更容易进行数据类型的校验，同时还可以设置默认值。 接下来将原来定义在&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 中的用户列表，要剪切到user-list组件的template属性中，同时，我们知道在列表中会用到selectItem属性，所以在user-list的data中定义该属性，父组件就不用在定义该属性了。 下面，我们在&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;中使用该组件,并且传递了用户数据。 &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; 现在用户列表的组件，在这里我们就创建好了。 16.3.2 用户添加组件设计下面我们在创建一个组件，该组件封装了一个文本框和添加用户信息的按钮。 代码如下： //新增用户组件 Vue.component(&quot;user-add&quot;, { data() { return { userInfo: &quot;&quot;, }; }, template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model=&quot;userInfo&quot; v-on:keydown.enter=&quot;addUser&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. this.$emit(&quot;add-user&quot;, this.userInfo); this.userInfo = &quot;&quot;; }, }, }); 在上面的代码中，我们创建了user-add 这个组件，该组件最终呈现的就是就是一个文本框与一个添加按钮。并且通过v-model将userInfo属性与文本框进行了绑定。同时，单击按钮的时候，执行addUser方法，在该方法中，通过$emit想父组件发送了一个事件，同时将用户在文本框中输入的数据也传递过去。 然后清空文本框， 下面看一下父组件的处理。 &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot;&gt;&lt;/user-add&gt; 在&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 中使用user-add这个组件，同时接受传递过来的事件add-user,然后执行addUser方法。 下面看一下addUser这个方法的具体实现。 在vue 实例的methods属性中，添加addUser这个方法。 //添加用户的信息 addUser(userInfo) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: userInfo, }); }, 接受用户在文本框中输入的数据，然后添加到users数组中。 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot;&gt;&lt;/user-add&gt; &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //新增用户组件 Vue.component(&quot;user-add&quot;, { data() { return { userInfo: &quot;&quot;, }; }, template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model=&quot;userInfo&quot; v-on:keydown.enter=&quot;addUser&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. this.$emit(&quot;add-user&quot;, this.userInfo); this.userInfo = &quot;&quot;; }, }, }); // 用户列表 Vue.component(&quot;user-list&quot;, { data() { return { selectItem: &quot;&quot;, }; }, props: { users: { type: Array, default: [], }, }, template: ` &lt;div&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, }); new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //添加用户的信息 addUser(userInfo) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: userInfo, }); }, //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 16.3.3 自定义组件实现双向绑定在上一个案例中，我们创建了一个user-add这个组件，完成用户信息的添加。 并且在该组件的内部，维护了所添加的用户信息。 假如，我不想让user-add这个组件来维护这个用户信息，而是让父组件来维护，应该怎样处理呢？ &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot; v-model=&quot;userInfo&quot;&gt;&lt;/user-add&gt; 将userInfo的值给v-model. 所以在父组件中要定义userInfo new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, }, 下面看一下user-add组件的修改 Vue.component(&quot;user-add&quot;, { // data() { // return { // userInfo: &quot;&quot;, // }; // }, props: [&quot;value&quot;], template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-on:keydown.enter=&quot;addUser&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. // this.$emit(&quot;add-user&quot;, this.userInfo); this.$emit(&quot;add-user&quot;); // this.userInfo = &quot;&quot;; }, onInput(e) { this.$emit(&quot;input&quot;, e.target.value); }, }, }); 在user-add组件中，定义props接收传递过来的值，也就是userInfo的值会传递给value 下面修改user-add组件中的模板，文本框绑定value值。通过给其添加input事件，在文本框中输入值后，调用onInput方法，在该方法中获取用户在文本框中输入的值，然后发送input事件。对应的值传递给父组件中的userInfo 同时单击“新增用户”按钮的时候，执行addUser方法，在该方法中发送事件add-user,也不需要传递数据了。 同时，父组件中的addUser方法实现如下： addUser() { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; }, 直接从data中获取userInfo的数据。 总结： 以下的写法 &lt;user-add @add-user=&quot;addUser&quot; v-model=&quot;userInfo&quot;&gt;&lt;/user-add&gt; 等价以下的写法 &lt;user-add v-bind:value=&quot;userInfo&quot; v-on:input=&quot;userInfo = $event&quot; &gt;&lt;/user-add&gt; 也就是说v-model就是v-bind与v-on的语法糖。 在这里我们将userInfo的值给了value属性，而value属性传递到了user-add组件中，所以在user-add组件中要通过props来接收value属性的值。 在user-add组件的文本中，输入内容后触发@input 事件，对应的会调用onInput方法，在该方法中，执行了 this.$emit(&quot;input&quot;, e.target.value); 发送了input事件，并且传递了用户在文本框中输入的值。 那很明显，这时会触发下面代码中的input事件，将传递过来的值给userInfo属性。 &lt;user-add v-bind:value=&quot;userInfo&quot; v-on:input=&quot;userInfo = $event&quot; &gt;&lt;/user-add&gt; 以上就是v-model的原理，希望仔细体会，这也是面试经常会被问到的问题。 16.3.4. 使用插槽完成内容分发关于插槽的内容，在前面的的课程中我们已经学习过了，那么什么是内容分发呢？ 其实就是在使用组件的时候，我们提供具体的数据内容，然后这些内容会插入到组件内部插槽的位置，这就是所谓的内容分发。 下面，要做的事情就是创建一个信息的提示窗口。例如：当添加用户成功后，给出相应的提示。 首先先创建样式： &lt;style&gt; .actived { background-color: #dddddd; } .message-box { padding: 10px 20px; background-color: #4fc; border: 1px solid #42b; } .message-box-close { float: right; } &lt;/style&gt; 下面创建对应的组件。 //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 props: [&quot;show&quot;], template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot;&gt;关闭&lt;/span&gt; &lt;/div&gt;`, }); 使用上面的组件 &lt;div id=&quot;app&quot;&gt; &lt;!-- 弹窗组件 --&gt; &lt;message :show=&quot;isShow&quot;&gt; 添加用户成功 &lt;/message&gt; &lt;!-- 批量更新身高 --&gt; &lt;/div&gt; 在data 中定义isShow属性，初始值为false. new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, isShow: false, }, 下面就是当用户完成添加的时候，弹出该窗口。 //添加用户的信息 addUser() { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 this.isShow = true; }, 在addUser方法中完成了用户信息的添加后，将isShow的属性值设置为true. 这时弹出了对应的窗口。 下面要考虑的就是，单击窗口右侧的“关闭”按钮，将窗口关闭这个效果应该怎样实现。 首先给关闭按钮添加单击事件。 如下所示： //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 props: [&quot;show&quot;], template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='$emit(&quot;close&quot;,false)'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, }); 当单击关闭按钮后，会发送一个close事件，同时传递的值为false. 下面回到父组件中，对close事件进行处理。 &lt;!-- 弹窗组件 --&gt; &lt;message :show=&quot;isShow&quot; @close=&quot;closeWindow&quot;&gt; 添加用户成功 &lt;/message&gt; 当close事件触发后，执行closeWindow方法。 //关闭窗口 closeWindow(data) { this.isShow = data; }, 在closeWindow方法中，根据子组件传递过来的值false,修改isShow属性的值，这时isShow的值为false.这时窗口关闭。 下面要解决的问题就是，在使用弹窗组件的时候，不仅能传递窗口的内容，还能传递其它的内容，例如标题等。 那应该怎样处理呢? 这里，可以使用具名插槽 代码如下： &lt;!-- 弹窗组件 --&gt; &lt;message :show=&quot;isShow&quot; @close=&quot;closeWindow&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;恭喜&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 添加用户成功 &lt;/template&gt; &lt;/message&gt; 下面修改一下message组件中的内容。 //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 props: [&quot;show&quot;], template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='$emit(&quot;close&quot;,false)'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, }); 在上面定义message组件的时候，指定了具名插槽，名称为title.要与在父组件中使用message组件的时候指定的名称保持一致，同时这里如果没有传递任何内容，将会显示”默认标题”。 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } .message-box { padding: 10px 20px; background-color: #4fc; border: 1px solid #42b; } .message-box-close { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 弹窗组件 --&gt; &lt;message :show=&quot;isShow&quot; @close=&quot;closeWindow&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;恭喜&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 添加用户成功 &lt;/template&gt; &lt;/message&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot; v-model=&quot;userInfo&quot;&gt;&lt;/user-add&gt; &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 props: [&quot;show&quot;], template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='$emit(&quot;close&quot;,false)'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, }); //新增用户组件 Vue.component(&quot;user-add&quot;, { // data() { // return { // userInfo: &quot;&quot;, // }; // }, props: [&quot;value&quot;], template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-on:keydown.enter=&quot;addUser&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. // this.$emit(&quot;add-user&quot;, this.userInfo); this.$emit(&quot;add-user&quot;); // this.userInfo = &quot;&quot;; }, onInput(e) { this.$emit(&quot;input&quot;, e.target.value); }, }, }); // 用户列表 Vue.component(&quot;user-list&quot;, { data() { return { selectItem: &quot;&quot;, }; }, props: { users: { type: Array, default: [], }, }, template: ` &lt;div&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, }); new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, isShow: false, }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //关闭窗口 closeWindow(data) { this.isShow = data; }, //添加用户的信息 addUser() { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 this.isShow = true; }, //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 16.3.5 vm.$on与vm.$emit应用现在，关于用户管理这个案例的一些组件拆分，以及插槽的应用在这我们已经构建好了。 下面就看一下vm.$on与vm.$emit的应用。 根据前面的学习，我们知道vm.$on与vm.$emit的典型应用就是事件总线。 也就是通过在Vue 原型上添加一个Vue实例作为事件总线，实现组件间相互通信，而且不受组件间关系的影响 Vue.prototype.$bus=new Vue() 在所有组件最上面创建事件总线， 这样做的好处就是在任意组件中使用this.$bus访问到该Vue实例。 下面，我们来看一下事件总线的用法。 首先，我们这里先把事件总线创建出来。 //创建事件总线 Vue.prototype.$bus = new Vue(); 下面，在创建一个警告的窗口，也就是当单击“新增用户”按钮的时候，如果用户没有填写用户名给出相应册错误提示。 在这里先把样式修改一下： &lt;style&gt; .actived { background-color: #dddddd; } .message-box { padding: 10px 20px; } .success { background-color: #4fc; border: 1px solid #42b; } .warning { background-color: red; border: 1px solid #42b; } .message-box-close { float: right; } &lt;/style&gt; 然后创建出对应的窗口。 &lt;!-- 警告 --&gt; &lt;message :show=&quot;showWarn&quot; @close=&quot;closeWindow&quot; class=&quot;warning&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;警告&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 请输入用户名 &lt;/template&gt; &lt;/message&gt; 注意：在上面的代码中，我们使用showWarn这个属性控制警告窗口的显示与隐藏。 同时，为其添加了warning样式，对应的成功的窗口需要添加success 样式。 同时在data中定义showWarn属性。 new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, isShow: false, showWarn: false, // 控制警告窗口的显示与隐藏 }, 下面要修改的就是当单击”新增用户”按钮的时候，对addUser方法的修改。 //添加用户的信息 addUser() { if (this.userInfo) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 this.isShow = true; } else { // 显示错误警告信息 this.showWarn = true; } }, 判断userInfo中是否有值，如果没有值，展示出错误警告信息。 通过浏览器，进行测试。发现如果用户没有在文本框中输入用户名，直接单击了“新增用户”，这时给出了错误提示的窗口。 但是用户没有关闭错误提示的窗口，而是直接在文本框中输入了用户名，然后又点击了”新增用户”按钮，这时“成功窗口”与“警告窗口”都显示出来了。 下面需要解决这个问题。 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 props: [&quot;show&quot;], template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='$emit(&quot;close&quot;,false)'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, mounted() { //给总线绑定`message-close`事件 //也就是监听是否有`message-close`事件被触发。 this.$bus.$on(&quot;message-close&quot;, () =&gt; { this.$emit(&quot;close&quot;, false); }); }, }); 在message组件加载完后，给事件总线绑定了message-close事件，当该事件触发后还是向父组件发送了close事件，这一点与单击关闭按钮是一样的。 下面，怎样触发总线的message-close事件呢？ 我们可以在窗口中添加一个“清空提示栏”按钮，单击该按钮的时候可以触发message-close事件，从而关闭提示窗口。 &lt;!-- 清空提示栏 --&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;button @click=&quot;$bus.$emit('message-close')&quot;&gt; 清空提示栏 &lt;/button&gt; &lt;/div&gt; 单击”清空提示栏”按钮后，触发事件总线的message-close事件。 最后完善一下closeWindow方法，该方法控制整个提示窗口的关闭 //关闭窗口 closeWindow(data) { this.isShow = data; this.showWarn = data; }, 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } .message-box { padding: 10px 20px; } .success { background-color: #4fc; border: 1px solid #42b; } .warning { background-color: red; border: 1px solid #42b; } .message-box-close { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 弹窗组件 --&gt; &lt;message :show=&quot;isShow&quot; @close=&quot;closeWindow&quot; class=&quot;success&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;恭喜&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 添加用户成功 &lt;/template&gt; &lt;/message&gt; &lt;!-- 警告 --&gt; &lt;message :show=&quot;showWarn&quot; @close=&quot;closeWindow&quot; class=&quot;warning&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;警告&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 请输入用户名 &lt;/template&gt; &lt;/message&gt; &lt;!-- 清空提示栏 --&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;button @click=&quot;$bus.$emit('message-close')&quot;&gt; 清空提示栏 &lt;/button&gt; &lt;/div&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot; v-model=&quot;userInfo&quot;&gt;&lt;/user-add&gt; &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建事件总线 Vue.prototype.$bus = new Vue(); //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 props: [&quot;show&quot;], template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='$emit(&quot;close&quot;,false)'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, mounted() { //给总线绑定`message-close`事件 //也就是监听是否有`message-close`事件被触发。 this.$bus.$on(&quot;message-close&quot;, () =&gt; { this.$emit(&quot;close&quot;, false); }); }, }); //新增用户组件 Vue.component(&quot;user-add&quot;, { // data() { // return { // userInfo: &quot;&quot;, // }; // }, props: [&quot;value&quot;], template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-on:keydown.enter=&quot;addUser&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. // this.$emit(&quot;add-user&quot;, this.userInfo); this.$emit(&quot;add-user&quot;); // this.userInfo = &quot;&quot;; }, onInput(e) { this.$emit(&quot;input&quot;, e.target.value); }, }, }); // 用户列表 Vue.component(&quot;user-list&quot;, { data() { return { selectItem: &quot;&quot;, }; }, props: { users: { type: Array, default: [], }, }, template: ` &lt;div&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, }); new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, isShow: false, showWarn: false, // 控制警告窗口的显示与隐藏 }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //关闭窗口 closeWindow(data) { this.isShow = data; this.showWarn = data; }, //添加用户的信息 addUser() { if (this.userInfo) { if (this.users.length &gt; 0) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 this.isShow = true; } } else { // 显示错误警告信息 this.showWarn = true; } }, //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 16.4 vm.$once与vm.$off关于这两个方法，大家只需要了解一下就可以了。 vm.$once监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。 vm.$on('test', function (msg) { console.log(msg) }) vm.$off 移除自定义事件监听器。 如果没有提供参数，则移除所有的事件监听器； 如果只提供了事件，则移除该事件所有的监听器； 如果同时提供了事件与回调，则只移除这个回调的监听器 vm.$off() // 移除所有的事件监听器 vm.$off('test') // 移除该事件所有的监听器 vm.$off('test', callback) // 只移除这个回调的监听器 16.5 ref 和vm.$refsref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象上，如果在普通的DOM元素上使用，引用指向的就是DOM元素;如果用在子组件上，引用就指向组件的实例。 如下代码示例，是用来设置输入框的焦点 &lt;input type=&quot;text&quot; ref=&quot;inp&quot; /&gt; mounted(){ //mounted之后才能访问到inp this.$refs.inp.focus() } 下面在用户管理案例中，看一下具体的实现效果。 //新增用户组件 Vue.component(&quot;user-add&quot;, { // data() { // return { // userInfo: &quot;&quot;, // }; // }, props: [&quot;value&quot;], template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-on:keydown.enter=&quot;addUser&quot; ref=&quot;inp&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. // this.$emit(&quot;add-user&quot;, this.userInfo); this.$emit(&quot;add-user&quot;); // this.userInfo = &quot;&quot;; }, onInput(e) { this.$emit(&quot;input&quot;, e.target.value); }, }, mounted() { this.$refs.inp.focus(); }, }); 在上面的代码中，我们首先给user-add组件模板中的文本框添加了ref属性。 然后，在其所对应的mounted方法中，通过$refs找到文本框，然后为其添加焦点。 回到浏览器中，刷新浏览器，可以看到对应的文本框获取了焦点。 下面，我们在将弹出窗口修改一下： 下面修改一下message模板中的内容。 //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 // props: [&quot;show&quot;], data() { return { show: false, }; }, template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='toggle'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, mounted() { //给总线绑定`message-close`事件 //也就是监听是否有`message-close`事件被触发。 this.$bus.$on(&quot;message-close&quot;, () =&gt; { // this.$emit(&quot;close&quot;, false); this.toggle(); }); }, methods: { toggle() { this.show = !this.show; }, }, }); 在上面的代码中，取消了props，而定义了data属性，表明的含义就是整个窗口的状态的控制，也就是提示窗口的显示与隐藏，都是有自己控制，而不是受外部传递的参数来进行控制了。 同时，在该组件中，添加了toggle方法，修改对应的show的状态。 所以模板中，按钮的单击事件触发以后，调用的就是toggle方法，也就是单击了窗口的右侧的关闭按钮，是通过调用toggle方法来完成，窗口的关闭。 同样事件message-close触发以后，也是调用toggle方法来关闭窗口。 下面看一下关于message模板的使用。 &lt;!-- 弹窗组件 --&gt; &lt;message ref=&quot;msgSuccess&quot; class=&quot;success&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;恭喜&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 添加用户成功 &lt;/template&gt; &lt;/message&gt; 在上面的代码中，我们为message组件，添加了ref属性。 同理表示警告的窗口，也需要添加ref的属性。 &lt;!-- 警告 --&gt; &lt;message ref=&quot;msgWaring&quot; class=&quot;warning&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;警告&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 请输入用户名 &lt;/template&gt; &lt;/message&gt; 关于data中定义的isShow与showWarn就可以取消了。 data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, // isShow: false, // showWarn: false, // 控制警告窗口的显示与隐藏 }, 当用户点击“新增用户”按钮的时候，执行addUser方法，下面也需要对该方法进行如下修改： //添加用户的信息 addUser() { if (this.userInfo) { if (this.users.length &gt; 0) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 // this.isShow = true; this.$refs.msgSuccess.toggle(); } } else { // 显示错误警告信息 // this.showWarn = true; this.$refs.msgWaring.toggle(); } }, 在上面的代码中，我们都是通过$ref 找到对应的窗口，然后调用toggle方法，来修改对应的状态。 因为，我们前面讲过如果ref用在子组件上，引用就指向组件的实例.所以可以调用组件内部的toggle方法。 完整代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } .message-box { padding: 10px 20px; } .success { background-color: #4fc; border: 1px solid #42b; } .warning { background-color: red; border: 1px solid #42b; } .message-box-close { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 弹窗组件 --&gt; &lt;message ref=&quot;msgSuccess&quot; class=&quot;success&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;恭喜&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 添加用户成功 &lt;/template&gt; &lt;/message&gt; &lt;!-- 警告 --&gt; &lt;message ref=&quot;msgWaring&quot; class=&quot;warning&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;警告&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 请输入用户名 &lt;/template&gt; &lt;/message&gt; &lt;!-- 清空提示栏 --&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;button @click=&quot;$bus.$emit('message-close')&quot;&gt; 清空提示栏 &lt;/button&gt; &lt;/div&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot; v-model=&quot;userInfo&quot;&gt;&lt;/user-add&gt; &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建事件总线 Vue.prototype.$bus = new Vue(); //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 // props: [&quot;show&quot;], data() { return { show: false, }; }, template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='toggle'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, mounted() { //给总线绑定`message-close`事件 //也就是监听是否有`message-close`事件被触发。 this.$bus.$on(&quot;message-close&quot;, () =&gt; { // this.$emit(&quot;close&quot;, false); //当警告窗口和提示信息的窗口，展示出来了才关闭。 if (this.show) { this.toggle(); } }); }, methods: { toggle() { this.show = !this.show; }, }, }); //新增用户组件 Vue.component(&quot;user-add&quot;, { // data() { // return { // userInfo: &quot;&quot;, // }; // }, props: [&quot;value&quot;], template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-on:keydown.enter=&quot;addUser&quot; ref=&quot;inp&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. // this.$emit(&quot;add-user&quot;, this.userInfo); this.$emit(&quot;add-user&quot;); // this.userInfo = &quot;&quot;; }, onInput(e) { this.$emit(&quot;input&quot;, e.target.value); }, }, mounted() { this.$refs.inp.focus(); }, }); // 用户列表 Vue.component(&quot;user-list&quot;, { data() { return { selectItem: &quot;&quot;, }; }, props: { users: { type: Array, default: [], }, }, template: ` &lt;div&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, }); new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, // isShow: false, // showWarn: false, // 控制警告窗口的显示与隐藏 }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //关闭窗口 closeWindow(data) { this.isShow = data; this.showWarn = data; }, //添加用户的信息 addUser() { if (this.userInfo) { if (this.users.length &gt; 0) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 // this.isShow = true; this.$refs.msgSuccess.toggle(); } } else { // 显示错误警告信息 // this.showWarn = true; this.$refs.msgWaring.toggle(); } }, //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面在对ref与vm.$refs的使用做一个总结： ref是作为渲染结果被创建的，在初始渲染时不能访问它们。也就是必须在mounted构造函数中。 $refs不是响应式的，不要试图用它在模板中做数据绑定。 17、过滤器17.1 过滤器基本使用过滤器在日常生活中也是比较常见的，例如自来水的过滤等。 在Vue中，过滤器的作用就是格式化数据，也就是对数据的过滤处理，比如将字符串格式化为首字母大写 或者将日期格式化为指定的格式等。 下面先看一下自定义过滤器的语法 Vue.filter('过滤器名称',function(value){ //value参数表示要处理的数据 //过滤器业务逻辑，最终将处理后的数据进行返回 }) 定义好以后可以使用。使用的方式如下： &lt;div&gt;{{msg|upper}}&lt;/div&gt; &lt;div&gt;{{msg|upper|lower}}&lt;/div&gt; 具体的程序如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;过滤器基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &lt;div&gt; &lt;!--使用过滤器--&gt; {{msg|upper}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义过滤器，让输入的单词首字母变成大写. Vue.filter(&quot;upper&quot;, function (value) { //获取首字母让其转换成大写，然后拼接后面的内容。 return value.charAt(0).toUpperCase() + value.slice(0); }); const vm = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;&quot;, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 过滤器在使用的时候，可以采用如下的方式： &lt;div&gt;{{msg|upper|lower}}&lt;/div&gt; 也就是，先对msg中的数据使用upper过滤器，得到的结果在交给lower过滤器进行处理。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;过滤器基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &lt;div&gt; {{msg|upper}} &lt;/div&gt; &lt;div&gt; {{msg|upper|lower}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义过滤器，让输入的单词首字母变成大写. Vue.filter(&quot;upper&quot;, function (value) { //获取首字母让其转换成大写，然后拼接后面的内容。 return value.charAt(0).toUpperCase() + value.slice(0); }); Vue.filter(&quot;lower&quot;, function (value) { return value.charAt(0).toLowerCase() + value.slice(0); }); const vm = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;&quot;, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上面定义的顾虑器是全局的过滤器，当然也可以定义局部过滤器。 局部过滤器只能在其所定义的组件内使用。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;过滤器基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &lt;div&gt; {{msg|upper}} &lt;/div&gt; &lt;div&gt; {{msg|upper|lower}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义过滤器，让输入的单词首字母变成大写. // Vue.filter(&quot;upper&quot;, function (value) { // //获取首字母让其转换成大写，然后拼接后面的内容。 // return value.charAt(0).toUpperCase() + value.slice(0); // }); Vue.filter(&quot;lower&quot;, function (value) { return value.charAt(0).toLowerCase() + value.slice(0); }); const vm = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;&quot;, }, //局部过滤器 filters: { upper: function (value) { return value.charAt(0).toUpperCase() + value.slice(0); }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们通过fileters定义了一个局部的过滤器upper. 在前面，我们也说过Vue实例本身就是一个组件。 17.2 带参数的过滤器带参数的过滤器定义如下： Vue.filter('format',function(value,arg1){ //value表示要过滤的数据。 //arg1,表示传递过来的参数 }) 使用的方式如下 &lt;div&gt; {{data|format(`yyyy-MM-dd`)}} &lt;/div&gt; 要处理的数据data交给了过滤器中回调函数的value参数，yyyy-MM-dd交给了arg1. 如下代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;过滤器参数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; {{date|format('abc','hello')}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.filter(&quot;format&quot;, function (value, arg, arg1) { console.log(arg, arg1); return value; }); const vm = new Vue({ el: &quot;#app&quot;, data: { date: new Date(), }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们定义了format过滤器，然后在使用的时候，我们是将date日期数据给了value abc这个字符串给了arg,hello给了arg1. 下面，我们把日期给具体的处理一下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;过滤器参数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; {{date|format('yyyy-MM-dd')}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.filter(&quot;format&quot;, function (value, arg, arg1) { let result = &quot;&quot;; result += value.getFullYear() + &quot;-&quot; + (value.getMonth() + 1) + &quot;-&quot; + value.getDate(); return result; }); const vm = new Vue({ el: &quot;#app&quot;, data: { date: new Date(), }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 18、自定义指令18.1 自定义指令基本用法为什么需要自定义指令呢？ 因为内置指令不满足需求。 下面看一下基本的创建自定义指令语法: Vue.directive('focus',{ inserted:function(el){ //获取元素焦点 el.focus(); } }) 自定义指令用法 &lt;input type=&quot;text&quot; v-focus&gt; 下面看一下具体的代码。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;自定义指令基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-focus /&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.directive(&quot;focus&quot;, { inserted: function (el) { //el:表示指令所绑定的元素 el.focus(); }, }); const vm = new Vue({ el: &quot;#app&quot;, data: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在上面的代码中，我们通过directive方法创建了一个focus指令。 在使用该指令的时候，一定要加上v-的形式。 inserted表示的是指令的钩子函数，含义是：被绑定元素插入父节点时调用。 18.2 自定义指令-带参数带参数的自定义指令创建的语法（改变元素背景色） Vue.directive('color',{ inserted:function(el,binding){ //binding表示传递过来的参数 el.style.backgroundColor=binding.value.color; } }) 指令的用法 &lt;input type=&quot;text&quot; v-color='{color:&quot;orange&quot;}' /&gt; 下面，看一下完整的代码案例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;自定义指令带参数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-color=&quot;msg&quot; /&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //自定义指令-带参数 Vue.directive(&quot;color&quot;, { bind: function (el, binding) { el.style.backgroundColor = binding.value.color; }, }); const vm = new Vue({ el: &quot;#app&quot;, data: { msg: { color: &quot;blue&quot;, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过上面的代码，可以看到定义了一个color的指令，在使用的时候传递了msg对象。 所以这个对象会给binding这个参数，我们通过这个参数的value 属性获取msg对象中的color属性的值，然后用来设置文本框的背景色。 这里使用了bind这个钩子函数：只调用一次，第一次绑定指令到元素时调用，我们可以在此绑定只执行一次的初始化动作。 18.3 自定义局部指令局部指令的基本语法： directives:{ focus:{ //指令的定义 inserted:function(el){ el.focus() } } } 在Vue实例中添加directives 具体实现的代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;局部指令&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-color=&quot;msg&quot; /&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, data: { msg: { color: &quot;red&quot;, }, }, directives: { color: { bind: function (el, binding) { el.style.backgroundColor = binding.value.color; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 局部指令只在所定义的组件中使用。 19、渲染函数Vue推荐在绝大数情况下使用模板来创建你的HTML。然后在一些场景中，你真的需要JavaScript的完全编程的能力，也就是使用javaScript来创建HTML，这时你可以用渲染函数，它比模板更接近编译器。 这里我们先来做一个基本的了解，为后期的深入学习打好一个基础。 下面先看一下render函数的基本结构。 render:function(createElement){ //createElement函数返回的结果为VNode. VNode就是虚拟dom，用js对象来模拟真实的DOM. retrun createElement( tag, //标签名称 data,// 传递数据 children //子节点数组 ) } 下面我们在用户管理这个案例中，使用render函数来创建一个组件。 具体的代码如下： // heading组件 //&lt;heading :level=&quot;1&quot;&gt;{{title}}&lt;/heading&gt; //这时要创建的组件 // &lt;h2 title=&quot;&quot;&gt;&lt;/h2&gt; //这时上面的组件最终渲染的结果 Vue.component(&quot;heading&quot;, { props: { level: { type: String, required: true, }, }, render(h) { //h 就是createElement函数 return h( &quot;h&quot; + this.level, //参数1，表示要创建的元素 this.$slots.default //参数3，子节点VNode数组。（这里没有使用参数2，{{tile}}就是一个子元素） ); }, }); 接下来就可以使用heading组件了。 &lt;!-- 使用render函数创建的头部组件 --&gt; &lt;heading level=&quot;1&quot;&gt; {{title}} &lt;/heading&gt; 当然，这里需要在data中定义title属性。 data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, title: &quot;用户管理&quot;, // isShow: false, // showWarn: false, // 控制警告窗口的显示与隐藏 }, 完整代码如下（24、render函数.html）： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;style&gt; .actived { background-color: #dddddd; } .message-box { padding: 10px 20px; } .success { background-color: #4fc; border: 1px solid #42b; } .warning { background-color: red; border: 1px solid #42b; } .message-box-close { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 弹窗组件 --&gt; &lt;message ref=&quot;msgSuccess&quot; class=&quot;success&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;恭喜&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 添加用户成功 &lt;/template&gt; &lt;/message&gt; &lt;!-- 警告 --&gt; &lt;message ref=&quot;msgWaring&quot; class=&quot;warning&quot;&gt; &lt;!-- titile的插槽 --&gt; &lt;template v-slot:title&gt; &lt;h2&gt;警告&lt;/h2&gt; &lt;/template&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt; 请输入用户名 &lt;/template&gt; &lt;/message&gt; &lt;!-- 使用render函数创建的头部组件 --&gt; &lt;heading level=&quot;1&quot;&gt; {{title}} &lt;/heading&gt; &lt;!-- 清空提示栏 --&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;button @click=&quot;$bus.$emit('message-close')&quot;&gt; 清空提示栏 &lt;/button&gt; &lt;/div&gt; &lt;!-- 批量更新身高 --&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;height&quot; /&gt; &lt;button @click=&quot;batchUpdate&quot;&gt;批量更新用户身高&lt;/button&gt; &lt;/p&gt; &lt;!-- 新增用户 --&gt; &lt;user-add @add-user=&quot;addUser&quot; v-model=&quot;userInfo&quot;&gt;&lt;/user-add&gt; &lt;!-- 用户列表组件 --&gt; &lt;user-list :users=&quot;users&quot;&gt;&lt;/user-list&gt; &lt;p&gt; 总人数：{{totalCount}} &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建事件总线 Vue.prototype.$bus = new Vue(); // heading组件 //&lt;heading :level=&quot;1&quot;&gt;{{title}}&lt;/heading&gt; //这时要创建的组件 // &lt;h2 title=&quot;&quot;&gt;&lt;/h2&gt; //这时上面的组件最终渲染的结果 Vue.component(&quot;heading&quot;, { props: { level: { type: String, required: true, }, }, render(h) { return h( &quot;h&quot; + this.level, //参数1，表示要创建的元素 this.$slots.default //参数3，子节点VNode数组。（这里没有使用参数2，{{tile}}就是一个子元素） ); }, }); //创建弹出的组件 Vue.component(&quot;message&quot;, { //show表示的含义，控制弹出窗口的显示与隐藏。 //slot:表示占坑。也就是窗口中的内容，是通过外部组件传递过来的。 // props: [&quot;show&quot;], data() { return { show: false, }; }, template: `&lt;div class='message-box' v-if=&quot;show&quot;&gt; &lt;!--具名插槽--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span class=&quot;message-box-close&quot; @click='toggle'&gt;关闭&lt;/span&gt; &lt;/div&gt;`, mounted() { //给总线绑定`message-close`事件 //也就是监听是否有`message-close`事件被触发。 this.$bus.$on(&quot;message-close&quot;, () =&gt; { // this.$emit(&quot;close&quot;, false); //当警告窗口和提示信息的窗口，展示出来了才关闭。 if (this.show) { this.toggle(); } }); }, methods: { toggle() { this.show = !this.show; }, }, }); //新增用户组件 Vue.component(&quot;user-add&quot;, { // data() { // return { // userInfo: &quot;&quot;, // }; // }, props: [&quot;value&quot;], template: ` &lt;div&gt; &lt;p&gt; &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-on:keydown.enter=&quot;addUser&quot; ref=&quot;inp&quot; /&gt; &lt;/p&gt; &lt;button @click=&quot;addUser&quot;&gt;新增用户&lt;/button&gt; &lt;/div&gt; `, methods: { addUser() { //将输入的用户数据通知给父组件，来完成新增用户操作. // this.$emit(&quot;add-user&quot;, this.userInfo); this.$emit(&quot;add-user&quot;); // this.userInfo = &quot;&quot;; }, onInput(e) { this.$emit(&quot;input&quot;, e.target.value); }, }, mounted() { this.$refs.inp.focus(); }, }); // 用户列表 Vue.component(&quot;user-list&quot;, { data() { return { selectItem: &quot;&quot;, }; }, props: { users: { type: Array, default: [], }, }, template: ` &lt;div&gt; &lt;p v-if=&quot;users.length===0&quot;&gt;没有任何用户数据&lt;/p&gt; &lt;ul v-else&gt; &lt;li v-for=&quot;(item,index) in users&quot; :key=&quot;item.id&quot; :style=&quot;{backgroundColor:selectItem===item?'#dddddd':'transparent'}&quot; @mousemove=&quot;selectItem=item&quot; &gt; 编号：{{item.id}} 姓名:{{item.name}}---身高:{{item.height}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, }); new Vue({ el: &quot;#app&quot;, data: { num: 100, totalCount: 0, users: [], height: 0, userInfo: &quot;abc&quot;, title: &quot;用户管理&quot;, // isShow: false, // showWarn: false, // 控制警告窗口的显示与隐藏 }, //组件实例已创建时 async created() { const users = await this.getUserList(); this.users = users; //批量更新用户身高 this.batchUpdate(); }, methods: { //关闭窗口 closeWindow(data) { this.isShow = data; this.showWarn = data; }, //添加用户的信息 addUser() { if (this.userInfo) { if (this.users.length &gt; 0) { this.users.push({ id: this.users[this.users.length - 1].id + 1, name: this.userInfo, }); this.userInfo = &quot;&quot;; //完成用户添加后，给出相应的提示信息 // this.isShow = true; this.$refs.msgSuccess.toggle(); } } else { // 显示错误警告信息 // this.showWarn = true; this.$refs.msgWaring.toggle(); } }, //批量更新身高，动态的给users中添加身高属性 batchUpdate() { this.users.forEach((c) =&gt; { // c.height = this.height; // Vue.set(c, &quot;height&quot;, this.height); this.$set(c, &quot;height&quot;, this.height); }); }, getTotal: function () { console.log(&quot;methods&quot;); return this.users.length + &quot;个&quot;; }, getUserList: function () { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve([ { id: 1, name: &quot;张三&quot;, }, { id: 2, name: &quot;李四&quot;, }, { id: 3, name: &quot;老王&quot;, }, ]); }, 2000); }); }, }, watch: { users: { immediate: true, //立即执行 handler(newValue, oldValue) { this.totalCount = newValue.length + &quot;个人&quot;; }, }, }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 虚拟DOM Vue通过建立一个虚拟DOM来追踪自己要如何改变真实DOM. createElement参数 前面说过，createElement函数有三个参数。 createElement( //{string |Object|Function} //第一个参数，可以是字符串，也可以是对象或者是函数 ‘div’ , // 第二个参数是对象，表示的是一个与模板中属性对应的数据对象。该参数可选 { }, //第三个参数是一个数组,表示的是子节点数组 [ ] ) 下面，给heading组件添加第一个属性。 &lt;!-- 使用render函数创建的头部组件 --&gt; &lt;heading level=&quot;1&quot; :title=&quot;title&quot;&gt; {{title}} &lt;/heading&gt; 在上面的代码中，我们给heading组件动态添加了一个title属性。而我们知道heading组件，最终渲染成的是h1的元素，最终效果为：&lt;h1 title='aaa'&gt;的形式。 // heading组件 //&lt;heading :level=&quot;1&quot;&gt;{{title}}&lt;/heading&gt; //这时要创建的组件 // &lt;h2 title=&quot;&quot;&gt;&lt;/h2&gt; //这时上面的组件最终渲染的结果 Vue.component(&quot;heading&quot;, { props: { level: { type: String, required: true, }, title: { type: String, default: &quot;&quot;, }, }, render(h) { return h( &quot;h&quot; + this.level, //参数1，表示要创建的元素 { attrs: { title: this.title } }, //参数2 this.$slots.default //参数3，子节点VNode数组。（这里没有使用参数2，{{tile}}就是一个子元素） ); }, }); 在上面的代码中，我们在render函数中给h函数添加了第二个参数，给最终生成的元素添加了attrs属性。 20、函数式组件组件没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法时，可以将组件标记为functional.这意味它无状态（没有响应式数据），也没有实例（没有this上下文） 因为只是函数，所以渲染的开销相对来说，较小。 函数化的组件中的 Render 函数，提供了第二个参数 context 作为上下文，data、props、slots、children 以及 parent 都可以通过 context 来访问。 这块内容简单了解一下就可以。 21、混入混入(mixin)提供了一种非常灵活的方式，来分发Vue组件中的可复用功能，一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项被“混合”进入该组件本身的选项。 // 定义一个混入对象 var myMixin={ created:function(){ this.hello() }, methods:{ hello:function(){ console.log('hello world') } } } Vue.component('comp',{ mixins:[myMixin] }) “混入”可以提高组件的复用功能，例如：上面所写的hello这个方法，不仅在一个组件中使用，还会 在其它组件中使用.那么，我们的处理方式就是，可以将hello 这个方法单独定义在一个地方，如果某个组件想要使用，可以直接将该方法注入到组件中。 22、插件前面我们讲解的混入，组件封装等都可以提高组件的复用功能。 但是这种方式不适合分发，也就是不适合将这些内容上传到github上，npm上。而这种情况最适合通过插件来实现。 插件通常用来为Vue添加全局功能。插件的功能范围一般有下面几种： 添加全局方法或者属性。例如：’element’ 添加全局资源 通过全局混入来添加一些组件选项。例如vue-router 添加vue实例方法，通过把它们添加到Vue.prototype上实现 一个库，提供自己的API，同时提供上面提到的一个或多个功能，例如vue-router 插件声明 Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或 property Vue.myGlobalMethod = function () { // 逻辑... } // 2. 添加全局资源 Vue.directive('my-directive', { bind (el, binding, vnode, oldVnode) { // 逻辑... } ... }) // 3. 注入组件选项 Vue.mixin({ created: function () { // 逻辑... } ... }) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... } } https://www.cnblogs.com/luozhihao/p/7414419.html 23、vue-cli使用npm install -g @vue/cli 通过使用vue-clie创建项目。","link":"/2022/08/15/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/"},{"title":"测试","text":"","link":"/2022/08/20/%E6%B5%8B%E8%AF%95/"},{"title":"面试题目","text":"面试题目1、实现一个new操作符 // &lt;!-- new操作符 // &lt;!-- 1.创建一个空对象 --&gt; // &lt;!-- 2.将空对象的原型指向构造函数的原型 --&gt; // &lt;!-- 3.将空对象作为构造函数的上下文（改变this指向） --&gt; // &lt;!-- 4.对构造函数的返回值处理判断 --&gt; return Object对象时，new操作符返回return的数据 function Fn(age, name) { this.age = age this.name = name return { a: 1 } } function myNew(fn, ...reset) { let obj = {} Object.setPrototypeOf(obj, fn.prototype) let result = fn.apply(obj, reset) return result instanceof Object ? result : obj } console.log(myNew(Fn, 18, 'zs')); 2、数据类型检测的方式有哪些 1.判断基本数据类型用 typeof 因为 Object,Array,Function都会返回Object 2.判断引用数据类型用 instanceof typeof console.log(typeof 2); // number console.log(typeof true); // boolean console.log(typeof 'str'); // string console.log(typeof []); // object console.log(typeof function(){}); // function console.log(typeof {}); // object console.log(typeof undefined); // undefined console.log(typeof null); // object instanceof console.log(2 instanceof Number); // false console.log(true instanceof Boolean); // false console.log('str' instanceof String); // false console.log([] instanceof Array); // true console.log(function(){} instanceof Function); // true console.log({} instanceof Object); // true","link":"/2022/08/10/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"title":"项目总结","text":"项目总结[TOC] 小城夏天电商平台线上地址：http://jay1124.web3v.work/#/ GitHub：https://github.com/BoLinJay/xiaochengxiaitian 后台管里系统-权限控制 前端权限的意义如果仅从能够修改服务器中数据库中的数据层面上讲， 确实只在后端做控制就足够了， 那为什么越来越多的项目也进行了前端权限的控制， 主要有这几方面的好处 1.降低非法操作的可能性2.尽可能排除不必要清求， 减轻服务器压力3.提高用户体验 实现步骤，方法 接口访问的权限控制，这个就是利用axios拦截器，判断token是否存在，访问有关页面时携带token,菜单列表的权限控制，分为两种： 显示所有菜单，用户访问不在自己权限中的页面时，提醒无权限 只显示当前用户能访问的权限内菜单，如果用户通过URL强制访问页面则返回404 1.先创建一个不需要权限访问的路由表，比如登录页，404页面，在把需要权限的路由表创建出来，这里的404页面要写在路由列表的最后，所有使用路由懒加载的方式创建这里的权限路由表可以不创建，直接从后端获取，但是后期维护和添加新需求麻烦。 2.获取后端传送来的路由信息，和路由表作比较，生成最总用户可以访问的路由表 3.使用router.addRoutes添加用户所需要的路由信息 4.可以使用vuex管理路由表，进行永久存储，然后从vuex中获取路由表进行渲染 5.数据操作权限可以加载路由元数据中meta中 ，使用v-if/v-show，根据数据进行动态显示，也可注册一个自定义指令 接口访问的接口控制，这个就是利用axios拦截器，判断token是否存在，访问有关页面时携带token, // 每次请求都为http头增加Authorization字段，其内容为token service.interceptors.request.use( config =&gt; { if (store.state.user.token) { config.headers.Authorization = `token ${store.state.user.token}`; } return config }, err =&gt; { return Promise.reject(err) } ); 2.菜单列表的权限控制，分为两种： 显示所有菜单，用户访问不在自己权限中的页面时，提醒无权限 只显示当前用户能访问的权限内菜单，如果用户通过URL强制访问页面则返回404 很显然，第一种方法不合适，那咱们梳理一下第二种方法，大致流程为： 配置自定义指令代码 //main.js //按扭权限指令 Vue.directive('allow', { inserted: (el, binding, vnode) =&gt; { let permissionList = vnode.context.$route.meta.permission; if (!permissionList.includes(binding.value)) { el.parentNode.removeChild(el) } } }) 1.路由信息匹配代码// router/index.js /** * 根据权限匹配路由 * @param {array} permission 权限列表（菜单列表） * @param {array} asyncRouter 异步路由对象 */ function routerMatch(permission, asyncRouter) { return new Promise((resolve) =&gt; { const routers = []; // 创建路由 function createRouter(permission) { // 根据路径匹配到的router对象添加到routers中即可 permission.forEach((item) =&gt; { if (item.children &amp;&amp; item.children.length) { createRouter(item.children) } let path = item.path; // 循环异步路由，将符合权限列表的路由加入到routers中 asyncRouter.find((s) =&gt; { if (s.path === '') { s.children.find((y) =&gt; { if (y.path === path) { y.meta.permission = item.permission; routers.push(s); } }) } if (s.path === path) { s.meta.permission = item.permission; routers.push(s); } }) }) } createRouter(permission) resolve([routers]) }) } 2.axios的封装代码// 1. 创建一个新的axios实例 // 2. 请求拦截器，如果有token进行头部携带 // 3. 响应拦截器：1. 剥离无效数据 2. 处理token失效 // 4. 导出一个函数，调用当前的axsio实例发请求，返回值promise import axios from 'axios' import store from '@/store' import router from '@/router' // 导出基准地址，原因：其他地方不是通过axios发请求的地方用上基准地址 export const baseURL = 'http://pcapi-xiaotuxian-front-devtest.itheima.net/' const instance = axios.create({ // axios 的一些配置，baseURL timeout baseURL, timeout: 5000 }) instance.interceptors.request.use(config =&gt; { // 拦截业务逻辑 // 进行请求配置的修改 // 如果本地又token就在头部携带 // 1. 获取用户信息对象 const { profile } = store.state.user // 2. 判断是否有token if (profile.token) { // 3. 设置token config.headers.Authorization = `Bearer ${profile.token}` } return config }, err =&gt; { return Promise.reject(err) }) // res =&gt; res.data 取出data数据，将来调用接口的时候直接拿到的就是后台的数据 instance.interceptors.response.use(res =&gt; res.data, err =&gt; { // 401 状态码，进入该函数 if (err.response &amp;&amp; err.response.status === 401) { // 1. 清空无效用户信息 // 2. 跳转到登录页 // 3. 跳转需要传参（当前路由地址）给登录页码 store.commit('user/setUser', {}) // 当前路由地址 // 组件里头：`/user?a=10` $route.path === /user $route.fullPath === /user?a=10 // js模块中：router.currentRoute.value.fullPath 就是当前路由地址，router.currentRoute 是ref响应式数据 const fullPath = encodeURIComponent(router.currentRoute.value.fullPath) // encodeURIComponent 转换uri编码，防止解析地址出问题 router.push('/login?redirectUrl=' + fullPath) } return Promise.reject(err) }) // 请求工具函数 export default (url, method, submitData) =&gt; { // 负责发请求：请求地址，请求方式，提交的数据 return instance({ url, method, // 1. 如果是get请求 需要使用params来传递submitData ?a=10&amp;c=10 // 2. 如果不是get请求 需要使用data来传递submitData 请求体传参 // [] 设置一个动态的key, 写js表达式，js表达式的执行结果当作KEY // method参数：get,Get,GET 转换成小写再来判断 // 在对象，['params']:submitData ===== params:submitData 这样理解 [method.toLowerCase() === 'get' ? 'params' : 'data']: submitData }) } 小城夏天电商平台1.vueX持久化方法 使用插件 vuex-persistedstate 存储本地 localStorage , 2.骨架屏封装 步骤： 基础布局，props，接收参数：高度，宽度，背景色，是否开启动画 &lt;template&gt; &lt;div class=&quot;xtx-skeleton&quot; :style=&quot;{width,height}&quot; :class=&quot;{shan:animated}&quot;&gt; &lt;!-- 1 盒子--&gt; &lt;div class=&quot;block&quot; :style=&quot;{backgroundColor:bg}&quot;&gt;&lt;/div&gt; &lt;!-- 2 闪效果 xtx-skeleton 伪元素 ---&gt; &lt;/div&gt; &lt;/template&gt; 3.轮播图封装 完成基础布局，逻辑封装有下一页，上一页，自动播放，自动播放的间隔时间 步骤： props接收：数据信息，是否自动播放，自动播放的间隔时间 使用ref定义一个num类型的响应式数据，用来控制显示哪张图片，v-for遍历数据，v-bind绑定class样式，判断当前图片索引和定义的数据相等，就给他加样式样式opacity：1和z-index:,默认样式都是不显示的，上下页按钮绑定事件，改变响应式数据的值，从而实现图片的切换。 自动播放:开启一个定时器，改边这个响应式数据的值，实现自动切换，自动播放的间隔时间就是传进来的props值 4.数据懒加载 步骤： 进入可视区时才调用API函数获取数据， 使用@vueuse/core 中的 useIntersectionObserver的插件监听DOM元素是否进入可视区，封装一个函数，接收内观察的对象和API函数,return数据和该DOM元素 分析useIntersectionObserver的参数// stop 是停止观察是否进入或移出可视区域的行为 const { stop } = useIntersectionObserver( // target 是观察的目标dom容器，必须是dom容器，而且是vue3.0方式绑定的dom对象 target, // isIntersecting 是否进入可视区域，true是进入 false是移出 // observerElement 被观察的dom ([{ isIntersecting }], observerElement) =&gt; { // 在此处可根据isIntersecting来判断，然后做业务 }, ) 封装的函数// hooks 封装逻辑，提供响应式数据。 import { useIntersectionObserver } from '@vueuse/core' import { ref } from 'vue' // 数据懒加载函数 export const useLazyData = (apiFn) =&gt; { // 需要 // 1. 被观察的对象 // 2. 不同的API函数 const target = ref(null) const result = ref([]) const { stop } = useIntersectionObserver( target, ([{ isIntersecting }], observerElement) =&gt; { if (isIntersecting) { stop() // 调用API获取数据 apiFn().then(data =&gt; { result.value = data.result }) } } ) // 返回---&gt;数据（dom,后台数据） return { target, result } } 5.图片懒加载 步骤 使用webAPI:IntersectionObserver判断图片是否进入可视区，封装了一个自定义指令,进行src的替换，在img上使用使用v-lazyload值为图片地址，不设置src属性 封装自定义指令的方法vue2：vue.directive,vue3:app.directive 介绍一下IntersectionObserver// 创建观察对象实例 const observer = new IntersectionObserver(callback[, options]) // callback 被观察dom进入可视区离开可视区都会触发 // - 两个回调参数 entries , observer // - entries 被观察的元素信息对象的数组 [{元素信息},{}]，信息中isIntersecting判断进入或离开 // - observer 就是观察实例 // options 配置参数 // - 三个配置属性 root rootMargin threshold // - root 基于的滚动容器，默认是document // - rootMargin 容器有没有外边距 // - threshold 交叉的比例 // 实例提供两个方法 // observe(dom) 观察哪个dom // unobserve(dom) 停止观察那个dom 自定义指令的封装import defaultImg from '@/assets/images/200.png' const DirectiveImage = (app) =&gt; { // 图片懒加载指令 app.directive('lazyload', { mounted(el, binding) { const observer = new IntersectionObserver(([{ isIntersecting }]) =&gt; { if(isIntersecting) { // 进入可视区后停止观察 observer.unobserve(el) // 图片加载失败显示默认图片 //onerror 事件会在文档或图像加载过程中发生错误时被触发。 el.onerror = () =&gt; { el.src = defaultImg } // 替换src el.src = binding.value } }, { threshold:0.01 }) // 开始观察 observer.observe(el) } }) } 如何自定义指令 定义局部自定义指令 局部自定义指令需要在组件的directives结构中定义，它是一个单独的结构 //vue3和vue2的组件自定义指令方法相同，只是钩子函数不同 directives:{ 指令名称：{ 钩子函数 } 自定义全局指令 //vue2 Vue.directive('directiveName', { //钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 }) // vue3全局指令 app.directive('directiveName', { // 在绑定元素的 attribute 或事件监听器被应用之前调用, 在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用 created() {}, // 当指令第一次绑定到元素并且在挂载父组件之前调用 beforeMount() {}, // 在绑定元素的父组件被挂载后调用 mounted() {}, // 在更新包含组件的 VNode 之前调用 beforeUpdate() {}, // 在包含组件的 VNode 及其子组件的 VNode 更新后调用 updated() {}, // 在卸载绑定元素的父组件之前调用 beforeUnmount() {}, // 当指令与元素解除绑定且父组件已卸载时, 只调用一次 unmounted() {}, }); 如何自定义全局方法或属性 原理：在 Vue.prototype 上添加了一个方法 使用Vue.prototype // 在main.js中写 Vue.prototype.getData = (params) =&gt; { ... } 使用install + Vue.prototype // 在你的全局函数文件fun.js中写 export default { install (Vue) { Vue.prototype.getData = () =&gt; { return { name: 'scout'} } } } // main.js 引入 import getData from './fun' Vue.use(getData) 如何自定义全局组件 vue2 // 公共vue组件: components文件夹下面的Loading.vue文件： import LoadingComponent from '@/components/Loading' export default { install (Vue) { Vue.component('Loading', LoadingComponent) } } // 全局组件： public文件夹下面的Loading.js文件。在main.js中引入: import Loading from &quot;@/public/Loading&quot; Vue.use(Loading) // 在vue任何组件上都可以直接使用：&lt;Loading /&gt; vue3 /* 以下两种二选一 */ const app = createApp(App); app.use(ElementPlus) app.use(router) app.mount('#app') //组件全局注册: app.component('组件名 用其调用 短横线分割命名',组件对象 name 首字母大写命名) app.component('side-box',sideBox) 6.面包屑组件的封装 总结，一下知识点 render 是vue提供的一个渲染函数，优先级大于el,template等选项，用来提供组件结构。 注意： vue2.0 render函数提供h（createElement）函数用来创建节点 vue3.0 h（createElement）函数有 vue 直接提供，需要按需导入 this.$slots.default() 获取默认插槽的node结构，按照要求拼接结构。 h函数的传参 tag 标签名|组件名称, props 标签属性|组件属性, node 子节点|多个节点 具体参考 render 注意：不要在 xtx-bread 组件插槽写注释，也会被解析。 &lt;script&gt; import { h } from 'vue' export default { name: 'XtxBread', render () { // 用法 // 1. template 标签去除，单文件组件 // 2. 返回值就是组件内容 // 3. vue2.0 的h函数传参进来的，vue3.0 的h函数导入进来 // 4. h 第一个参数 标签名字 第二个参数 标签属性对象 第三个参数 子节点 // 需求 // 1. 创建xtx-bread父容器 // 2. 获取默认插槽内容 // 3. 去除xtx-bread-item组件的i标签，因该由render函数来组织 // 4. 遍历插槽中的item，得到一个动态创建的节点，最后一个item不加i标签 // 5. 把动态创建的节点渲染再xtx-bread标签中 const items = this.$slots.default() const dymanicItems = [] items.forEach((item, i) =&gt; { dymanicItems.push(item) if (i &lt; (items.length - 1)) { dymanicItems.push(h('i', { class: 'iconfont icon-angle-right' })) } }) return h('div', { class: 'xtx-bread' }, dymanicItems) } } &lt;/script&gt; 7.批量注册组件 步骤： 使用 require 提供的函数 context 加载某一个目录下的所有 .vue 后缀的文件。 然后context函数会返回一个导入函数importFn 它有一个属性 keys() 获取所有的文件路径 通过文件路径数组，通过遍历数组，再使用 importFn 根据路径导入组件对象 遍历的同时进行全局注册即可 // 批量导入需要使用一个函数 require.context(dir,deep,matching) // 参数：1. 目录 2. 是否加载子目录 3. 加载的正则匹配 const importFn = require.context('./', false, /\\.vue$/) // console.dir(importFn.keys()) 文件名称数组 import Message from './Message' export default { install(app) { // 全自动批量注册 牛逼克拉斯 importFn.keys().forEach(key =&gt; { // 导入组件 const component = importFn(key).default // 注册组件 app.component(component.name, component) }); 总结： require.context(参数1,参数2,参数3) 是webpack提供的一个自动导入的API 参数1：加载的文件目录 参数2：是否加载子目录 参数3：正则，匹配文件 返回值：导入函数 fn keys() 获取读取到的所有文件列表 #04-顶级类目-基础布局搭建 8.无限加载 无限加载其实就是根据页码显示数据的另一种表现形式 步骤 判断是否进入可视区，进入可视区后调用函数获取数据，每获取一组数据将页码+1，没有数据则返回FALSE，并把阻止请求 落地代码 封装的无限加载组件 &lt;template&gt; &lt;div class=&quot;xtx-infinite-loading&quot; ref=&quot;container&quot;&gt; &lt;div class=&quot;loading&quot; v-if=&quot;loading&quot;&gt; &lt;span class=&quot;img&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;正在加载...&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;none&quot; v-if=&quot;finished&quot;&gt; &lt;span class=&quot;img&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;亲，没有更多了&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' import { useIntersectionObserver } from '@vueuse/core' export default { name: 'XtxInfiniteLoading', props: { loading: { type: Boolean, default: false }, finished: { type: Boolean, default: false } }, setup (props, { emit }) { const container = ref(null) useIntersectionObserver( container, ([{ isIntersecting }], dom) =&gt; { if (isIntersecting) { if (props.loading === false &amp;&amp; props.finished === false) { emit('infinite') } } }, { threshold: 0 } ) return { container } } } &lt;/script&gt; 使用 &lt;XtxInfiniteLoading :loading=&quot;loading&quot; :finished=&quot;finished&quot; @infinite=&quot;getData&quot; /&gt; 8.商品详情放大镜组件 步骤 首先准备大图容器和遮罩容器 然后使用@vueuse/core的useMouseInElement方法获取基于元素的偏移量 计算出 遮罩容器定位与大容器北京定位 暴露出数据给模板使用 放大镜效果落地代码 // 放大镜效果 const usePreviewImg = () =&gt; { // 是否显示遮罩和大图 const show = ref(false) const target = ref(null) // elementX 鼠标基于容器左上角X轴偏移 // elementY 鼠标基于容器左上角Y轴偏移 // isOutside 鼠标是否在模板容器外 const { elementX, elementY, isOutside} = useMouseInElement(target) // 遮罩的位置 const position = reactive({ left: 0, top: 0 }) // 大图的位置 const bgPosition = reactive({ backgroundPositionX: 0, backgroundPositionY: 0 }) watch([elementX, elementY, isOutside], () =&gt; { // 控制X轴方向的定位 0-200 之间 if (elementX.value &lt; 100) position.left = 0 else if (elementX.value &gt; 300) position.left = 200 else position.left = elementX.value - 100 // 控制Y轴方向的定位 0-200 之间 if (elementY.value &lt; 100) position.top = 0 else if (elementY.value &gt; 300) position.top = 200 else position.top = elementY.value - 100 // 设置大背景的定位 bgPosition.backgroundPositionX = -position.left * 2 + 'px' bgPosition.backgroundPositionY = -position.top * 2 + 'px' // 设置遮罩容器的定位 position.left = position.left + 'px' position.top = position.top + 'px' // 设置是否显示预览大图 show.value = !isOutside.value }) return { position, bgPosition, show, target } } 9.本地购物车操作和合并线上购物车 购物车实现步骤： 当用户进行购物车操作时，下判断是否登录 未登录状态下，通过mutations修改vuex数据，这里vuex已实现数据持久化。 当用户登录后，在actions中调用后台接口，响应成功后通过mutations修改vuex中的数据，然后将本地购物车和线上购物车合并，并且清除掉本地的购物车， 没登录状态下就是本地操作，登录状态下的是调用后台接口进行操作的 10.路由导航守卫router.beforeEach((to, from,next) =&gt; { // ... // 返回 false 以取消导航 return false }) `to: 即将要进入的目标` `from: 当前导航正要离开的路由` `next:放行`","link":"/2022/08/01/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"个人项目","slug":"个人项目","link":"/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"categories":[]}