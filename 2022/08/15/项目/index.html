<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="Hexo">
  <link 
    rel="icon" 
    href="/">
  <title>Super</title>
  
    
      <meta 
        property="og:title" 
        content="Super">
    
    
      <meta 
        property="og:url" 
        content="http://example.com/2022/08/15/%E9%A1%B9%E7%9B%AE/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://img.songhn.com/img/Y67gdd.png">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-08-15">
      <meta 
        property="og:article:modified_time" 
        content="2022-08-15">
      <meta 
        property="og:article:author" 
        content="超人不会飞">
      
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
      <span class="navbar-logo-dsc">Super</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首页
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          归档
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          标签
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分类
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          关于
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          友链
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://img.songhn.com/img/Y67gdd.png" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">超人不会飞</p>
<p class="author-description">前端小白的进阶之路</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>2</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>0</span>
    <span>分类</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>0</span>
    <span>标签</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%AE%A1%E9%87%8C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">后台管里系统-权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8C%B9%E9%85%8D%E4%BB%A3%E7%A0%81"><span class="toc-text">1.路由信息匹配代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-axios%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81"><span class="toc-text">2.axios的封装代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%9F%8E%E5%A4%8F%E5%A4%A9%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0"><span class="toc-text">小城夏天电商平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vueX%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">1.vueX持久化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%B0%81%E8%A3%85"><span class="toc-text">2.骨架屏封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%B0%81%E8%A3%85"><span class="toc-text">3.轮播图封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">4.数据懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90useIntersectionObserver%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">分析useIntersectionObserver的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">封装的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">5.图片懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIntersectionObserver"><span class="toc-text">介绍一下IntersectionObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">自定义指令的封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">如何自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%E6%88%96%E5%B1%9E%E6%80%A7"><span class="toc-text">如何自定义全局方法或属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">如何自定义全局组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%A2%E5%8C%85%E5%B1%91%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">6.面包屑组件的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="toc-text">7.批量注册组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%97%A0%E9%99%90%E5%8A%A0%E8%BD%BD"><span class="toc-text">8.无限加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E6%94%BE%E5%A4%A7%E9%95%9C%E7%BB%84%E4%BB%B6"><span class="toc-text">8.商品详情放大镜组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%AC%E5%9C%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%93%8D%E4%BD%9C%E5%92%8C%E5%90%88%E5%B9%B6%E7%BA%BF%E4%B8%8A%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-text">9.本地购物车操作和合并线上购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-text">10.路由导航守卫</span></a></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分类
  </div>
  <div class="categories-list">
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>热门标签
  </div>
  <div class="tags-list">
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-08-15T02:52:42.229Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-08-15</span>
    </time>
    
    
      <span class="dot"></span>
      <span>4.7k 字</span>
    
  </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <p>小城夏天电商平台线上地址：<a target="_blank" rel="noopener" href="http://jay1124.web3v.work/#/">http://jay1124.web3v.work/#/</a></p>
<p>GitHub：<a target="_blank" rel="noopener" href="https://github.com/BoLinJay/xiaochengxiaitian">https://github.com/BoLinJay/xiaochengxiaitian</a><br>@[toc]</p>
<h2 id="后台管里系统-权限控制"><a href="#后台管里系统-权限控制" class="headerlink" title="后台管里系统-权限控制"></a>后台管里系统-权限控制</h2><blockquote>
<p>前端权限的意义<br>如果仅从能够修改服务器中数据库中的数据层面上讲， 确实只在后端做控制就足够了， 那为什么越来越多的项目也进行了前端权限的控制， 主要有这几方面的好处</p>
<p>1.降低非法操作的可能性<br>2.尽可能排除不必要清求， 减轻服务器压力<br>3.提高用户体验</p>
</blockquote>
<p><strong>实现步骤，方法</strong></p>
<blockquote>
<p>接口访问的权限控制，这个就是利用<code>axios</code>拦截器，判断token是否存在，访问有关页面时携带token,<br>菜单列表的权限控制，分为两种：</p>
<ul>
<li>显示所有菜单，用户访问不在自己权限中的页面时，提醒无权限</li>
<li>只显示当前用户能访问的权限内菜单，如果用户通过URL强制访问页面则返回404</li>
</ul>
<p>1.先创建一个不需要权限访问的路由表，比如登录页，404页面，在把需要权限的路由表创建出来，<code>这里的404页面要写在路由列表的最后，所有使用路由懒加载的方式创建</code>这里的权限路由表可以不创建，直接从后端获取，但是后期维护和添加新需求麻烦。</p>
<p>2.获取后端传送来的路由信息，和路由表作比较，生成最总用户可以访问的路由表</p>
<p>3.使用<code>router.addRoutes</code>添加用户所需要的路由信息</p>
<p>4.可以使用vuex管理路由表，进行永久存储，然后从vuex中获取路由表进行渲染</p>
<p>5.数据操作权限可以加载路由元数据中<code>meta</code>中 ，使用v-if&#x2F;v-show，根据数据进行动态显示，也可注册一个自定义指令<br><img src="https://img-blog.csdnimg.cn/354b41cdbf4a48f88fc5bb0c0613e89e.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/354b41cdbf4a48f88fc5bb0c0613e89e.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/354b41cdbf4a48f88fc5bb0c0613e89e.png"><br><img src="https://img-blog.csdnimg.cn/5a201436392b4765b7d8c167785d9038.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/5a201436392b4765b7d8c167785d9038.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/5a201436392b4765b7d8c167785d9038.png"></p>
</blockquote>
<p>接口访问的接口控制，这个就是利用<code>axios</code>拦截器，判断token是否存在，访问有关页面时携带token,</p>
<pre class="highlight"><span class="line"><span class="comment">// 每次请求都为http头增加Authorization字段，其内容为token</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>) &#123;</span><br><span class="line">            config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`token <span class="subst">$&#123;store.state.user.token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre>

<p>2.菜单列表的权限控制，分为两种：</p>
<ul>
<li>显示所有菜单，用户访问不在自己权限中的页面时，提醒无权限</li>
<li>只显示当前用户能访问的权限内菜单，如果用户通过URL强制访问页面则返回404</li>
</ul>
<p>很显然，第一种方法不合适，那咱们梳理一下第二种方法，大致流程为：</p>
<p><img src="https://img-blog.csdnimg.cn/ef1b1f3983e14dd782fb2f7f629328dd.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/ef1b1f3983e14dd782fb2f7f629328dd.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/ef1b1f3983e14dd782fb2f7f629328dd.png"></p>
<p>配置自定义指令代码</p>
<pre class="highlight"><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">//按扭权限指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;allow&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function">(<span class="params">el, binding, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> permissionList = vnode.<span class="property">context</span>.<span class="property">$route</span>.<span class="property">meta</span>.<span class="property">permission</span>;</span><br><span class="line">    <span class="keyword">if</span> (!permissionList.<span class="title function_">includes</span>(binding.<span class="property">value</span>)) &#123;</span><br><span class="line">      el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre>



<h3 id="1-路由信息匹配代码"><a href="#1-路由信息匹配代码" class="headerlink" title="1.路由信息匹配代码"></a>1.路由信息匹配代码</h3><pre class="highlight"><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据权限匹配路由</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; permission 权限列表（菜单列表）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; asyncRouter 异步路由对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">routerMatch</span>(<span class="params">permission, asyncRouter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> routers = [];</span><br><span class="line">    <span class="comment">// 创建路由</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createRouter</span>(<span class="params">permission</span>) &#123;</span><br><span class="line">         <span class="comment">// 根据路径匹配到的router对象添加到routers中即可</span></span><br><span class="line">      permission.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">children</span> &amp;&amp; item.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">createRouter</span>(item.<span class="property">children</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> path = item.<span class="property">path</span>;</span><br><span class="line">        <span class="comment">// 循环异步路由，将符合权限列表的路由加入到routers中</span></span><br><span class="line">        asyncRouter.<span class="title function_">find</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (s.<span class="property">path</span> === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="property">children</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (y.<span class="property">path</span> === path) &#123;</span><br><span class="line">                y.<span class="property">meta</span>.<span class="property">permission</span> = item.<span class="property">permission</span>;</span><br><span class="line">                routers.<span class="title function_">push</span>(s);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s.<span class="property">path</span> === path) &#123;</span><br><span class="line">            s.<span class="property">meta</span>.<span class="property">permission</span> = item.<span class="property">permission</span>;</span><br><span class="line">            routers.<span class="title function_">push</span>(s);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createRouter</span>(permission)</span><br><span class="line">    <span class="title function_">resolve</span>([routers])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>

<h3 id="2-axios的封装代码"><a href="#2-axios的封装代码" class="headerlink" title="2.axios的封装代码"></a>2.axios的封装代码</h3><pre class="highlight"><span class="line"><span class="comment">// 1. 创建一个新的axios实例</span></span><br><span class="line"><span class="comment">// 2. 请求拦截器，如果有token进行头部携带</span></span><br><span class="line"><span class="comment">// 3. 响应拦截器：1. 剥离无效数据  2. 处理token失效</span></span><br><span class="line"><span class="comment">// 4. 导出一个函数，调用当前的axsio实例发请求，返回值promise</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出基准地址，原因：其他地方不是通过axios发请求的地方用上基准地址</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseURL = <span class="string">&#x27;http://pcapi-xiaotuxian-front-devtest.itheima.net/&#x27;</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// axios 的一些配置，baseURL  timeout</span></span><br><span class="line">  baseURL,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拦截业务逻辑</span></span><br><span class="line">  <span class="comment">// 进行请求配置的修改</span></span><br><span class="line">  <span class="comment">// 如果本地又token就在头部携带</span></span><br><span class="line">  <span class="comment">// 1. 获取用户信息对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; profile &#125; = store.<span class="property">state</span>.<span class="property">user</span></span><br><span class="line">  <span class="comment">// 2. 判断是否有token</span></span><br><span class="line">  <span class="keyword">if</span> (profile.<span class="property">token</span>) &#123;</span><br><span class="line">    <span class="comment">// 3. 设置token</span></span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;profile.token&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// res =&gt; res.data  取出data数据，将来调用接口的时候直接拿到的就是后台的数据</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="property">data</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 401 状态码，进入该函数</span></span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span> &amp;&amp; err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 清空无效用户信息</span></span><br><span class="line">    <span class="comment">// 2. 跳转到登录页</span></span><br><span class="line">    <span class="comment">// 3. 跳转需要传参（当前路由地址）给登录页码</span></span><br><span class="line">    store.<span class="title function_">commit</span>(<span class="string">&#x27;user/setUser&#x27;</span>, &#123;&#125;)</span><br><span class="line">    <span class="comment">// 当前路由地址</span></span><br><span class="line">    <span class="comment">// 组件里头：`/user?a=10` $route.path === /user  $route.fullPath === /user?a=10</span></span><br><span class="line">    <span class="comment">// js模块中：router.currentRoute.value.fullPath 就是当前路由地址，router.currentRoute 是ref响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> fullPath = <span class="built_in">encodeURIComponent</span>(router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">fullPath</span>)</span><br><span class="line">    <span class="comment">// encodeURIComponent 转换uri编码，防止解析地址出问题</span></span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/login?redirectUrl=&#x27;</span> + fullPath)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求工具函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (url, method, submitData) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 负责发请求：请求地址，请求方式，提交的数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">instance</span>(&#123;</span><br><span class="line">    url,</span><br><span class="line">    method,</span><br><span class="line">    <span class="comment">// 1. 如果是get请求  需要使用params来传递submitData   ?a=10&amp;c=10</span></span><br><span class="line">    <span class="comment">// 2. 如果不是get请求  需要使用data来传递submitData   请求体传参</span></span><br><span class="line">    <span class="comment">// [] 设置一个动态的key, 写js表达式，js表达式的执行结果当作KEY</span></span><br><span class="line">    <span class="comment">// method参数：get,Get,GET  转换成小写再来判断</span></span><br><span class="line">    <span class="comment">// 在对象，[&#x27;params&#x27;]:submitData ===== params:submitData 这样理解</span></span><br><span class="line">    [method.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;get&#x27;</span> ? <span class="string">&#x27;params&#x27;</span> : <span class="string">&#x27;data&#x27;</span>]: submitData</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre>

<h2 id="小城夏天电商平台"><a href="#小城夏天电商平台" class="headerlink" title="小城夏天电商平台"></a>小城夏天电商平台</h2><h3 id="1-vueX持久化方法"><a href="#1-vueX持久化方法" class="headerlink" title="1.vueX持久化方法"></a>1.vueX持久化方法</h3><blockquote>
<ul>
<li>使用插件  vuex-persistedstate</li>
<li>存储本地 localStorage ,</li>
</ul>
</blockquote>
<h3 id="2-骨架屏封装"><a href="#2-骨架屏封装" class="headerlink" title="2.骨架屏封装"></a>2.骨架屏封装</h3><blockquote>
<p>步骤： 基础布局，props，接收参数：高度，宽度，背景色，是否开启动画</p>
</blockquote>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;xtx-skeleton&quot; :style=&quot;&#123;width,height&#125;&quot; :class=&quot;&#123;shan:animated&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 1 盒子--&gt;</span><br><span class="line">    &lt;div class=&quot;block&quot; :style=&quot;&#123;backgroundColor:bg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 2 闪效果 xtx-skeleton 伪元素 ---&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre>

<h3 id="3-轮播图封装"><a href="#3-轮播图封装" class="headerlink" title="3.轮播图封装"></a>3.轮播图封装</h3><blockquote>
<p>完成基础布局，逻辑封装有下一页，上一页，自动播放，自动播放的间隔时间</p>
<p>步骤：</p>
<p>props接收：数据信息，是否自动播放，自动播放的间隔时间</p>
<p>使用<code>ref</code>定义一个num类型的响应式数据，用来控制显示哪张图片，<code>v-for</code>遍历数据，<code>v-bind</code>绑定<code>class</code>样式，判断当前图片索引和定义的数据相等，就给他加样式样式<code>opacity：1</code>和<code>z-index:</code>,默认样式都是不显示的，上下页按钮绑定事件，改变响应式数据的值，从而实现图片的切换。</p>
<p>自动播放:开启一个定时器，改边这个响应式数据的值，实现自动切换，自动播放的间隔时间就是传进来的props值</p>
</blockquote>
<h3 id="4-数据懒加载"><a href="#4-数据懒加载" class="headerlink" title="4.数据懒加载"></a>4.数据懒加载</h3><blockquote>
<p>步骤：</p>
<p>进入可视区时才调用<code>API</code>函数获取数据，</p>
<p>使用<code>@vueuse/core</code> 中的 <code>useIntersectionObserver</code>的插件监听DOM元素是否进入可视区，封装一个函数，接收内观察的对象和<code>API</code>函数,return数据和该DOM元素</p>
</blockquote>
<h4 id="分析useIntersectionObserver的参数"><a href="#分析useIntersectionObserver的参数" class="headerlink" title="分析useIntersectionObserver的参数"></a>分析<code>useIntersectionObserver</code>的参数</h4><pre class="highlight"><span class="line"><span class="comment">// stop 是停止观察是否进入或移出可视区域的行为    </span></span><br><span class="line"><span class="keyword">const</span> &#123; stop &#125; = <span class="title function_">useIntersectionObserver</span>(</span><br><span class="line">  <span class="comment">// target 是观察的目标dom容器，必须是dom容器，而且是vue3.0方式绑定的dom对象</span></span><br><span class="line">  target,</span><br><span class="line">  <span class="comment">// isIntersecting 是否进入可视区域，true是进入 false是移出</span></span><br><span class="line">  <span class="comment">// observerElement 被观察的dom</span></span><br><span class="line">  <span class="function">(<span class="params">[&#123; isIntersecting &#125;], observerElement</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在此处可根据isIntersecting来判断，然后做业务</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre>

<h4 id="封装的函数"><a href="#封装的函数" class="headerlink" title="封装的函数"></a>封装的函数</h4><pre class="highlight"><span class="line"><span class="comment">// hooks 封装逻辑，提供响应式数据。</span></span><br><span class="line"><span class="keyword">import</span> &#123; useIntersectionObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 数据懒加载函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useLazyData</span> = (<span class="params">apiFn</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 需要</span></span><br><span class="line">  <span class="comment">// 1. 被观察的对象</span></span><br><span class="line">  <span class="comment">// 2. 不同的API函数</span></span><br><span class="line">  <span class="keyword">const</span> target = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="keyword">const</span> &#123; stop &#125; = <span class="title function_">useIntersectionObserver</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="function">(<span class="params">[&#123; isIntersecting &#125;], observerElement</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isIntersecting) &#123;</span><br><span class="line">        <span class="title function_">stop</span>()</span><br><span class="line">        <span class="comment">// 调用API获取数据</span></span><br><span class="line">        <span class="title function_">apiFn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          result.<span class="property">value</span> = data.<span class="property">result</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 返回---&gt;数据（dom,后台数据）</span></span><br><span class="line">  <span class="keyword">return</span> &#123; target, result &#125;</span><br><span class="line">&#125;</span><br></pre>

<h3 id="5-图片懒加载"><a href="#5-图片懒加载" class="headerlink" title="5.图片懒加载"></a>5.图片懒加载</h3><blockquote>
<p>步骤</p>
<p>使用webAPI:<code>IntersectionObserver</code>判断图片是否进入可视区，封装了一个自定义指令,进行<code>src</code>的替换，在<code>img</code>上使用使用<code>v-lazyload</code>值为图片地址，不设置<code>src</code>属性</p>
<p>封装自定义指令的方法vue2：vue.directive,vue3:app.directive</p>
</blockquote>
<h4 id="介绍一下IntersectionObserver"><a href="#介绍一下IntersectionObserver" class="headerlink" title="介绍一下IntersectionObserver"></a>介绍一下<code>IntersectionObserver</code></h4><pre class="highlight"><span class="line"><span class="comment">// 创建观察对象实例</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback[, options])</span><br><span class="line"><span class="comment">// callback 被观察dom进入可视区离开可视区都会触发</span></span><br><span class="line"><span class="comment">// - 两个回调参数 entries , observer</span></span><br><span class="line"><span class="comment">// - entries 被观察的元素信息对象的数组 [&#123;元素信息&#125;,&#123;&#125;]，信息中isIntersecting判断进入或离开</span></span><br><span class="line"><span class="comment">// - observer 就是观察实例</span></span><br><span class="line"><span class="comment">// options 配置参数</span></span><br><span class="line"><span class="comment">// - 三个配置属性 root rootMargin threshold</span></span><br><span class="line"><span class="comment">// - root 基于的滚动容器，默认是document</span></span><br><span class="line"><span class="comment">// - rootMargin 容器有没有外边距</span></span><br><span class="line"><span class="comment">// - threshold 交叉的比例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例提供两个方法</span></span><br><span class="line"><span class="comment">// observe(dom) 观察哪个dom</span></span><br><span class="line"><span class="comment">// unobserve(dom) 停止观察那个dom</span></span><br></pre>

<h4 id="自定义指令的封装"><a href="#自定义指令的封装" class="headerlink" title="自定义指令的封装"></a>自定义指令的封装</h4><pre class="highlight"><span class="line"><span class="keyword">import</span> defaultImg <span class="keyword">from</span> <span class="string">&#x27;@/assets/images/200.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DirectiveImage</span> = (<span class="params">app</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 图片懒加载指令</span></span><br><span class="line">    app.<span class="title function_">directive</span>(<span class="string">&#x27;lazyload&#x27;</span>, &#123;</span><br><span class="line">        <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(isIntersecting) &#123;</span><br><span class="line">                    <span class="comment">// 进入可视区后停止观察</span></span><br><span class="line">                    observer.<span class="title function_">unobserve</span>(el)</span><br><span class="line">                    <span class="comment">// 图片加载失败显示默认图片</span></span><br><span class="line">                    <span class="comment">//onerror 事件会在文档或图像加载过程中发生错误时被触发。</span></span><br><span class="line">                    el.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        el.<span class="property">src</span> = defaultImg</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 替换src</span></span><br><span class="line">                        el.<span class="property">src</span> = binding.<span class="property">value</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">threshold</span>:<span class="number">0.01</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 开始观察</span></span><br><span class="line">            observer.<span class="title function_">observe</span>(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre>



<h4 id="如何自定义指令"><a href="#如何自定义指令" class="headerlink" title="如何自定义指令"></a>如何自定义指令</h4><ul>
<li>定义局部自定义指令</li>
</ul>
<blockquote>
<p>局部自定义指令需要在组件的<code>directives</code>结构中定义，它是一个单独的结构</p>
</blockquote>
<pre class="highlight"><span class="line"><span class="comment">//vue3和vue2的组件自定义指令方法相同，只是钩子函数不同</span></span><br><span class="line"><span class="attr">directives</span>:&#123;</span><br><span class="line">    指令名称：&#123;</span><br><span class="line">			钩子函数</span><br><span class="line">     &#125;</span><br></pre>

<ul>
<li>自定义全局指令<br><img src="https://img-blog.csdnimg.cn/7ef0fb5d19f7450ea067deab1a59fa8e.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/7ef0fb5d19f7450ea067deab1a59fa8e.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/7ef0fb5d19f7450ea067deab1a59fa8e.png"></li>
</ul>
<pre class="highlight"><span class="line"><span class="comment">//vue2</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;directiveName&#x27;</span>, &#123;</span><br><span class="line">  	<span class="comment">//钩子函数</span></span><br><span class="line">    bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line">    inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line">    update：所在组件的 <span class="title class_">VNode</span> 更新时调用，但是可能发生在其子 <span class="title class_">VNode</span> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</span><br><span class="line">    componentUpdated：指令所在组件的 <span class="title class_">VNode</span> 及其子 <span class="title class_">VNode</span> 全部更新后调用。</span><br><span class="line">    unbind：只调用一次，指令与元素解绑时调用。</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3全局指令</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;directiveName&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 在绑定元素的 attribute 或事件监听器被应用之前调用, 在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用</span></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 当指令第一次绑定到元素并且在挂载父组件之前调用</span></span><br><span class="line">    <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 在绑定元素的父组件被挂载后调用</span></span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 在更新包含组件的 VNode 之前调用</span></span><br><span class="line">    <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 在包含组件的 VNode 及其子组件的 VNode 更新后调用</span></span><br><span class="line">    <span class="title function_">updated</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 在卸载绑定元素的父组件之前调用</span></span><br><span class="line">    <span class="title function_">beforeUnmount</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 当指令与元素解除绑定且父组件已卸载时, 只调用一次</span></span><br><span class="line">    <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre>

<h4 id="如何自定义全局方法或属性"><a href="#如何自定义全局方法或属性" class="headerlink" title="如何自定义全局方法或属性"></a>如何自定义全局方法或属性</h4><blockquote>
<p>原理：在 <code>Vue.prototype</code> 上添加了一个方法</p>
</blockquote>
<ul>
<li>使用<code>Vue.prototype</code></li>
</ul>
<pre class="highlight"><span class="line"><span class="comment">// 在main.js中写</span></span><br><span class="line"> <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getData</span> = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre>

<ul>
<li>使用install + <code>Vue.prototype</code></li>
</ul>
<pre class="highlight"><span class="line"> <span class="comment">// 在你的全局函数文件fun.js中写</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      install (<span class="title class_">Vue</span>) &#123;</span><br><span class="line">        <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getData</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;scout&#x27;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// main.js 引入</span></span><br><span class="line">   <span class="keyword">import</span> getData <span class="keyword">from</span> <span class="string">&#x27;./fun&#x27;</span></span><br><span class="line">   <span class="title class_">Vue</span>.<span class="title function_">use</span>(getData) </span><br></pre>

<h4 id="如何自定义全局组件"><a href="#如何自定义全局组件" class="headerlink" title="如何自定义全局组件"></a>如何自定义全局组件</h4><ul>
<li>vue2</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment">// 公共vue组件: components文件夹下面的Loading.vue文件：</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LoadingComponent</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Loading&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install (<span class="title class_">Vue</span>) &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;Loading&#x27;</span>, <span class="title class_">LoadingComponent</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局组件： public文件夹下面的Loading.js文件。在main.js中引入:</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loading</span> <span class="keyword">from</span> <span class="string">&quot;@/public/Loading&quot;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Loading</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在vue任何组件上都可以直接使用：&lt;Loading /&gt;</span></span><br></pre>

<ul>
<li>vue3</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment">/* 以下两种二选一 */</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">//组件全局注册: app.component(&#x27;组件名 用其调用 短横线分割命名&#x27;,组件对象 name 首字母大写命名)</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;side-box&#x27;</span>,sideBox) </span><br></pre>

<h3 id="6-面包屑组件的封装"><a href="#6-面包屑组件的封装" class="headerlink" title="6.面包屑组件的封装"></a>6.面包屑组件的封装</h3><blockquote>
<p>总结，一下知识点</p>
<ul>
<li><p>render 是vue提供的一个渲染函数，优先级大于el,template等选项，用来提供组件结构。</p>
</li>
<li><p>注意：</p>
<ul>
<li>vue2.0 render函数提供h（createElement）函数用来创建节点</li>
<li>vue3.0 h（createElement）函数有 vue 直接提供，需要按需导入</li>
</ul>
</li>
<li><p>this.$slots.default() 获取默认插槽的node结构，按照要求拼接结构。</p>
</li>
<li><p>h函数的传参 tag 标签名|组件名称, props 标签属性|组件属性, node 子节点|多个节点</p>
</li>
<li><p>具体参考 <a target="_blank" rel="noopener" href="http://zhoushugang.gitee.io/erabbit-client-pc-document/guide/[https:/vue-docs-next-zh-cn.netlify.app/guide/render-function.html#dom-%E6%A0%91](https:/vue-docs-next-zh-cn.netlify.app/guide/render-function.html#dom-%E6%A0%91)">render</a></p>
</li>
<li><p>注意：不要在 xtx-bread 组件插槽写注释，也会被解析。</p>
</li>
</ul>
</blockquote>
<pre class="highlight"><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;XtxBread&#x27;</span>,</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 用法</span></span><br><span class="line">    <span class="comment">// 1. template 标签去除，单文件组件</span></span><br><span class="line">    <span class="comment">// 2. 返回值就是组件内容</span></span><br><span class="line">    <span class="comment">// 3. vue2.0 的h函数传参进来的，vue3.0 的h函数导入进来</span></span><br><span class="line">    <span class="comment">// 4. h 第一个参数 标签名字  第二个参数 标签属性对象  第三个参数 子节点</span></span><br><span class="line">    <span class="comment">// 需求</span></span><br><span class="line">    <span class="comment">// 1. 创建xtx-bread父容器</span></span><br><span class="line">    <span class="comment">// 2. 获取默认插槽内容</span></span><br><span class="line">    <span class="comment">// 3. 去除xtx-bread-item组件的i标签，因该由render函数来组织</span></span><br><span class="line">    <span class="comment">// 4. 遍历插槽中的item，得到一个动态创建的节点，最后一个item不加i标签</span></span><br><span class="line">    <span class="comment">// 5. 把动态创建的节点渲染再xtx-bread标签中</span></span><br><span class="line">    <span class="keyword">const</span> items = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>()</span><br><span class="line">    <span class="keyword">const</span> dymanicItems = []</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      dymanicItems.<span class="title function_">push</span>(item)</span><br><span class="line">      <span class="keyword">if</span> (i &lt; (items.<span class="property">length</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">        dymanicItems.<span class="title function_">push</span>(<span class="title function_">h</span>(<span class="string">&#x27;i&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;iconfont icon-angle-right&#x27;</span> &#125;))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;xtx-bread&#x27;</span> &#125;, dymanicItems)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>

<h3 id="7-批量注册组件"><a href="#7-批量注册组件" class="headerlink" title="7.批量注册组件"></a>7.批量注册组件</h3><blockquote>
<p>步骤：</p>
<ul>
<li>使用 <code>require</code> 提供的函数 <code>context</code> 加载某一个目录下的所有 <code>.vue</code> 后缀的文件。</li>
<li>然后context函数会返回一个导入函数importFn<ul>
<li>它有一个属性 <code>keys()</code> 获取所有的文件路径</li>
</ul>
</li>
<li>通过文件路径数组，通过遍历数组，再使用 <code>importFn</code> 根据路径导入组件对象</li>
<li>遍历的同时进行全局注册即可</li>
</ul>
</blockquote>
<pre class="highlight"><span class="line"><span class="comment">// 批量导入需要使用一个函数 require.context(dir,deep,matching)</span></span><br><span class="line"><span class="comment">// 参数：1. 目录  2. 是否加载子目录  3. 加载的正则匹配</span></span><br><span class="line"><span class="keyword">const</span> importFn = <span class="built_in">require</span>.<span class="title function_">context</span>(<span class="string">&#x27;./&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/\.vue$/</span>)</span><br><span class="line"><span class="comment">// console.dir(importFn.keys()) 文件名称数组</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Message</span> <span class="keyword">from</span> <span class="string">&#x27;./Message&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">app</span>) &#123;</span><br><span class="line">        <span class="comment">// 全自动批量注册   牛逼克拉斯 </span></span><br><span class="line">        importFn.<span class="title function_">keys</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 导入组件</span></span><br><span class="line">            <span class="keyword">const</span> component = <span class="title function_">importFn</span>(key).<span class="property">default</span></span><br><span class="line">                  <span class="comment">// 注册组件</span></span><br><span class="line">            app.<span class="title function_">component</span>(component.<span class="property">name</span>, component)</span><br><span class="line">        &#125;);</span><br><span class="line"> 总结：</span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">context</span>(参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3</span>) 是webpack提供的一个自动导入的<span class="variable constant_">API</span></span><br><span class="line">参数<span class="number">1</span>：加载的文件目录</span><br><span class="line">参数<span class="number">2</span>：是否加载子目录</span><br><span class="line">参数<span class="number">3</span>：正则，匹配文件</span><br><span class="line">返回值：导入函数 fn</span><br><span class="line"><span class="title function_">keys</span>() 获取读取到的所有文件列表</span><br><span class="line">#<span class="number">04</span>-顶级类目-基础布局搭建</span><br></pre>

<h3 id="8-无限加载"><a href="#8-无限加载" class="headerlink" title="8.无限加载"></a>8.无限加载</h3><blockquote>
<p>无限加载其实就是根据页码显示数据的另一种表现形式</p>
<p>步骤 </p>
<ul>
<li>判断是否进入可视区，进入可视区后调用函数获取数据，每获取一组数据将页码+1，没有数据则返回FALSE，并把阻止请求</li>
</ul>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/fc7811c768f7416f9f5ae826ff10f2fc.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/fc7811c768f7416f9f5ae826ff10f2fc.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/fc7811c768f7416f9f5ae826ff10f2fc.png"></p>
<p>落地代码</p>
<ul>
<li>封装的无限加载组件</li>
</ul>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xtx-infinite-loading&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;loading&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;none&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;finished&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>亲，没有更多了<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useIntersectionObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;XtxInfiniteLoading&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">loading</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">finished</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  setup (props, &#123; emit &#125;) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> container = <span class="title function_">ref</span>(<span class="literal">null</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">useIntersectionObserver</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      container,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="function">(<span class="params">[&#123; isIntersecting &#125;], dom</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (isIntersecting) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">if</span> (props.<span class="property">loading</span> === <span class="literal">false</span> &amp;&amp; props.<span class="property">finished</span> === <span class="literal">false</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">emit</span>(<span class="string">&#x27;infinite&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">threshold</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    )</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123; container &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre>

<ul>
<li>使用</li>
</ul>
<pre class="highlight"><span class="line">&lt;<span class="title class_">XtxInfiniteLoading</span> :loading=<span class="string">&quot;loading&quot;</span> :finished=<span class="string">&quot;finished&quot;</span> @infinite=<span class="string">&quot;getData&quot;</span> /&gt;</span><br></pre>

<h3 id="8-商品详情放大镜组件"><a href="#8-商品详情放大镜组件" class="headerlink" title="8.商品详情放大镜组件"></a>8.商品详情放大镜组件</h3><blockquote>
<p>步骤</p>
<ul>
<li>首先准备大图容器和遮罩容器</li>
<li>然后使用<code>@vueuse/core</code>的<code>useMouseInElement</code>方法获取基于元素的偏移量</li>
<li>计算出 遮罩容器定位与大容器北京定位 暴露出数据给模板使用</li>
</ul>
</blockquote>
<p>放大镜效果落地代码</p>
<pre class="highlight"><span class="line"><span class="comment">// 放大镜效果</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">usePreviewImg</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 是否显示遮罩和大图</span></span><br><span class="line">    <span class="keyword">const</span> show = <span class="title function_">ref</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> target = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">   <span class="comment">// elementX 鼠标基于容器左上角X轴偏移</span></span><br><span class="line">  <span class="comment">// elementY 鼠标基于容器左上角Y轴偏移</span></span><br><span class="line">  <span class="comment">// isOutside 鼠标是否在模板容器外</span></span><br><span class="line">    <span class="keyword">const</span> &#123; elementX, elementY, isOutside&#125; = <span class="title function_">useMouseInElement</span>(target)</span><br><span class="line">      <span class="comment">// 遮罩的位置</span></span><br><span class="line">    <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">        <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">top</span>: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 大图的位置</span></span><br><span class="line">    <span class="keyword">const</span> bgPosition = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">        <span class="attr">backgroundPositionX</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">backgroundPositionY</span>: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">watch</span>([elementX, elementY, isOutside], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 控制X轴方向的定位 0-200 之间</span></span><br><span class="line">        <span class="keyword">if</span> (elementX.<span class="property">value</span> &lt; <span class="number">100</span>) position.<span class="property">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (elementX.<span class="property">value</span> &gt; <span class="number">300</span>) position.<span class="property">left</span> = <span class="number">200</span></span><br><span class="line">        <span class="keyword">else</span> position.<span class="property">left</span> = elementX.<span class="property">value</span> - <span class="number">100</span></span><br><span class="line">        <span class="comment">// 控制Y轴方向的定位 0-200 之间</span></span><br><span class="line">        <span class="keyword">if</span> (elementY.<span class="property">value</span> &lt; <span class="number">100</span>) position.<span class="property">top</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (elementY.<span class="property">value</span> &gt; <span class="number">300</span>) position.<span class="property">top</span> = <span class="number">200</span></span><br><span class="line">        <span class="keyword">else</span> position.<span class="property">top</span> = elementY.<span class="property">value</span> - <span class="number">100</span></span><br><span class="line">        <span class="comment">// 设置大背景的定位</span></span><br><span class="line">        bgPosition.<span class="property">backgroundPositionX</span> = -position.<span class="property">left</span> * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        bgPosition.<span class="property">backgroundPositionY</span> = -position.<span class="property">top</span> * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">         <span class="comment">// 设置遮罩容器的定位</span></span><br><span class="line">        position.<span class="property">left</span> = position.<span class="property">left</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        position.<span class="property">top</span> = position.<span class="property">top</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 设置是否显示预览大图</span></span><br><span class="line">        show.<span class="property">value</span> = !isOutside.<span class="property">value</span></span><br><span class="line">        &#125;)</span><br><span class="line">         <span class="keyword">return</span> &#123; position, bgPosition, show, target &#125;</span><br><span class="line">    &#125;</span><br></pre>

<h3 id="9-本地购物车操作和合并线上购物车"><a href="#9-本地购物车操作和合并线上购物车" class="headerlink" title="9.本地购物车操作和合并线上购物车"></a>9.本地购物车操作和合并线上购物车</h3><blockquote>
<p>购物车实现步骤：</p>
<p>当用户进行购物车操作时，下判断是否登录</p>
<p>未登录状态下，通过mutations修改vuex数据，这里vuex已实现数据持久化。</p>
<p>当用户登录后，在actions中调用后台接口，响应成功后通过mutations修改vuex中的数据，然后将本地购物车和线上购物车合并，并且清除掉本地的购物车，</p>
<p>没登录状态下就是本地操作，登录状态下的是调用后台接口进行操作的<br><img src="https://img-blog.csdnimg.cn/ef7f9ca377644a27aa2e0d8c4b2b712a.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/ef7f9ca377644a27aa2e0d8c4b2b712a.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/ef7f9ca377644a27aa2e0d8c4b2b712a.png"><br><img src="https://img-blog.csdnimg.cn/4145220e518f4bc7b69668704bcc6a9c.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/4145220e518f4bc7b69668704bcc6a9c.png" class="lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/4145220e518f4bc7b69668704bcc6a9c.png"></p>
</blockquote>
<h3 id="10-路由导航守卫"><a href="#10-路由导航守卫" class="headerlink" title="10.路由导航守卫"></a>10.路由导航守卫</h3><pre class="highlight"><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 返回 false 以取消导航</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">`to: 即将要进入的目标`</span></span><br><span class="line"><span class="string">`from: 当前导航正要离开的路由`</span></span><br><span class="line"><span class="string">`next:放行`</span></span><br></pre>


  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            超人不会飞
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="http://example.com/2022/08/15/%E9%A1%B9%E7%9B%AE/">
            http://example.com/2022/08/15/%E9%A1%B9%E7%9B%AE/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/08/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
        </div>
      </a>
    </div>
  
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%AE%A1%E9%87%8C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">后台管里系统-权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8C%B9%E9%85%8D%E4%BB%A3%E7%A0%81"><span class="toc-text">1.路由信息匹配代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-axios%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81"><span class="toc-text">2.axios的封装代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%9F%8E%E5%A4%8F%E5%A4%A9%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0"><span class="toc-text">小城夏天电商平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vueX%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">1.vueX持久化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%B0%81%E8%A3%85"><span class="toc-text">2.骨架屏封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%B0%81%E8%A3%85"><span class="toc-text">3.轮播图封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">4.数据懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90useIntersectionObserver%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">分析useIntersectionObserver的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">封装的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">5.图片懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIntersectionObserver"><span class="toc-text">介绍一下IntersectionObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">自定义指令的封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">如何自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%E6%88%96%E5%B1%9E%E6%80%A7"><span class="toc-text">如何自定义全局方法或属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">如何自定义全局组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%A2%E5%8C%85%E5%B1%91%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">6.面包屑组件的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="toc-text">7.批量注册组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%97%A0%E9%99%90%E5%8A%A0%E8%BD%BD"><span class="toc-text">8.无限加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E6%94%BE%E5%A4%A7%E9%95%9C%E7%BB%84%E4%BB%B6"><span class="toc-text">8.商品详情放大镜组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%AC%E5%9C%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%93%8D%E4%BD%9C%E5%92%8C%E5%90%88%E5%B9%B6%E7%BA%BF%E4%B8%8A%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-text">9.本地购物车操作和合并线上购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-text">10.路由导航守卫</span></a></li></ol></li></ol>
</div>
            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%AE%A1%E9%87%8C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">后台管里系统-权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8C%B9%E9%85%8D%E4%BB%A3%E7%A0%81"><span class="toc-text">1.路由信息匹配代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-axios%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81"><span class="toc-text">2.axios的封装代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%9F%8E%E5%A4%8F%E5%A4%A9%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0"><span class="toc-text">小城夏天电商平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vueX%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">1.vueX持久化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%B0%81%E8%A3%85"><span class="toc-text">2.骨架屏封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%B0%81%E8%A3%85"><span class="toc-text">3.轮播图封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">4.数据懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90useIntersectionObserver%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">分析useIntersectionObserver的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">封装的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">5.图片懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIntersectionObserver"><span class="toc-text">介绍一下IntersectionObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">自定义指令的封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">如何自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%E6%88%96%E5%B1%9E%E6%80%A7"><span class="toc-text">如何自定义全局方法或属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-text">如何自定义全局组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%A2%E5%8C%85%E5%B1%91%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">6.面包屑组件的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="toc-text">7.批量注册组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%97%A0%E9%99%90%E5%8A%A0%E8%BD%BD"><span class="toc-text">8.无限加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E6%94%BE%E5%A4%A7%E9%95%9C%E7%BB%84%E4%BB%B6"><span class="toc-text">8.商品详情放大镜组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%AC%E5%9C%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%93%8D%E4%BD%9C%E5%92%8C%E5%90%88%E5%B9%B6%E7%BA%BF%E4%B8%8A%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-text">9.本地购物车操作和合并线上购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-text">10.路由导航守卫</span></a></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最近文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-08-19</div>
        <a href="/2022/08/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"><div class="recent-posts-item-content"></div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-08-15</div>
        <a href="/2022/08/15/%E9%A1%B9%E7%9B%AE/"><div class="recent-posts-item-content"></div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          Super
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
